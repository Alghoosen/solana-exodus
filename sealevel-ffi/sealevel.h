/*
 * libsealevel is a C interface for the Sealevel virtual machine.
 * This version of the library bundles the interpreter and JIT executors part of the Rust implementation of the Solana blockchain.
 *
 * Source code: https://github.com/solana-labs/solana
 *
 * ABI stability is planned, though this version makes no promises yet.
 * Avoid passing objects between two different versions of this library because no internal compatibility guarantees are made.
 *
 * Note that, despite the Rust code under the hood, this interface allows unsafe behavior.
 * The usual C rules apply library-wide: Check for null pointers, avoid aliasing, don't mix types, respect thread safety, no double frees.
 * You may find additional safety remarks on each exported function.
*/

#pragma once

/* Generated with cbindgen:0.23.0 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#define SEALEVEL_ERR_UNKNOWN -1

#define SEALEVEL_OK 0

#define SEALEVEL_ERR_INVALID_ELF 1

#define SEALEVEL_ERR_SYSCALL_REGISTRATION 2

#define SEALEVEL_ERR_CALL_DEPTH_EXCEEDED 3

#define SEALEVEL_ERR_EXIT_ROOT_CALL_FRAME 4

#define SEALEVEL_ERR_DIVIDE_BY_ZERO 5

#define SEALEVEL_ERR_DIVIDE_OVERFLOW 6

#define SEALEVEL_ERR_EXECUTION_OVERRUN 7

#define SEALEVEL_ERR_CALL_OUTSIDE_TEXT_SEGMENT 8

#define SEALEVEL_ERR_EXCEEDED_MAX_INSTRUCTIONS 9

#define SEALEVEL_ERR_JIT_NOT_COMPILED 10

#define SEALEVEL_ERR_INVALID_VIRTUAL_ADDRESS 11

#define SEALEVEL_ERR_INVALID_MEMORY_REGION 12

#define SEALEVEL_ERR_ACCESS_VIOLATION 13

#define SEALEVEL_ERR_STACK_ACCESS_VIOLATION 14

#define SEALEVEL_ERR_INVALID_INSTRUCTION 15

#define SEALEVEL_ERR_UNSUPPORTED_INSTRUCTION 16

#define SEALEVEL_ERR_ERR_EXHAUSTED_TEXT_SEGMENT 17

#define SEALEVEL_ERR_LIBC_INVOCATION_FAILED 18

#define SEALEVEL_ERR_VERIFIER_ERROR 19

/**
 * Sealevel virtual machine config.
 */
typedef struct sealevel_config sealevel_config;

/**
 * A loaded and relocated program.
 *
 * To execute this program, create a VM with `sealevel_vm_create`.
 */
typedef struct sealevel_executable sealevel_executable;

/**
 * The invoke context holds the state of a single transaction execution.
 * It tracks the execution progress (instruction being executed),
 * interfaces with account data,
 * and specifies the on-chain execution rules (precompiles, syscalls, sysvars).
 */
typedef struct sealevel_invoke_context sealevel_invoke_context;

typedef struct sealevel_region sealevel_region;

typedef struct sealevel_vm sealevel_vm;

/**
 * The map of syscalls provided by the virtual machine.
 */
typedef SyscallRegistry *sealevel_syscall_registry;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Creates a new Sealevel machine config.
 *
 * # Safety
 * Call `sealevel_config_free` on the return value after you are done using it.
 * Failure to do so results in a memory leak.
 */
sealevel_config *sealevel_config_new(void);

/**
 * Releases resources associated with a Sealevel machine config.
 *
 * # Safety
 * Avoid the following undefined behavior:
 * - Calling this function given a string that's _not_ the return value of `sealevel_config_new`.
 * - Calling this function more than once on the same object (double free).
 * - Using the config object after calling this function (use-after-free).
 */
void sealevel_config_free(sealevel_config *config);

/**
 * Drops an invoke context and all programs created with it. Noop given a null pointer.
 *
 * # Safety
 * Avoid the following undefined behavior:
 * - Calling this function twice on the same object.
 */
void sealevel_invoke_context_free(sealevel_invoke_context *this_);

/**
 * Returns the error code of this thread's last seen error.
 */
int sealevel_errno(void);

/**
 * Returns a UTF-8 string of this thread's last seen error,
 * or NULL if `sealevel_errno() == SEALEVEL_OK`.
 *
 * # Safety
 * Call `sealevel_strerror_free` on the return value after you are done using it.
 * Failure to do so results in a memory leak.
 */
const char *sealevel_strerror(void);

/**
 * Frees an unused error string gained from `sealevel_strerror`.
 * Calling this with a NULL pointer is a no-op.
 *
 * # Safety
 * Avoid the following undefined behavior:
 * - Calling this function given a string that's _not_ the return value of `sealevel_strerror`.
 * - Calling this function more than once on the same string (double free).
 * - Using a string after calling this function (use-after-free).
 */
void sealevel_strerror_free(const char *str);

/**
 * Loads a Sealevel program from an ELF buffer and verifies its SBF bytecode.
 *
 * Sets `sealevel_errno` and returns a null pointer if loading failed.
 *
 * Consumes the given syscall registry.
 *
 * # Safety
 * Avoid the following undefined behavior:
 * - Using the syscalls object parameter after calling this function (including a second call of this function).
 * - Providing a config object that has been freed with `sealevel_config_free` before.
 */
sealevel_executable *sealevel_load_program(const sealevel_config *config,
                                           sealevel_syscall_registry syscalls,
                                           const char *data,
                                           size_t data_len);

/**
 * Compiles a program to native executable code.
 *
 * Sets `sealevel_errno`.
 *
 * # Safety
 * Avoid the following undefined behavior:
 * - Calling this function twice on the same program.
 * - Calling this function given a null pointer or an invalid pointer.
 */
void sealevel_program_jit_compile(sealevel_executable *program);

/**
 * Creates a Sealevel virtual machine and loads the given program into it.
 *
 * Sets `sealevel_errno` and returns a null pointer if loading failed.
 *
 * The given heap should be 16-byte aligned.
 */
sealevel_vm *sealevel_vm_create(sealevel_executable *program,
                                uint8_t *heap_ptr,
                                size_t heap_len,
                                const sealevel_region *regions_ptr,
                                int regions_count);

uint64_t sealevel_vm_execute(sealevel_vm *vm);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus
