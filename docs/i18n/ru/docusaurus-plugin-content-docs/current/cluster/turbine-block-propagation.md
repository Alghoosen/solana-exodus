---
title: Распространение Turbine Block
---

Кластер Solana использует многослойный механизм распространения блоков под названием _Turbine_ для трансляции транзакции на все узлы с минимальным количеством дублирующих сообщений. Кластер делится на небольшие коллекции узлов, называемых _районами_. Каждый узел отвечает за обмен любыми данными, которые он получает с другими узлами своего района, а также распространение данных на небольшой набор узлов в других районах. Таким образом, каждый узел должен общаться только с небольшим количеством узлов.

Во время слота лидер распределяет между узлами валидатора в первом соседстве \(слой 0\). Каждый валидатор делится данными в пределах своего района, но также передает на один узел в некоторых районах на следующем уровне \(слой 1\). Узлы первого уровня делятся своими данными с соседними соседями, до тех пор, пока все узлы в кластере не получат все штрихи.

## Назначение соседей - взвешенное выделение

Для того чтобы фанат данных работал, весь кластер должен согласиться с тем, как кластер делится на районы. Для достижения этой цели все признанные узлы валидатора \(узлы TVU\) сортируются по ставке и хранятся в списке. Затем этот список проиндексируется различными способами для определения границ районов проживания и повторной передачи соседей. Например, лидер просто выберет первые узлы, которые составляют слой 0. Это будет автоматически самым высоким держателем ставки, позволяя наиболее сильным голосам сначала вернуться к лидеру. Узлы слоя 0 и нижнего слоя используют ту же логику, чтобы найти своих соседей и соседей следующего слоя.

Для уменьшения возможности векторов атаки, каждый из них передается по дереву случайных районов. Каждый узел использует один и тот же набор узлов, представляющих кластер. Случайное дерево формируется из набора для каждого шреда с использованием семенного материала, получаемого из признаков лидера, ячейки и сеянного индекса.

## Слой и структура соседних районов

Нынешний лидер делает свои первоначальные трансляции не более `узлов DATA_PLANE_FANOUT`. Если этот уровень 0 меньше, чем количество узлов в кластере, то плоскость хранения данных добавляет ниже слоёв. Последующие слои следуют этим ограничениям для определения способности слоя: Каждый район содержит `DATA_PLANE_FANOUT` узлов. Слой 0 начинается с одного соседства с узлами фанаута. Количество узлов в каждом дополнительном слое увеличивается в фактор фанаута.

Как упоминалось выше, каждый узел слоя должен только транслировать свои фрагменты своим соседям и ровно один узел в некоторых соседних районах, вместо каждого пира TVU в кластере. Хороший способ подумать об этом, слой 0 начинается с 1 соседства с узлами фанаута, слой 1 добавляет фанаутские районы, у каждого фанатов и второго слоя `фанаут * количество узлов в слое 1` и так далее.

Таким образом, каждый узел должен общаться только с максимум `2 * DATA_PLANE_FANOUT - 1` узлов.

На диаграмме показано, как руководитель посылает данные с фанаутом 2 в соседство 0 в слое 0 и как узлы в соседстве 0 делятся своими данными друг с другом.

![Лидер отправляет на соседний уровень 0 в слое 0](/img/data-plane-seeding.svg)

На диаграмме показано, как 0 фанатов соседства 1 и 2.

![Соседние 0 Фанаут соседству 1 и 2](/img/data-plane-fanout.svg)

Наконец, на следующей диаграмме показан кластер двух слоёв с фанаутом 2.

![Два слоя с Фанаутом 2](/img/data-plane.svg)

### Настройка конфигурации

`DATA_PLANE_FANOUT` - определяет размер слоя 0. Последующие слои растут в `DATA_PLANE_FANOUT`. Количество узлов в соседстве равно величине фанаута. Соседние границы будут заполнены до того, как будут добавлены новые, то есть если район не заполнен, то он _должен быть последним_.

В настоящее время конфигурация устанавливается при запуске кластера. В будущем эти параметры могут быть размещены в цепи, что позволяет модифицировать на лету по мере изменения размеров кластер.

## Расчет требуемого курса FEC

Turbine использует повторную передачу пакетов между валидаторами. Из-за повторной передачи объединена любая потеря общесетевых пакетов, и вероятность того, что пакет с не сможет достичь назначения, увеличивается на в каждом прыжке. Курс FEC должен учитывать потерю пакетов в сети и глубину распространения.

Засеянная группа — это набор данных и пакетов кодирования, которые могут быть использованы для реконструирования друг друга. Каждая группа имеет шанс на провал, основываясь на вероятности отказа от пакетов, превышающих скорость FEC. Если валидатор не может реконструировать пролитую группу, тогда блок не может быть перестроен, и валидатор должен полагаться на ремонт для ремонта блоков.

Вероятность неудачи прошитой группы может быть рассчитана с помощью распределения биномиальности. Если курс FEC `16:4`, то размер группы равен 20, и по крайней мере 4 шридов должны потерпеть неудачу для группы. Которая равна сумме вероятности провалившихся из 20.

Вероятность блока привела к успеху турбины:

- Вероятность сбоя пакета: `P = 1 - (1 - network_packet_loss_rate)^2`
- FEC курс: `К:М`
- Количество испытаний: `N = K + M`
- Шанс сбоя в группе: `S = SUM из i=0 -> M для биномиального (prob_failure = P, trials = N, failures = i)`
- Шредов на блок: `G`
- Успешная скорость блока: `B = (1 - S) ^ (G / N)`
- Распределение биномов ровно для `i` результатов с вероятностью P в N испытаниях определяется как `(N select i) * P^i * (1 - P)^(N-i)`

Например:

- Скорость потери сетевых пакетов составляет 15%.
- Сеть в 50k т/с генерирует 6400 излучателей в секунду.
- Курс FEC увеличивает общее количество штрихов за блок на коэффициент FEC.

FEC курс: `16:4`

- `G = 8000`
- `P = 1 - 0,85 ± 0,85 = 1 - 0,7225 = 0,2775`
- `S = СУМ из i=0 -> 4 для двоичного (prob_failure = 0.2775, trials = 20, failures = i) = 0.689414`
- `B = (1 - 0,689) ^ (8000 / 20) = 10^-203`

FEC курс: `16:16`

- `G = 12800`
- `S = СУМ из i=0 -> 32 для двоичного (prob_failure = 0.2775, trials = 64, failures = i) = 0.002132`
- `B = (1 - 0,002132) ^ (12800 / 32) = 0,42583`

FEC курс: `32:32`

- `G = 12800`
- `S = СУМ из i=0 -> 32 для двоичного (prob_failure = 0.2775, trials = 64, failures = i) = 0.000048`
- `B = (1 - 0,000048) ^ (12800 / 64) = 0,99045`

## Соседи

На следующей диаграмме показано, как взаимодействуют два квартала в разных слоях. Чтобы записать район, достаточно узлов \(кодов стирания +1\) из вышеуказанного района необходимо прервать. Поскольку каждый район получает излишек с нескольких узлов в соседстве в верхнем слое, Нам понадобится большая сетевая ошибка в верхних слоях, чтобы в итоге получить неполные данные.

![Внутренние работы по соседству](/img/data-plane-neighborhood.svg)
