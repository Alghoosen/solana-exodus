---
title: Постоянное хранилище аккаунтов
---

## Постоянное хранилище аккаунтов

Набор аккаунтов представляет текущее вычисленное состояние всех транзакций, которые были обработаны валидатором. Каждый валидатор должен поддерживать весь этот набор. Каждый блок, предложенный сетью, представляет собой изменение этого набора, и поскольку каждый блок является потенциальной точкой отката, изменения должны быть обратимыми.

Постоянные хранилища, такие как NVME, в 20-40 раз дешевле, чем DDR. Проблема с постоянным хранилищем заключается в том, что производительность записи и чтения намного ниже, чем у DDR, и необходимо внимательно следить за тем, как данные читаются или записываются. И чтение, и запись могут быть разделены между несколькими накопителями и запрашиваться параллельно. Этот дизайн предлагает структуру данных, которая допускает одновременное чтение и одновременную запись в хранилище. Операции записи оптимизируются с помощью структуры данных AppendVec, которая позволяет получать один доступ для записи, обеспечивая доступ множеству одновременных читателей. Индекс аккаунтов поддерживает указатель на точку, где аккаунт был добавлен в каждый форк, тем самым устраняя необходимость в явном чекпоинте состояния.

## AppendVec

AppendVec - это структура данных, которая позволяет выполнять одновременное множественное чтение, с добавлением новых записей со стороны лишь одного процесса. Рост или изменение емкости AppendVec требует исключительного доступа. Это реализовано с помощью атомарного ` 
смещения`, которое обновляется в конце завершенной опперации записи.

Основанная для AppendVec память - это файл, который отображен в памяти. Файлы с отображением в память обеспечивают быстрый произвольный доступ, а подкачка страниц обрабатывается ОС.

## Индексирование аккаунтов

Индекс аккаунта предназначен для поддержки единого индекса для всех текущих учетных записей находящихся в других форках.

```text
type AppendVecId = usize;

type Fork = u64;

struct AccountMap(Hashmap<Fork, (AppendVecId, u64)>);

type AccountIndex = HashMap<Pubkey, AccountMap>;
```

Индекс аккаунта соответствует значению его публичного ключа, конкретного форка и местоположения данных аккаунта в AppendVec. Для получения версии аккаунта для определенного Форка:

```text
/// Load the account for the pubkey.
/// This function will load the account from the specified fork, falling back to the fork's parents
/// * fork - a virtual Accounts instance, keyed by Fork.  Accounts keep track of their parents with Forks,
///       the persistent store
/// * pubkey - The Account's public key.
pub fn load_slow(&self, id: Fork, pubkey: &Pubkey) -> Option<&Account>
```

Чтение удовлетворяется указанием отображенного в память местоположения в ` AppendVecId` с сохраненным смещением. Ссылка может быть возвращена без копирования.

### Корневые форки

[Tower BFT](tower-bft.md) в конечном итоге выбирает форк в качестве корневого форка и он сжимается. Нельзя откатиться обратно сжатый/корневой форк.

Когда форк сжимается, все аккаунты его предков, которые еще не присутствуют в форке, подтягиваются к форку путем обновления индексов. Аккаунты с нулевым балансом в жатом форке удаляются во время обновления индексов.

Аккаунт может быть подхвачен _сборщиком мусора_, если сжатие сделало его недоступным.

Существуют три возможных варианта:

- Поддержка HashSet корневых форков. Ожидается, что один будет создаваться каждую секунду. Все дерево таких форков в дальнейшем может быть удалено сборщиком-мусора. В качестве альтернативы, если каждый форк хранит счетчик ссылок на аккаунты, сборка мусора может происходить в любое время при обновлении местоположения индекса.
- Удаление из индекса всех обрезанных форков. Любые оставшиеся форки короче, чем кореневой, можно считать корневыми.
- Перенос любого старого корневого форка в новый после сканирования индексов. Любые оставшиеся форки короче нового корневого форка могут быть удалены позже.

## Запись только с добавлением

Все обновления в аккаунтах происходят только путем добавления новых записей. Новая версия для каждого обновления аккаунта хранится в AppendVec.

Можно оптимизировать обновления в пределах одного форка, возвращая изменяемую ссылку на уже сохраненную учетную запись в форке. Bank уже отслеживает одновременный доступ к аккаунтам и гарантирует, что одновременная записи в конкретный аккаунт и чтение из него не произойдут в одном форке. Для поддержки этой операции AppendVec должен реализовать эту функцию:

```text
fn get_mut(&self, index: u64) -> &mut T;
```

Это API позволяет одновременный смешанный доступ в регион пямяти по `индексу`. Оно полагается на Bank, чтобы гарантировать эксклюзивный доступ к данному индексу.

## Сборка мусра

Когда учетные записи обновляются, они перемещаются в конец AppendVec. Когда вместимость исчерпана, можно создать новый AppendVec и хранить в нем обновления. В конце концов ссылки на более старый AppendVec исчезнут, потому что все учетные записи были обновлены, а старый AppendVec могут быть удалены.

Чтобы ускорить этот процесс, можно переместить Аккаунты, которые не обновлялись недавно, в начало нового AppendVec. Эта форма сборки мусора может выполняться без необходимости блокировки любой из структур данных, за исключением обновления индекса.

Первоначальная реализация сборки мусора заключается в том, что после того, как все учетные записи в AppendVec становятся устаревшими версиями, он используется повторно. После добавления учетные записи не обновляются и не перемещаются.

## Восстановление индекса

Каждый поток Bank имеет эксклюзивный доступ к аккаунтам во время добавления, поскольку блокировки аккаунтов не могут быть сняты до тех пор, пока данные не будут зафиксированы. Но явного порядка для записи между отдельными файлами AppendVec не существует. Для создания порядка индекс поддерживает атомарный счетчик версий записи. Каждое дополнение к AppendVec записывает номер версии записи индекса для этого добавления в записи для Account в AppendVec.

Для записи индексов, все файлы AppendVec могут читаться в любом порядке, и последняя записанная версия для каждого форка должна храниться в индексе.

## Снепшоты

Для создания снепшота основные файлы с отображением памяти в AppendVec должны быть сброшены на диск. Индекс также можно записать на диск.

## Производительность

- Запись только с добавлением является достаточно быстрой. SSD и NVME, а также все структуры данных ядра уровня ОС позволяют приложениям работать с такой скоростью, которую позволяет пропускная способность PCI или NVMe \(2,700 МБ/с\).
- Каждый воспроизводящий и банковский поток записывают параллельно в свои собственные AppendVec файлы.
- Каждый AppendVec потенциально может быть размещен на отдельных NVMe.
- Каждый воспроизводящий и банковский поток имеют параллельный доступ ко всем AppendVecs файлам без блокировки возможности писать в них.
- Индекс требует блокировки записи для добавления новой информации. Однопоточная производительность обновлений HashMap составляет порядка 10 млн в секунду.
- Этапы Banking и Replay должны использовать 32 потока на каждый NVMe. NVM обладают оптимальной производительностью при одновременном чтении и записи 32 процессами.
