---
title: Durable Nonce Транзакции
---

## Проблематика

Чтобы предотвратить возможность отправки одной и тойже транзакции дважды, для её генерации используется уникальное значение в поле nonce, которое заполняется хэшем блока (далее blockhash). Blockhash имеет срок валидности (на текущий момент около ~2мин.) по истечении которого транзакция будет отклонена, как невалидная. К сожалению, для некоторого числа применений, например различные кастодиальные услуги, требуется больше времени, чтобы подписать транзакцию. По этой причине необходим механизм, который бы позволил этим потенциальным участникам взаимодействовать с сетью оффлайн.

## Требования

1. Подпись транзакции должна обязательно включать в себя значение nonce
2. Значение nonce не может быть использовано дважды, даже если приватный ключ был скомпрометирован

## Решение на основе смарт-контракта

Тут мы описываем решение данной проблемы, истечение срока валидности blockhash, с помощью смарт-контракта, благодаря которому, клиент может "отложить в копилку" nonce для использования в поле `recent_blockhash` будущей транзакции. Такой "отложенный" nonce будем называть durable nonce. Этот подход сродни тому, как некоторые CPU ISA реализуют атомарные инструкции Compare и Swap.

Чтобы воспользоваться durable nonce клиенту необходимо сначала запросить его значение из данных аккаунта, наша условная копилка, куда мы отложили наш nonce будущее. Дальше транзакция создается в обычным способом, но с несколькими новыми требованиями:

1. Значение durable nonce используется в поле `recent_blockhash`. Обратите внимание, речь идет именно о поле в смарт-контракте, в инструментах Cli и Json Api название поля может отличаться
2. Инструкция `AdvanceNonceAccount` в транзакции выдается первой

### Механика контракта

```text
Start
Create Account
  state = Uninitialized
NonceInstruction
  if state == Uninitialized
    if account.balance < rent_exempt
      error InsufficientFunds
    state = Initialized
  elif state != Initialized
    error BadState
  if sysvar.recent_blockhashes.is_empty()
    error EmptyRecentBlockhashes
  if !sysvar.recent_blockhashes.contains(stored_nonce)
    error NotReady
  stored_hash = sysvar.recent_blockhashes[0]
  success
WithdrawInstruction(to, lamports)
  if state == Uninitialized
    if !signers.contains(owner)
      error MissingRequiredSignatures
  elif state == Initialized
    if !sysvar.recent_blockhashes.contains(stored_nonce)
      error NotReady
    if lamports != account.balance && lamports + rent_exempt > account.balance
      error InsufficientFunds
  account.balance -= lamports
  to.balance += lamports
  success
```

Клиент, желающий использовать возможности durable nonce, в первую очередь должен создать одноразовые аккаунт, nonce account, с помощью системной программы. Этот аккаунт изначально будет находиться в состоянии `Uninitialized` и не будет хранить blockhash в качестве durable nonce значения, вот почему его ещё нельзя использовать.

Для инициализации только что созданного аккаунта, необходимо вызвать инструкцию `InitializeNonceAccount`. Эта инструкция принимает на вход только один параметр - `Публичный ключ` аккаунта с, которому мы передаем [право владения](../offline-signing/durable-nonce.md#nonce-authority) над созданным одноразовым аккаунтом. Одноразовый аккаунт должен удовлетворять условие [rent-exempt](rent.md#two-tiered-rent-regime), чтобы обеспечить постоянство данных на будущее, а это в свою очередь требует наличия определенного количества лэмпортов на счёту. Следовательно перед инициализацией вам необходимо будет пополнить баланс на минимально необходимую сумму. После успешной инициализации, последний валидный blockhash текущего кластера будет хранится вместе со значением `публичного ключа` текущего владельца одноразовго аккаунта.

Инструкция `AdvanceNonceAccount` используется для управления хранимым значением nonce. Инструкция обновляет, хранимый в данных состояния аккаунта последний валидный blockhash, если же полученное значение будет равнятся тому, что уже хранится, то инструкция вернет ошибку. Эта проверка предотвращает повторную отправку транзакции в том же блоке.

Поскольку у одноразовых аккаунтов есть требование к соответствию [rent-exempt](rent.md#two-tiered-rent-regime) состояния, используется специальная команда, которая позволяет вывести все средства со счёта одноразового аккаунта. Инструкция `WithdrawNonceAccount` принимает на вход только адин аргумент - количество лэмпортов для вывода и предотвращает падение баланса ниже минимально необходимого, чтобы сохранялось требование rent-exemption. Исключение из этой проверки является ситуация, когда окончательный баланс аккаунта становится нулевым, а таком случа аккаунт становится пригодным для удаления. Важной деталью удаления аккаунта является дополнительное требование: сохраненное значение nonce не должно совпадать с самым последним хешем блока кластера, так же, как и при использовании инструкции `AdvanceNonceAccount`.

[Владельца](../offline-signing/durable-nonce.md#nonce-authority) одноразового аккаунта можно изменить с помощью инструкции `AuthorizeNonceAccount`. Эта инструкция принимает только один параметр - `публичный ключ` нового владельца. Выполнение этой инструкции даёт новому владельцу полный контроль над одноразовым аккаунтом и его балансом.

> `AdvanceNonceAccount`, `WithdrawNonceAccount` и `AuthorizeNonceAccount` - все эти инструкции требуют передачи в качестве аргумента значение [текущего владельца](../offline-signing/durable-nonce.md#nonce-authority) для подписи транзакций.

### Поддержка среды выполнения

Одного только контракта для реализации этого механизма недостаточно. Чтобы обеспечить наличие валидного значения blockhash в поле `recent_blockhash` и предотвратить потерю комиссии из-за неудачной попытки воспроизвести транзакции, необходимы изменения во время выполнения инструкций.

Любая транзакций, не прошедшая обычну. проверку `check_hash_age` будет автоматически опробована как транзакция с использованием durable nonce. Об этом свидетельствует наличие в самом начале транзакции инструкции `AdvanceNonceAccount`.

Если среда выполнения определяет, что используется транзакция использующая durable nonce, то будут предприняты следующие дополнительные шаги для валидации транзакции:

1. Одноразовый аккаунт `NonceAccount`, указанный в инструкции `Nonce` будет загружен.
2. Далее должна произойти проверка его состояния к соответствию со значением `Initialized` для чего предварительно будет десериализован `NonceState` из поля `NonceAccount`.
3. Далее значение nonce, хранящееся в `NonceAccount`, проверяется на соответствие значению, указанному в поле `recent_blockhash` транзакции.

Если все три вышеперечисленные проверки пройдены, то транзакция может продолжить свою валидацию.

Поскольку с транзакций, которые завершаются ошибкой `InstructionError`, взимается комиссия, а их состояние откатывается в исходное, уплаченные комиссии при отмене инструкции `AdvanceNonceAccount` не возвращаются, что открывает возможность для "кражи комиссий". Вредоносный валидатор может воспроизводить неудачную транзакцию до тех пор, пока сохраненный одноразовый номер не будет обновлен. Среда выполнения препятствует такому поведению. Когда транзакция с использованием durable nonce завершается ошибкой `InstructionError`, помимо инструкции `AdvanceNonceAccount`, одноразовый аккаунт откатывается к состояния до выполнения инструкций транзакции. Затем среда выполнения оновляет хранящееся значение nonce, а одноразовый аккаунт сохраняет новое значение, как если бы транзакция завершилась успешно.
