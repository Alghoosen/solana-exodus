---
title: Процесс управления Solana ABI
---

В настоящем документе предлагается процесс управления Solana ABI. Процесс управления ABI - это инженерная практика и вспомогательная техническая среда, позволяющая избежать внесения непреднамеренных несовместимых изменений ABI.

# Проблема

Solana ABI (двоичный интерфейс для кластера) в настоящее время определяется реализацией только неявно и требует очень внимательного наблюдения, чтобы заметить критические изменения. Это крайне затрудняет обновление программного обеспечения на существующем кластере без перезагрузки реестра.

# Требования и цели

- Непреднамеренные изменения ABI могут быть обнаружены как отказы CI механически.
- Более новая реализация должна иметь возможность обрабатывать самые старые данные (с момента появления), когда мы выходим в mainnet.
- Цель этого предложения - защитить ABI, поддерживая при этом довольно быстрое развитие, сделав выбор в пользу механического процесса, а не очень длительного процесса аудита, управляемого человеком.
- После криптографической подписи большой двоичный объект данных должен быть идентичным, поэтому обновление формата данных на месте невозможно независимо от входящего и исходящего из онлайн-системы. Кроме того, учитывая огромный объем транзакций, мы стремление справиться с ретроспективным обновлением на месте в лучшем случае нежелательно.

# Решение

Вместо естественной должной осмотрительности человеческого глаза, которая, как следует предполагать, дает регулярные сбои, нам нужна систематическая гарантия того, что кластер не сломается при изменении исходного кода.

Для этого мы вводим механизм маркировки всех связанных с ABI вещей в исходном коде (`struct`s, `enum`s) с новым `#[frozen_abi]` атрибутом. Это принимает жестко запрограммированное значение дайджеста, полученное из типов его полей через `ser:: Serialize`. Атрибут автоматически генерирует модульный тест, чтобы попытаться обнаружить любые несанкционированные изменения в отмеченных объектах, связанных с ABI.

Однако обнаружение не может быть полным; как бы мы ни анализировали статически исходный код, сломать ABI все равно возможно. Например, это включает not-`derive`dнаписанное вручную `ser:: Serialize`, изменения реализации базовой библиотеки (например, `bincode`), архитектуру CPU различия. Обнаружение этих возможных несовместимостей ABI выходит за рамки этого управления ABI.

# Определения

Элемент / тип ABI: различные типы, которые будут использоваться для сериализации, которые в совокупности составляют весь ABI для любых компонентов системы. Например, эти типы включают `struct`s и `enum`s.

Дайджест элемента ABI: некоторый фиксированный хэш, полученный из информации о типе полей элемента ABI.

# Пример

```patch
+#[frozen_abi(digest="eXSMM7b89VY72V...")]
 #[derive(Serialize, Default, Deserialize, Debug, PartialEq, Eq, Clone)]
 pub struct Vote {
     /// A stack of votes starting with the oldest vote
     pub slots: Vec<Slot>,
     /// signature of the bank's state at the last slot
     pub hash: Hash,
 }
```

# Рабочий процесс для разработчиков

Чтобы узнать дайджест для новых элементов ABI, разработчики могут добавить `frozen_abi` со случайным значением дайджеста, запустить модульные тесты и заменить его правильным дайджестом из сообщения об ошибке проверки утверждения.

В общем, после того, как мы добавим `frozen_abi` и его изменение будет опубликовано в канале стабильного выпуска, его дайджест никогда не должен измениться. Если такое изменение необходимо, мы должны выбрать определение новой `struct`, например `FooV1`. И следует подходить к особому потоку релизов, как хард-форки.

# Замечания по реализации

Мы в некоторой степени используем макроэлементы для автоматического создания модульных тестов и вычисления дайджеста из элементов ABI. Это можно сделать, грамотно используя `serde::Serialize` (`[1]`) and `any::type_name` (`[2]`). В качестве прецедента для подобной реализации `ink` от Parity Technologies `[3]` может быть информационным.

# Детали реализации

Целью реализации является максимально возможное автоматическое обнаружение непреднамеренных изменений ABI. С этой целью дайджест структурной информации ABI рассчитан с максимальной точностью и стабильностью.

Когда выполняется проверка дайджеста ABI, она динамически вычисляет дайджест ABI, рекурсивно обрабатывая ABI полей элемента ABI, повторно используя функциональность сериализации `serde`'s, proc macro и общую специализацию. Затем выполняется проверка `assert!` на то, что его окончательное значение дайджеста идентично тому, что указано в атрибуте `frozen_abi`.

Чтобы понять это, он создает пример экземпляра типа и пользовательский экземпляр `Serializer` для `serde`, чтобы рекурсивно перемещаться по его полям, как если бы пример был сериализован по-настоящему. Этот переход должен выполняться через `serde` в действительно фиксировать, какие типы данных на самом деле будут сериализованы с помощью `serde`, даже с учетом пользовательских реализаций не `derive` d `Serialize`.

# Процесс переваривания ABI

Эта часть немного сложна. Есть три взаимосвязанные части: `AbiExample`, `AbiDigester` и `AbiEnumVisitor`.

Во-первых, сгенерированный тест создает примерный экземпляр переваренного типа с признаком под названием `AbiExample`, который должен быть реализован для всех перевариваемых типов, таких как `Serialize`, и возвращать `Self` как черта `Default`. Обычно он предоставляется через специализацию общих черт для большинства распространенных типов. Также можно `derive` for `struct` and `enum` и при необходимости можно написать вручную.

Пользовательский `Serializer` называется `AbiDigester`. И когда он вызывается `serde` чтобы сериализовать некоторые данные, он рекурсивно собирает информацию ABI, насколько это возможно. Внутреннее состояние дайджеста ABI в `AbiDigester` обновляется по-разному в зависимости от типа данных. Эта логика специально перенаправляется с помощью признака `AbiEnumVisitor` для каждого типа `enum`. Как следует из названия, нет необходимости реализовывать `AbiEnumVisitor` для других типов.

Подводя итог этому взаимодействию, `serde` обрабатывает поток управления рекурсивной сериализацией в тандеме с `AbiDigester`. Начальная точка входа в тесты и дочерние элементы `AbiDigester` рекурсивно используют `AbiExample` для создания примера иерархического графика объектов. А `AbiDigester` использует `AbiEnumVisitor` для запроса фактической информации ABI, используя построенный образец.

`Default` недостаточно для `AbiExample`. `:: default () ` различных коллекций пуст, но мы хотим переварить их с фактическими элементами. Кроме того, переработка ABI не может быть реализована только с помощью `AbiEnumVisitor`. `AbiExample` требуется, потому что фактический экземпляр типа необходим для фактического обхода данных через `serde`.

С другой стороны, ABI пищеварение не может быть выполнено только с помощью `AbiExample`. `AbiEnumVisitor` обязателен, потому что все варианты `инума` не могут быть пройдены с помощью одного из вариантов в качестве примера ABI.

Сведения о усвояемой среде:

- rust's имя типа
- Имя типа данных `serde`
- все поля в `struct`
- все варианты в `enum`
- `постройте`: normal(`struct {...}`) и tuple-style (`struct(...)`)
- `enum`: нормальные варианты и `struct`- и `tuple`- стили.
- атрибуты: `serde(serialize_with=...)` и `serde(skip)`

Неусвояемая информация:

- Любой пользовательский путь кода сериализации, не затронутый образцом, предоставленным `AbiExample`. (технически невозможно)
- дженерики (должен быть конкретным типом; используйте `frozen_abi` на конкретных типах)

# Ссылки

1. [(Де)Сериализация с информацией о типе · Выпуск #1095 · serde-r/serde](https://github.com/serde-rs/serde/issues/1095#issuecomment-345483479)
2. [`std::any::type_name` - Rust](https://doc.rust-lang.org/std/any/fn.type_name.html)
3. [Чернила Parity для написания смарт-контрактов](https://github.com/paritytech/ink)
