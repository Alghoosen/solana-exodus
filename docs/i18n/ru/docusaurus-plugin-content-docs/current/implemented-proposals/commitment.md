---
title: Обязательство
---

Метрика приверженности нацелена на то, чтобы дать клиентам оценку уровня подтверждения сети и доли в конкретном блоке. Затем клиенты могут использовать эту информацию для определения своих собственных критериев приверженности.

# Расчет RPC

Клиенты могут запрашивать показатели обязательств у валидатора для подписи `s` through `get_block_commitment(s: Signature) -> BlockCommitment` over RPC. через RPC. `BlockCommitment` содержит массив u64 `[u64, MAX_CONFIRMATION]`. Этот массив представляет метрику обязательств для конкретного блока ` N `, который содержит сигнатуру ` s ` последнего блока ` M `, за который проголосовал валидатор.

Запись ` s ` с индексом ` i ` в массиве ` BlockCommitment ` подразумевает, что валидатор обнаружил, что ` s ` общая ставка в кластере достигает ` i ` подтверждений в блоке ` N `, как это наблюдалось в некотором блоке ` M `. В нем будут элементы ` MAX_CONFIRMATIONS ` этот массив, представляющий все возможное количество подтверждений от 1 до ` MAX_CONFIRMATIONS `.

# Вычисление метрики обязательства

Построение `BlockCommitment` структурирует уже выполненные вычисления для достижения консенсуса. Функция `collect_vote_lockouts` в `консенсусе. s` строит хэшкарту, где каждая запись в форме `b, s)` где `s` - это сумма ставки на банк `b`.

Этот расчет выполняется в банке кандидата `b` следующим образом.

```text
   let output: HashMap<b, Stake> = HashMap::new();
   for vote_account in b.vote_accounts {
       for v in vote_account.vote_stack {
           for a in ancestors(v) {
               f(*output.get_mut(a), vote_account, v);
           }
       }
   }
```

где `f` - это некоторая функция накопления, которая изменяет `Разбивка` для слота `` с некоторыми данными, полученными от голоса `v` и `vote_account` (ставка, lockout и т. д.). Обратите внимание, что `ancestors` здесь включает только слотов, присутствующих в кэше текущего состояния. Подписи для банков более ранних по сравнению с теми, которые присутствуют в статус-кэше, все равно не могут быть запрошены, чтобы эти банки не были включены в расчет обязательств здесь.

Теперь мы можем естественным образом увеличить вышесказанное, чтобы построить массив `BlockCommitment` для каждого банка `b` путем:

1. Добавление ` ForkCommitmentCache ` для сбора структур ` BlockCommitment `
2. Замена ` f ` на ` f '` таким образом, чтобы вышеуказанное вычисление также строило этот ` BlockCommitment ` для каждого банка ` b `.

Мы продолжим с подробностями 2, как 1) тривиально.

Прежде чем продолжить, обратите внимание, что для аккаунта голосования некоторого валидатора ` a ` количество локальных подтверждений для этого валидатора в слоте ` s ` равно ` v.num_confirmations `, где ` v ` - наименьший голос в стеке голосов ` a.votes `, такой что `v.slot >= s`(т. е. нет нужно смотреть на любой голосов > v так как количество подтверждений будет меньше).

Более конкретно, мы дополняем приведенные выше расчеты:

```text
   let output: HashMap<b, Stake> = HashMap::new();
   let fork_commitment_cache = ForkCommitmentCache::default();
   for vote_account in b.vote_accounts {
       // vote stack is sorted from oldest vote to newest vote
       for (v1, v2) in vote_account.vote_stack.windows(2) {
           for a in ancestors(v1).difference(ancestors(v2)) {
               f'(*output.get_mut(a), *fork_commitment_cache.get_mut(a), vote_account, v);
           }
       }
   }
```

где `f'` определяется как:

```text
    fn f`(
        stake: &mut Stake,
        some_ancestor: &mut BlockCommitment,
        vote_account: VoteAccount,
        v: Vote, total_stake: u64
    ){
        f(stake, vote_account, v);
        *some_ancestor.commitment[v.num_confirmations] += vote_account.stake;
    }
```
