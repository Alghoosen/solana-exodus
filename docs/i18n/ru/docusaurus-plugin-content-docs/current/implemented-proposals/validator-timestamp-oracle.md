---
title: Проверка метки времени Oracle
---

Сторонним пользователям Solana иногда необходимо знать реальное время создания блока, как правило, для соответствия требованиям внешних аудиторов или правоохранительных органов. Это предложение описывает валидаторную метку времени oracle, которая позволила бы кластеру Solana удовлетворить эту потребность.

Общая схема предлагаемой реализации выглядит следующим образом:

- Через регулярные промежутки времени каждый валидатор записывает свое наблюдаемое время для известного слота в цепочке (через метку времени, добавленную к голосованию слота)
- Клиент может запросить время блока для root-блока, используя `getBlockTime` RPC метод. Когда клиент запрашивает метку времени для блока N:

  1. Валидатор определяет временную метку "кластера" для последнего слота с временной меткой перед блоком N, наблюдая за всеми инструкциями голосования с временной меткой, записанными в реестре, которые ссылаются на этот слот, и определяя среднюю временную метку, взвешенную по ставке.

  2. Эта недавняя средняя временная метка затем используется для вычисления временной метки блока N с использованием установленной длительности слота кластера

Требования:

- Любой валидатор, воспроизводящий реестр в будущем, должен предлагать одно и то же время для каждого блока с момента генезиса
- Расчетное время блока не должно дрейфовать более чем на час или около того, прежде чем переходить к реальным (oracle) данным
- Время блока контролируются не одним централизованным оракулом, а в идеале на основе функции, использующей входные данные от всех валидаторов
- Каждый валидатор должен поддерживать oracle с отметкой времени

Та же реализация может предоставить оценку временной метки для пока еще не корневого блока. Однако, поскольку последний интервал времени может быть или не может быть корневым, эта временная метка будет нестабильной (потенциально невыполнение требования 1). Первоначальная реализация будет нацелена на корневые блоки, но если есть вариант использования временной метки недавнего блока, то в будущем будет тривиально добавить API RPC.

## Время записи

Через регулярные промежутки времени, когда он голосует на определенном слоте, каждый валидатор записывает свое наблюдаемое время, включая метку времени в свою отправку голосовой инструкции. Соответствующий слот для отметки времени является самым новым слотом в векторе голосования (`Vote::slots.iter().max()`). Он подписывается парой идентификационных ключей валидатора как обычное голосование. Чтобы включить эту отчетность, структуру голосования необходимо расширить, включив в нее поле отметки времени, `timestamp: Option<UnixTimestamp>`, которое будет установлено в `None` в большинстве голосов.

Начиная с https://github.com/solana-labs/solana/pull/10630, валидаторы отправляют временную метку при каждом голосовании. Это позволяет реализовать службу кэширования времени блока, которая позволяет узлам вычислять расчетную метку времени сразу после укоренения блока и кэшировать это значение в Blockstore. Это обеспечивает постоянные данные и быстрые запросы, в то же время удовлетворяя требованию 1) выше.

### Аккаунты голосования

Аккаунт для голосования валидатора будет содержать самую последнюю временную метку слота в VoteState.

### Программа голосования

Программа голосования в цепочке должна быть расширена для обработки временной метки, отправленной вместе с инструкцией по голосованию от валидаторов. В дополнение к текущей функциональности process_vote (включая загрузку правильного аккаунта голосования и проверку, что подписавший транзакцию является ожидаемым валидатором), этот процесс должен сравнить временную метку и соответствующий слот с текущими сохраненными значениями и убедиться, что они оба монотонно увеличиваются, и сохранить новый слот и временную метку в аккаунте.

## Расчет средневзвешенной по стейку отметки времени

Чтобы вычислить расчетную метку времени для конкретного блока, валидатору сначала необходимо определить самый последний слот с меткой времени:

```text
let timestamp_slot = floor(current_slot / timestamp_interval);
```

Затем валидатору необходимо собрать все транзакции голосования с отметкой времени из реестра, которые ссылаются на этот слот, используя `Blockstore::get_slot_entries()`. Поскольку эти транзакции могли занять некоторое время, чтобы достичь и быть обработанными лидером, валидатору необходимо просканировать несколько завершенных блоков после timestamp_slot, чтобы получить разумный набор временных меток. Точное количество слотов должно быть настроено: Больше слотов обеспечит большее участие кластера и больше точек данных с отметками времени; меньшее количество слотов ускоряет фильтрацию временных меток.

Из этой коллекции транзакций валидатор вычисляет взвешенную по стейку среднюю временную метку, перекрестно ссылаясь на ставки эпохи из `staking_utils::staked_nodes_at_epoch()`.

Любой валидатор, воспроизводящий реестр, должен получить одну и ту же среднюю временную метку, взвешенную по стейку, путем обработки транзакций временных меток из одного и того же числа слотов.

## Считаем расчетное время для конкретного блока

После вычисления средней отметки времени для известного слота, становится тривиальным вычислить расчетную временную метку для последующего блока N:

```text
let block_n_timestamp = mean_timestamp + (block_n_slot_offset * slot_duration);
```

где `block_n_slot_offset` - это разница между слотом блока N и timestamp_slot, и `slot_duration` выводится из `slots_per_year` кластера, хранящегося в каждом банке
