# Долгосрочная история транзакций RPC

RPC должен обслуживать историю транзакций не менее 6 месяцев. Текущая история, измеряемая в днях, недостаточна для последующих пользователей.

Данные транзакций за 6 месяцев практически не могут быть сохранены в реестре Rockdb валидатора, поэтому необходимо внешнее хранилище данных. Реестр Rockdb валидатора будет продолжать служить основным источником данных, а затем вернется к внешнему хранилищу данных.

К конечным точкам RPC относятся:

- [getFirstAvailableBlock](developing/clients/jsonrpc-api.md#getfirstavailableblock)
- [getConfirmedBlock](developing/clients/jsonrpc-api.md#getconfirmedblock)
- [getConfirmedBlocks](developing/clients/jsonrpc-api.md#getconfirmedblocks)
- [getConfirmedSignaturesForAddress](developing/clients/jsonrpc-api.md#getconfirmedsignaturesforaddress)
- [getConfirmedTransaction](developing/clients/jsonrpc-api.md#getconfirmedtransaction)
- [getSignatureStatuses](developing/clients/jsonrpc-api.md#getsignaturestatuses)

Обратите внимание, что [ getBlockTime ](developing/clients/jsonrpc-api.md#getblocktime) не поддерживается, поскольку после исправления https://github.com/solana-labs/solana/issues/10089 `getBlockTime` можно удалить.

Некоторые ограничения проектирования системы:

- Объем данных для хранения и поиска может быстро увеличиться до терабайт и является неизменным.
- Система должна быть как можно более легкой для SRE. Например, кластер базы данных SQL, которому требуется SRE для постоянного мониторинга и перебалансировки узлов, нежелателен.
- Данные должны быть доступны для поиска в режиме реального времени - пакетные запросы, выполнение которых занимает минуты или часы, недопустимы.
- Легко реплицировать данные по всему миру, чтобы разместить их вместе с конечными точками RPC, которые будут их использовать.
- Взаимодействие с внешним хранилищем данных должно быть простым и не требовать зависимости от рискованных, мало используемых библиотек кода, поддерживаемых сообществом

Исходя из этих ограничений, продукт Google BigTable выбран в качестве хранилища данных.

## Схема таблиц

Экземпляр BigTable используется для хранения всех данных транзакций, разбитых на разные таблицы для быстрого поиска.

Новые данные могут быть скопированы в экземпляр в любое время, не затрагивая существующие данные, и все данные неизменны. Обычно ожидается, что новые данные будут загружены после завершения текущей эпохи, но нет ограничений на частоту дампов данных.

Очистка старых данных происходит автоматически при соответствующей настройке политики хранения данных в таблицах экземпляров, они просто исчезают. Поэтому порядок добавления данных становится важным. Например, если данные из эпохи N-1 добавляются после данных из эпохи N, более старые данные эпохи переживут более новые данные. Однако, помимо создания _holes_ в результатах запроса, такое неупорядоченное удаление не окажет вредного воздействия. Обратите внимание, что этот метод очистки позволяет хранить неограниченное количество данных транзакции, ограниченное только денежными затратами на это.

Макет таблицы поддерживает только существующие конечные точки RPC. Новые конечные точки RPC в будущем могут потребовать дополнений к схеме и, возможно, повторения всех транзакций для создания необходимых метаданных.

## Доступ к BigTable

BigTable имеет конечную точку gRPC, доступ к которой можно получить с помощью [ tonic ](https://crates.io/crates/crate)] и необработанного API protobuf, поскольку в настоящее время не существует высокоуровневого ящика Rust для BigTable. На практике это усложняет анализ результатов запросов BigTable, но не является существенной проблемой.

## Популяция данных

Постоянное заполнение данных экземпляра будет происходить периодически с помощью новой команды `solana-ledger-tool`, которая преобразует данные rockdb для заданного диапазона слотов в схему экземпляра.

Тот же процесс будет запущен один раз вручную, чтобы заполнить существующие данные реестра.

### Block Table: `block`

Эта таблица содержит данные сжатых блоков для данного слота.

Ключ строки генерируется путем использования 16-значного шестнадцатеричного представления слота в нижнем регистре, чтобы гарантировать, что самый старый слот с подтвержденным блоком всегда будет первым при перечислении строк. например, ключ строки для слота 42 будет 0000000000002a.

Строка данных является сжатым `StoredConfirmedBlock`.

### Таблица поиска подписи транзакции адреса аккаунта: `tx-by-addr`

Эта таблица содержит транзакции, которые затрагивают данный адрес.

Ключ строки `<base58 address>/<slot-id-one's-compliment-hex-slot-0-prefixed-to-16-digits>`. Строка данных является сжатой транзакцией `в ByAddrInfo` структуре.

Принятие дополнения к слоту позволяет перечислить слоты, гарантируя, что самый новый слот с транзакциями, которые влияют на адрес, всегда будет указан первым.

Адреса Sysvar не индексируются. Однако часто используемые программы, такие как Vote или System, скорее всего, будут иметь строку для каждого подтвержденного слота.

### Таблица поиска подписи транзакции: `tx`

Эта таблица сопоставляет подпись транзакции с подтвержденным блоком и индексирует этот блок.

Ключ строки - это подпись транзакции в кодировке base58. Данные строки представляют собой сжатую структуру `TransactionInfo`.
