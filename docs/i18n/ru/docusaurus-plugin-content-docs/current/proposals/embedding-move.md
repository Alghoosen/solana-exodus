---
title: Встраивание языка Перемещения
---

## Проблематика

Solana позволяет разработчикам писать программы в цепочке на языках программирования общего назначения, таких как C или Rust, но эти программы содержат механизмы, специфичные для Solana. Например, нет другой цепочки, которая просит разработчиков создать модуль Rust с функцией `process_instruction (KeyedAccounts)`. По возможности Solana должна предлагать разработчикам приложений более портативные варианты.

До недавнего времени ни один популярный блокчейн не предлагал язык, который мог бы раскрыть ценность массивно-параллельной [ среды выполнения ](../validator/runtime.md) Solana. Например, контракты Solidity не отделяют ссылки на общие данные от кода контракта, и поэтому должны выполняться последовательно, чтобы гарантировать детерминированное поведение. На практике мы видим, что наиболее агрессивно оптимизированные блокчейны на основе EVM, похоже, достигают пика около 1200 TPS - небольшая часть того, что может сделать Solana. С другой стороны, проект Libra разработал язык программирования в цепочке под названием Move, который больше подходит для параллельного выполнения. Как и среда выполнения Solana, программы Move зависят от аккаунтов для всего общего состояния.

Самая большая разница в дизайне между средой выполнения Solana и движущейся виртуальной машиной Libra заключается в том, как они управляют безопасными вызовами между модулями. Solana применила подход к операционным системам, а Libra - на предметно-ориентированном языковом подходе. Во время выполнения модуль должен вернуться в среду выполнения, чтобы гарантировать, что модуль вызывающего абонента не записал данные, принадлежащие вызываемому. Точно так же, когда вызываемый объект завершает работу, он должен снова вернуться к среде выполнения, чтобы гарантировать, что вызываемый объект не записал данные, принадлежащие вызывающему. Move, с другой стороны, включает расширенную систему типов, которая позволяет выполнять эти проверки с помощью своего верификатора байт-кода. Поскольку байт-код Move можно проверить, стоимость проверки оплачивается только один раз, когда модуль загружается в цепочку. Во время выполнения стоимость оплачивается каждый раз, когда транзакция проходит между модулями. Разница по духу аналогична разнице между языком с динамической типизацией, таким как Python, и языком со статической типизацией, таким как Java. Среда выполнения Solana позволяет писать приложения на языках программирования общего назначения, но это связано с затратами на проверки времени выполнения при переключении между программами.

Это предложение пытается определить способ встраивания Move VM таким образом, чтобы:

- межмодульные вызовы в Move не требуют среды выполнения

  межпрограммные проверки во время выполнения

- Программы перемещения могут влиять на функциональность других программ Solana и наоборот

  наоборот

- Параллелизм времени выполнения Solana доступен для пакетов Move и non-Move

  транзакции

## Предлагаемое решение

### Переместить виртуальную машину как загрузчик Solana

Виртуальная машина Move должна быть встроена как загрузчик Solana под идентификатором `MOVE_PROGRAM_ID`, чтобы модули Move могли быть помечены как `executable` с виртуальной машиной в качестве его `owner`. Это позволит модулям загружать зависимости модулей, а также позволит параллельное выполнение сценариев Move.

Все аккаунты данных, принадлежащие модулям Move, должны установить своих владельцев на загрузчик, `MOVE_PROGRAM_ID`. Поскольку модули Move инкапсулируют данные своих аккаунтов так же, как программы Solana инкапсулируют свои, владелец модуля Move должен быть встроен в данные аккаунтов. Среда выполнения предоставит доступ на запись к Move VM, а Move предоставит доступ к аккаунтам модуля.

### Взаимодействие с программами Solana

Чтобы вызывать инструкции в программах, не относящихся к Move, Solana потребуется расширить виртуальную машину Move с помощью системного вызова `process_instruction ()`. Он будет работать так же, как программы `process_instruction ()` Rust BPF.
