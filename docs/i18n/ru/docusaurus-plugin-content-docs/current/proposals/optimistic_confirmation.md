---
title: Оптимистическое подтверждение
---

## Примитивы

`vote (X, S)` - голоса будут дополнены слотом "reference", `X`, который является ** последним ** предок этой вилки, за которую проголосовал этот валидатор с подтверждением переключения. Пока валидатор делает создает голоса, которые происходят друг от друга, для всех этих голосов должен использоваться один и тот же `X`. Когда валидатор голосует за слот `s`, который не является потомком предыдущего, `X` будет установлен на новый слот `s`. Все голоса будут иметь форму `vote (X, S)`, где `S` - отсортированный список слотов `(s, s.lockout)` за что голосуют.

Учитывая голосование `vote(X, S)`, let `S.last == vote.last` будет последним слотом в `S`.

Теперь мы определим некоторые условия срабатывания "Оптимистического снятия". Их интуиция описана ниже:

- `Intuition`: если валидатор отправляет `vote (X, S)`, тот же валидатор не должен голосовать за другой форк, который «перекрывает» этот форк. Более конкретно, этот валидатор не должен иметь другого голоса `голоса(X', S')` где диапазон `[X, S. ast]` перекрывает диапазон `[X', S'.last]`, `X != X'`, как показано ниже:

```text
                                  +-------+
                                  |       |
                        +---------+       +--------+
                        |         |       |        |
                        |         +-------+        |
                        |                          |
                        |                          |
                        |                          |
                    +---+---+                      |
                    |       |                      |
                X   |       |                      |
                    |       |                      |
                    +---+---+                      |
                        |                          |
                        |                      +---+---+
                        |                      |       |
                        |                      |       |  X'
                        |                      |       |
                        |                      +---+---+
                        |                          |
                        |                          |
                        |                          |
                        |                          |
                        |                      +---+---+
                        |                      |       |
                        |                      |       |  S'.last
                        |                      |       |
                        |                      +-------+
                        |
                    +---+---+
                    |       |
                 s  |       |
                    |       |
                    +---+---+
                        |
                        |
                        |
                        |
                    +---+---+
                    |       |
             S.last |       |
                    |       |
                    +-------+
```

(Пример отсекаемых голосов: голосование (X ', S') и голосование (X, S))

На диаграмме выше обратите внимание, что голосование за `S.last` должно быть отправлено после голосования за `S'.last` (из-за локаутов более высокий голос должен был быть отправлено позже). Таким образом, последовательность голосов должна была быть такой: `X... S'.last ... S.last`. Это означает, что после голосования по `S'.last` валидатор должен был переключиться обратно на другую вилку в некотором слоте `s > S'.last > X`. Таким образом, голосование за `S.last` должно было использовать `s` в качестве «контрольной» точки, а не `X`, потому что это был последний «переключатель». "на форке.

Чтобы обеспечить это, мы определяем условия снятия «Оптимистичное снятие». Принимая во внимание любые два разных голоса `vote(X, S)`and `vote(X', S')` одним и тем же валидатором, голоса должны удовлетворять:

- `X <= S.last`, `X' <= S'.last`
- Все `s` в `S` являются предками / потомками друг друга, все ` s '` в `S'` являются предками / потомками друг друга,
-
- ` X == X '` подразумевает, что `S` является родительским элементом `S'` или ` S '` является родительским элементом `S`
- `X' > X`подразумевает, что `X' > S.last` and `S'.last > S.last` или `s` in `S`, `s + lockout(s) < X'`
- `X > X'` подразумевает `X > S'.last` и `S.last > S'.last` и для всех `s` in `S'`, `s + lockout(s) < X`

(Последние два правила подразумевают, что диапазоны не могут перекрываться): В противном случае к валидатору будет применено снятие.

`Range(vote)`- учитывая голос `v = vote(X, S)`, define `Range(v)` как диапазон слотов `[X, S.last]`.

`SP(old_vote, new_vote)` - это «доказательство переключения» для `old_vote`, последнего голосования валидатора. Такое подтверждение необходимо каждый раз, когда валидатор переключает свой «эталонный» слот (см. раздел голосования выше). Подтверждение переключения включает ссылку на `old_vote`, так что есть запись о том, каким был «диапазон» этого `old_vote` (чтобы сделать другие конфликтующие переключатели в этом диапазоне активными для снятия). Такой переключатель по-прежнему должен учитывать блокировки.

Подтверждение переключения показывает, что `> 1/3` сети заблокирована в слоте `old_vote.last`.

Подтверждение - это список элементов `(validator_id, validator_vote (X, S))`, где:

1. Сумма ставок всех идентификаторов валидатора `> 1/3`

2. Для каждого `(validator_id, validator_vote (X, S))` существует несколько слотов `s` в `S`, где: _ a. `s` не является общим предком как `validator_vote.last`, так и `old_vote.last` и `new_vote.last`. _ b. `s` не является потомком `validator_vote.last`. \* c. `s + s.lockout() >= old_голос. asp` (подразумевает, что валидатор все еще заблокирован на слоте `s` в слоте `old_vote.last`).

Форки переключения без действительного подтверждения переключения можно снимать.

## Определения:

Оптимистическое подтверждение - считается, что блок `B` достиг "оптимистического подтверждения", если `>2/3` доли проголосовали с голосами `v` где `Range (v)` для каждого такого `v` включает `B.slot`.

Завершено - блок `B` считается завершенным, если хотя бы один правильный валидатор имеет root-права для `B` или потомка `B`.

Обратный - блок `B` считается отмененным, если был завершен другой блок ` B '`, который не является родительским или потомком `B`.

## Гарантии:

Блок `B`, достигший оптимистичного подтверждения, не будет отменен, если хотя бы один валидатор не будет отмечен снятием.

## Подтверждение:

Допустим, для противоречия, блок `B` достиг `оптимистического подтверждения` в некотором слоте `B + n` for some `n`, и:

- Другой блок ` B '`, который не является родительским или потомком `B`, был завершен.
- Ни один валидатор не нарушил никаких условий.

По определению `оптимистичное подтверждение` это означает `& gt; 2/3` валидаторов показали каждый голос `v` в форме `Vote (X, S)`, где `X & lt; = B & lt; = v.last`. Назовите этот набор валидаторов `оптимистическими валидаторами`.

Теперь у нас есть валидатор `v` в `Оптимистические валидаторы`, даны два голоса, сделанные `v`, `Vote(X, S)` and `Vote(X', S')` where `X <= B <= S.last`, и `X' <= B <= S'.last`, then `X == X'` в противном случае условие «Оптимистическое снятие» нарушается ("диапазоны" каждого голоса будут перекрываться в `B`).

Таким образом, определите `Оптимистические голоса` как набор голосов, поданных `Оптимистические валидаторы`, где для каждого оптимистичного валидатора `v` проводится голосование по `v` в набор входит `maximal` голосование `Vote (X, S)` с самый высокий `S.last` из всех голосов, поданных `v`, которые удовлетворяют `X <= B <= S.last`. Поскольку мы знаем сверху, что `X` для всех таких голосов, сделанных `v` уникален, мы знаем, что вот такой уникальный `maximal` голос.

### Lemma 1:

`Claim:` Given a vote `Vote(X, S)` made by a validator `V`в `Оптимистические валидаторы` установлены, а `S` содержит голосование за слот `s` для которого:

- `с + s.lockout > B`,
- `s` не является предком или потомком `B`,

затем `X > B`.

```text
                                  +-------+
                                  |       |
                        +---------+       +--------+
                        |         |       |        |
                        |         +-------+        |
                        |                          |
                        |                          |
                        |                          |
                        |                      +---+---+
                        |                      |       |
                        |                      |       |  X'
                        |                      |       |
                        |                      +---+---+
                        |                          |
                        |                          |
                        |                      +---+---+
                        |                      |       |
                        |                      |       |  B (Optimistically Confirmed)
                        |                      |       |
                        |                      +---+---+
                        |                          |
                        |                          |
                        |                          |
                        |                      +---+---+
                        |                      |       |
                        |                      |       |  S'.last
                        |                      |       |
                        |                      +-------+
                        |
                    +---+---+
                    |       |
                 X  |       |
                    |       |
                    +---+---+
                        |
                        |
                        |
                        |
                        |
                        |
                    +---+---+
                    |       |
            S.last  |       |
                    |       |
                    +---+---+
                        |
                        |
                        |
                        |
                    +---+---+
                    |       |
      s + s.lockout |       |
                    +-------+
```

`Proof`. Допустим, в целях противоречия, валидатор `V` из Набор "Оптимистические валидаторы" сделал такое голосование `Vote (X, S)`, где `S` содержит голосование за слот `s`, не являющийся предком или потомком `B`, где `s + s.lockout > B`, but `X <= B`.

Пусть `Vote (X ', S')` будет голосом в наборе `Optimistic Votes`, сделанном валидатором `V`. По определению этого набора (все голоса оптимистично подтверждены `B`), `X' <= B <= S'.last` (см. диаграмму выше).

Это означает, что поскольку выше предполагается, что `X <= B`, then `X <= S'.last`, поэтому по правилам косой черты либо `X == X'` or `X < X'`(в противном случае перекрывают диапазон `(X ', S'.last)`).

`Case X == X'`:

Рассмотрим `с`. Мы знаем `s! = X`, потому что предполагается, что `s` не является предком или потомком `B` и `X` является предком `B`. Поскольку `S'.last` является потомком `B`, это означает, что `s` также не является предком или потомком `S'.last`. Тогда, поскольку `S.last` происходит от `s`, то `S'.last` также не может быть предком или потомком `S.last`. Это подразумевает ` X! = X '` в соответствии с правилами «Оптимистического снятия».

`Case X == X'`:

Интуитивно это означает, что `Vote (X, S)` был сделан "before" `Vote (X ', S')`.

Исходя из предположения выше, `s + s.lockout > B > X'`. Поскольку `s` не является предком ` X '`, блокировки были бы нарушены, когда этот валидатор впервые попытался отправить голос переключения `X'` с некоторые голоса форма `Vote (X ', S' ')`.

Поскольку ни один из этих случаев не действителен, предположение должно было быть неверным, и утверждение доказано.

### Lemma 2:

Напомним, что блок ` B '` был завершен на форке, отличной от «оптимистически» подтвержденного блока `B`.

`Claim`: For any vote `Vote(X, S)` in the `Optimistic Votes`должно быть верно, что `B' > X`

```text
                                +-------+
                                |       |
                       +--------+       +---------+
                       |        |       |         |
                       |        +-------+         |
                       |                          |
                       |                          |
                       |                          |
                       |                      +---+---+
                       |                      |       |
                       |                      |       |  X
                       |                      |       |
                       |                      +---+---+
                       |                          |
                       |                          |
                       |                      +---+---+
                       |                      |       |
                       |                      |       |  B (Optimistically Confirmed)
                       |                      |       |
                       |                      +---+---+
                       |                          |
                       |                          |
                       |                          |
                       |                      +---+---+
                       |                      |       |
                       |                      |       |  S.last
                       |                      |       |
                       |                      +-------+
                       |
                   +---+---+
                   |       |
    B'(Finalized)  |       |
                   |       |
                   +-------+
```

`Proof`: Let `Vote(X, S)` будет голосом в наборе `Optimistic Votes`. Затем по определению с учетом блока «оптимистически подтвержденного» `B`, `X <= B <= S.last`.

Поскольку `X` является родительским элементом `B`, а ` B '` не является родительским элементом или предком `B`, потом:

- `B' != X`
- ` B '` не является родительским для `X`

Теперь подумайте, если `B'` < `X`:

`Case B' < X`: мы покажем, что это нарушение блокировки. Из вышесказанного мы знаем, что ` B '` не является родительским элементом `X`. Затем, поскольку ` B '` был внедрен, и ` B '` не является родительским для `X`, значит, валидатор не мог голосовать за более высокий слот `X`, который не происходит от ` B '`.

### Доказательство безопасности:

Теперь мы стремимся показать, что хотя бы один из валидаторов в наборе `Оптимистические валидаторы` нарушил правило снятия.

Прежде всего обратите внимание, что для того, чтобы ` B '` был внедрен, должен быть `> 2/3` ставки, которые проголосовали за ` B '` или потомка `B'`. Поскольку набор `Optimistic Validator` также содержит `> 2/3`проверенных валидаторов, отсюда следует, что `> 1/3` проверенных валидаторов:

- Корневой ` B '` или потомок `B'`
- Также отправил голосование `v` в форме `Vote(X, S)` где `X <= B <= v.last`.

Пусть набор `Delinquent` будет набором валидаторов, которые соответствуют указанным выше критериям.

По определению, чтобы получить root-права на ` B '`, каждый валидатор `V` в `Delinquent` должен иметь «голос переключения» в форме `Голосовать (X_v, S_v)` где:

- `S_v.last > B'`
- `S_v.last` является потомком ` B '`, поэтому не может быть потомком `B`
- Поскольку `S_v.last` не является потомком `B`, тогда `X_v` не может быть потомком или предком `B`.

По определению, этот провинившийся валидатор `V` также сделал некоторый голос `Vote (X, S)` в `Оптимистических голосах`, где по определению этого набора (оптимистично подтверждено `B`), мы знаем `S.last >= B >= X`.

По `Lemma 2` мы знаем, что `B' > X`, а сверху `S_v.last > B'`, поэтому `S_v.last > X`. Поскольку `X_v! = X` (не может быть потомком или предком указанного выше `B`), то по правилам косой черты мы знаем, что `X_v > S.last`. Сверху, `S.last >= B >= X`, поэтому для всех таких "голосов переключения" `X_v > B`.

Теперь, упорядочив все эти «переключающие голоса» во времени, позвольте `V` быть валидатором в `Optimistic Validators`, который первым отправил такой «переключающий голос» `Vote (X ', S ')`, где `X' > B`. Мы знаем, что такой валидатор существует, потому что мы знаем сверху, что все просрочившие валидаторы должны были отправить такое голосование, а просрочившие валидаторы являются подмножеством `Оптимистических валидаторов`.

Пусть `Vote (X, S)` будет уникальным голосом в `Optimistic Votes`, сделанном валидатором `V` (максимизируя `S.last`).

Учитывая `Vote (X, S)`, потому что `X' > B >= X`, затем `X' > X`, поэтому по правилам "оптимистичного косого" `X' > S.last`.

Чтобы выполнить такое «переключение голосования» на ` X '`, должно быть подтверждено переключение `SP (Vote (X, S), Vote (X', S '))` показать `> 1/3` доли заблокирована на последнем голосовании этого валидатора, `S.last`. Объедините этот `> 1/3` с тем фактом, что набор валидаторов в наборе `Optimistic Voters` состоит из `> 2/3` ставки означает, что по крайней мере один оптимистичный валидатор `W` из набора `Optimistic Voters` должен был проголосовать (вспомните определение подтверждения переключения), `Vote (X_w, S_w)`, который был включен в подтверждение переключения валидатора `V` для слота ` X '`, где `S_w` содержит слот `s` такой, что:

- `s` не является обычным предком `S.last` и `X'`
- `s` не является потомком `validator_vote.last`.
- `s' + s'.lockout > S.last`

Поскольку `B` является предком `S.last`, это также верно в следующих случаях:

- `s` не является общим предком `B` и ` X '`
- `s' + s'.lockout > S.last`

который был включен в доказательство переключения `V`.

Теперь, поскольку `W` также является пользователем `Optimistic Voters`, то согласно приведенной выше `лемме 1`, получив голосование от `W`, `Vote (X_w, S_w)`, где `S_w` содержит голосование за слот `s`, где `s + s.lockout > B`, и `s` не является предком `B`, тогда `X_w > B`.

Поскольку валидатор `V` включил голос `Vote (X_w, S_w)` в свое доказательство переключения для слота ` X '`, то его подразумевает валидатор ` V '` отправил голос `Vote (X_w, S_w)` ** до того, как ** валидатор `V` отправил свой голос переключения для слота ` X '`, `Голосовать (X', S ')`.

Но это противоречие, потому что мы выбрали `Vote (X ', S')` как первое голосование, сделанное любым валидатором из набора `Optimistic Voters`, где `X ' & gt; B` и ` X '` не является потомком `B`.
