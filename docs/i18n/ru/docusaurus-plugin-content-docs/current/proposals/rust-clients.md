---
title: Клиенты Rust
---

## Проблематика

Тесты высокого уровня, такие как стендовые тесты, написаны с использованием свойства ` Client `. Когда мы выполняем эти тесты как часть набора тестов, мы используем низкоуровневую реализацию ` BankClient `. Когда нам нужно запустить тот же тест с кластером, мы используем реализацию `ThinClient`. Проблема с этим подходом заключается в том, что он означает, что свойство будет постоянно расширяться, чтобы включать новые служебные функции, и все его реализации должны добавлять новые функции. Отделяя объект, обращенный к пользователю, от признака, который абстрагирует сетевой интерфейс, мы можем расширить объект, обращенный к пользователю, чтобы включить в него всевозможные полезные функции, такие как «счетчик» из RpcClient, не беспокоясь о необходимости расширения признака и его реализации.

## Предлагаемое решение

Вместо реализации черты `Client`, `ThinClient` должен быть сконструирован с его реализацией. Таким образом, все служебные функции, которые в данный момент присутствуют в черте `Client`, могут переместиться в `ThinClient`. Затем `ThinClient` может перейти в `solana-sdk`, поскольку все его сетевые зависимости будут в реализации `Client`. Затем мы добавили бы новую реализацию `Client`, названную `ClusterClient`, и которая будет жить в коробке `solana-client`, где `ThinClient` в настоящее время проживает.

После этой реорганизации любой код, требующий клиента, будет написан на языке `ThinClient`. В модульных тестах функциональность вызывается с помощью `ThinClient<BankClient>`, тогда как функции `main()`, тесты производительности и интеграционные тесты вызывают ее с помощью `ThinClient<ClusterClient>`.

Если компоненты более высокого уровня требуют большей функциональности, чем то, что может быть реализовано с помощью `BankClient`, это должно быть реализовано вторым объектом, который реализует вторую характеристику, следуя тому же шаблону, описанному здесь.

### Если компоненты более высокого уровня требуют большей функциональности, чем то, что может быть реализовано с помощью BankClient, это должно быть реализовано вторым объектом, который реализует вторую характеристику, следуя тому же шаблону, описанному здесь

`Client` должен использовать существующее перечисление `TransportError` для ошибок, за исключением того, что поле `Custom (String)` следует изменить на `Custom(Box<dyn Error>)`.

### Стратегия реализации

1. Добавить новый объект в `solana-sdk`, `RpcClientTng`, где суффикс `Tng` является временным и обозначает "следующее поколение"
2. Инициализация `RpcClientTng` с реализацией `SyncClient`.
3. Добавить новый объект в `solana-sdk`, `ThinClientTng`; инициализировать его с `RpcClientTng` и реализацией `AsyncClient`
4. Переместите все модульные тесты из `BankClient`в`ThinClientTng<BankClient>`
5. Добавить `ClusterClient`
6. Переместить `RpcClient` пользователей в новый `ThinClient<ClusterClient>`
7. Удалить `RpcClient` и переименовать `RpcClientTng` в `RpcClient`
8. Переместить `RpcClient` пользователей в новый `ThinClient<ClusterClient>`
9. Удалить `RpcClient` и переименовать `RpcClientTng` в `RpcClient`
