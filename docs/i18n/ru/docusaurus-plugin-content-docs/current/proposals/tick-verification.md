---
title: Тик верификации
---

Это дизайн критериев и проверки тиков в слоте. В нем также описывается обработка ошибок и условия прерывания, включая то, как система обрабатывает передачи, которые не соответствуют этим требованиям.

# Структура слота

Каждый слот должен содержать ожидаемый `ticks_per_slot` количество тиков. Последний шред в слоте должен содержать только последний тик полностью и ничего больше. Лидер также должен пометить этот шред, содержащий последний тик, значком флаг `LAST_SHRED_IN_SLOT`. Между тиками должно быть `hashes_per_tick` количество хешей.

# Обработка плохих передач

Вредоносные передачи `T` обрабатываются двумя способами:

1. Если лидер может генерировать некоторую ошибочную передачу `T`, а также некоторую альтернативную передачу ` T '` для того же слота без нарушения каких-либо правил слешинга для повторяющихся передач (например, если ` T '` является подмножеством `T`), то кластер должен учитывать возможность того, что обе передачи будут активными.

Таким образом, это означает, что мы не можем пометить ошибочную передачу `T` как мертвую, потому что кластер, возможно, достиг консенсуса по ` T '`. В этих случаях требуется убедительное доказательство, чтобы наказать за такое плохое поведение.

2. В противном случае мы можем просто пометить слот как не рабочий и не воспроизводимый. Доказательство слешинга может потребоваться, а может и не потребоваться, в зависимости от осуществимости.

# Blockstore получение фрагментов

Когда blockstore получает новый фрагмент `s`, возможны два случая:

1. `s` помечен как `LAST_SHRED_IN_SLOT`, затем проверьте, существует ли фрагмент ` s '` в хранилище блоков для этого слота, где `s'.index > s.index` Если да, то вместе `s` и ` s '` представляют собой доказательство слешинга.

2. Blockstore уже получил фрагмент ` s '`, помеченный как `LAST_SHRED_IN_SLOT` с индексом `i`. Если`s.index > i`, тогда вместе `s` и ` s '` составляют убедительное доказательство. В этом случае blockstore также не будет вставлять `s`.

3. Повторяющиеся фрагменты для одного и того же индекса игнорируются. Отсутствие дублирования фрагментов для одного и того же индекса - условие, допускающее снятие. Подробности этого случая описаны в разделе `Снятие дублирующего блока лидера`.

# Повтор и валидация тиков

1. Этап воспроизведения воспроизводит записи из хранилища блоков, отслеживая количество тиков, которые он видел за слот, и проверяя наличие `hashes_per_tick` количества хешей между тиками. После того, как тик из этого последнего фрагментаа был воиспрозведен, этап воспроизведения затем проверяет общее количество тиков.

Сценарий сбоя 1. Если когда-либо есть два последовательных тика, между которыми количество хэшей составляет `! = Hashes_per_tick `, отметьте этот слот как нерабочий.

Сценарий сбоя 2: если количество ticks != `ticks_per_slot`, пометьте слот как нерабочий.

Сценарий сбоя 3. Если количество тиков достигает `ticks_per_slot`, но мы все еще не видели `LAST_SHRED_IN_SLOT`, отметьте этот слот как нерабочийй.

2. Когда ReplayStage достигает фрагмента, помеченного как последний фрагмент, он проверяет, является ли этот последний фрагмен тиком.

Сценарий сбоя: если подписанный клочок с флагом `LAST_SHRED_IN_SLOT` не может быть десериализован в тик (либо не выполняется десериализация, либо десериализуется в запись), отметьте этот слот как нерабочий.
