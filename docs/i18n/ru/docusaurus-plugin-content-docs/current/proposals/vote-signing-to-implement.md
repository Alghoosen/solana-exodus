---
title: Безопасное Подписание Голоса
---

## Безопасное Подписание Голоса

Этот дизайн описывает дополнительные действия при подписи голоса, которые сделают процесс более безопасным.

В настоящее время Solana использует службу подписи голосов, которая оценивает каждый голос, чтобы убедиться, что он не нарушает условие слешинга. Эта служба может иметь различные вариации, в зависимости от возможностей аппаратной платформы. В частности, он может использоваться совместно с безопасным анклавом \(таким как SGX\). Анклав может сгенерировать асимметричный ключ, открывая API пользовательскому \(ненадежному\) коду для подписания транзакций голосования, сохраняя приватный ключ, подписавший голос, в его защищённой памяти.

Следующие разделы описывают как будет работать эта архитектура:

### Поток сообщения

1. Нода инициализирует анклав при запуске

   - Анклав генерирует асимметричный ключ и возвращает открытый ключ

     ноде

   - Пара ключей эфемерна. При загрузке ноды генерируется новая пара ключей. А

     новый пара ключей может также генерироваться во время работы на основе некоторых определяемых

     критерий.

   - Анклав возвращает отчет аттестации ноде

2. Нода выполняет аттестацию анклава \(например с помощью Intel's IAS API\)

   - Нода проверяет, чтобы защищённый анклав был запущен в TPM и

     подписан доверенной стороной

3. Держатель стейка норды предоставляет разрешение эфемерного ключа на использование своего стейка.

   Этот процесс должен быть определен.

4. Ненадежное, не-анклавное ПО ноды вызывает доверенное ПО анклава

   используя свой интерфейс для подписания транзакций и других данных.

   - В случае подписи голоса, нода должна верифицировать PoH. PoH

     верификация является неотъемлемой частью подписи. Анклав будет

     представлен с некоторыми верифицируемыми данными для проверки перед подписанием голосования.

   - Необходимо определить процесс генерации проверяемых данных в ненадежном пространстве

### PoH верификация

1. Когда нода голосует за запись в `X`, есть период блокировки `N`, для того

   , который не может голосовать за форы, не содержащий `Х` в своей истории.

2. Каждый раз, когда нода голосует за производную `X`, например `X+y`, период

   блокировки для `X` увеличивается на фактор `F` \(т.е. длительность периода пока нода не может голосовать за

   форк, который не содержит `X` - увеличивается\).

   - Период блокировки для `X+y` все еще `N` до тех пор, пока нода снова не проголосует.

3. Приращение периода блокировки ограничено \(e.g. фактор `F` применяется максимум 32

   раза\).

4. Подписывающий анклав не должен подписывать голос, который нарушает эту политику. Это

   значит

   - Энклав инициализирован с `N`, `F` и `Factor cap`
   - Анклав хранит `Factor capp` количество идентификаторов записи, на ноде за которую

     ранее проголосовал

   - Запрос на подпись содержит идентификатор записи для нового голоса
   - Enclave проверяет, что ID нового голоса находится на правильном форке

     \(следуя правилам \#1 и \#2 выше\)

### Проверка Предшественника

Это альтернативный, хотя и менее определенный подход к проверке форка голосования. 1. Валидатор поддерживает активный набор нод в кластере 2. Он наблюдает за голосами от активной группы за последний период голосования 3. Он хранит предшественник/last_tick, за который проголосовала каждая нода 4. Он посылает запрос на новый голос в службу подписания голосов

- Он включает в себя предыдущие голоса от нод в активной группе, и их

  соответствующих предков

  1. Подписывающий проверяет, содержит ли предыдущие голоса голос от валидатора,

     и предшественник голосования совпадает с большинством узлов

- Если проверка прошла успешно, он подписывает новый голос
- Он утверждает \(поднимает какой-то сигнал тревоги\), если проверка не удалась

Предпосылка заключается в том, что валидатор может быть обманут самое большее один раз, чтобы проголосовать за неправильные данные. Если кто-то захватит валидатора и отправит запрос на голосование для фиктивных данных, этот голос не будет включен в PoH \(поскольку он будет отклонен кластером\). В следующий раз, когда валидатор отправит запрос на подпись голосования, служба подписи обнаружит, что последний голос валидатора отсутствует \(как часть

## пункта 5 выше).

### Обнаружение форка

Из-за того, что анклав не может обрабатывать PoH, он не имеет прямых сведений об истории форков поданного голоса валидатора. Каждый анклав должен быть инициирован с текущим _активным набором_ открытых ключей. Валидатор должен отправить свой текущий голос вместе с голосами активного набора \(включая самого себя\), которые он наблюдал в слоте своего предыдущего голосования. Таким образом, анклав может предположить голоса, сопровождающие предыдущее голосование валидатора, и, следовательно, форк, по которому проводится голосование. Это невозможно для первоначально представленного голоса валидатора, так как у него не будет "предыдущего" слота для ссылки. Чтобы учесть это, следует применять кратковременное замораживание голосования до тех пор, пока не будет подан второй голос, содержащий голоса в активном наборе вместе с собственным голосом на высоте первоначального голосования.

### Конфигурация анклава

Клиент стейкинга должен быть настраиваемым, чтобы предотвратить голосование на неактивных форках. Этот механизм должен использовать известный активный набор клиента `N_active` вместе с пороговым голосованием `N_голосом` и пороговой глубиной `N_depth`, чтобы определить, следует ли продолжать голосование по представленному форку. Эта конфигурация должна принять форму правила, чтобы клиент голосовал за форк, только если он наблюдает больше, чем `N_vote` в `N_depth`. Фактически, это означает, что клиент не подтверждает, что он наблюдал некоторую вероятность экономической финализации представленного форка на такой глубине, где дополнительное голосование приведет к блокировке на нежелательный период времени, если этот форк окажется не действующим.

### Проблемы

1. Генерация проверяемых данных в ненадежном месте для проверки PoH

   в анклаве.

2. Нужна инфраструктура для предоставления стейка эфемерному ключу.
