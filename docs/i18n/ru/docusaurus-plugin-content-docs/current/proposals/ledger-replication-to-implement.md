---
title: Репликация реестра
---

Примечание: это решение для репликации реестра было частично реализовано, но не завершено. Частичная реализация была удалена https://github.com/solana-labs/solana/pull/9992, чтобы предотвратить риск использовать неиспользуемый код. Первая часть этого проектного документа отражает некогда реализованные части репликации реестра. [ вторая часть этого документа ](#ledger-replication-not-implemented) описывает части решения, которые никогда не реализовывались.

## Подтверждение репликации

При полной пропускной способности сети в 1gbps солана будет генерировать 4 петабайта данных в год. Чтобы предотвратить централизацию сети вокруг валидаторов, которые должны хранить полный набор данных, этот протокол предлагает способ для узлов майнинга обеспечивать емкость хранилища для частей данных.

Основная идея Proof of Replication - это шифрование набора данных с помощью открытого симметричного ключа с использованием шифрования CBC, а затем хеширование зашифрованного набора данных. Основная проблема наивного подхода заключается в том, что нечестный узел хранения может передавать шифрование и удалять данные по мере их хеширования. Простое решение - периодически регенерировать хэш на основе подписанного значения PoH. Это гарантирует, что все данные присутствуют во время генерации доказательства, а также требует, чтобы валидаторы имели все зашифрованные данные для проверки каждого доказательства каждой личности. Таким образом, для проверки требуется пространство `number_of_proofs * data_size`

## Оптимизация с помощью PoH

Наше усовершенствование этого подхода состоит в том, что мы производим случайную выборку зашифрованных сегментов быстрее, чем требуется для шифрования, и записываем хэш этих выборок в реестр PoH. Таким образом, сегменты остаются в одном и том же порядке для каждого PoRep, и проверка может передавать данные и проверять все доказательства в одном пакете. Таким образом, мы можем одновременно проверять несколько доказательств, каждое на собственном ядре CUDA. Общее пространство, необходимое для проверки, составляет `1_ledger_segment + 2_cbc_blocks * number_of_identities` с количеством ядер, равным `number_of_identities`. Мы используем 64-байтный размер блока chacha CBC.

## Сеть

Валидаторы для PoRep являются теми же валидаторами, которые проверяют транзакции. Если архив может доказать, что валидатор проверил поддельный PoRep, то валидатор не получит награду за эту эпоху.

Архиваторы - это специализированные _light clients_. Они загружают часть реестра \ (он же сегмент \) и хранят ее, а также предоставляют PoRep для хранения реестра. За каждого проверенного архива PoRep заработайте награду sol из майнинг пула.

## Ограничения

У нас есть следующие ограничения:

- Для проверки требуется создание блоков CBC. Для этого требуется место 2

  блоков на удостоверение и 1 ядро CUDA на удостоверение для одного и того же набора данных. Так как

  сразу несколько личностей должны быть объединены с как можно большим количеством доказательств для тех

  идентичности проверяются одновременно для одного и того же набора данных.

- Валидаторы будут случайным образом отбирать набор доказательств хранения для набора, который

  они могут справиться, и только создатели этих выбранных доказательств будут

  вознаграждены. Валидатор может запускать тест всякий раз, когда его аппаратная конфигурация

  изменения, чтобы определить, с какой скоростью он может проверять доказательства хранения.

## Протокол проверки и репликации

### Константы

1. SLOTS_PER_SEGMENT: количество слотов в сегменте данных реестра. В

   единицах хранения для архиватора.

2. NUM_KEY_ROTATION_SEGMENTS: Количество звеньев, после которых архивируется

   восстановите свои ключи шифрования и выберите новый набор данных для хранения.

3. NUM_STORAGE_PROOFS: Необходимое количествоподтверждений для хранения

   претендовать на успешное вознаграждение.

4. RATIO_OF_FAKE_PROOFS: отношение поддельных подтверждений к реальным подтверждениям, которые должны содержаться в заявлении о подтверждении добычи в хранилище,

   чтобы быть заявленным для вознаграждения.

5. NUM_STORAGE_SAMPLES: Количество образцов, необходимых для добычи

   подтверждение.

6. NUM_CHACHA_ROUNDS: Количество раундов шифрования, выполненных для генерации

   зашифрованного состояние.

7. NUM_SLOTS_PER_TURN: Количество слотов, определяющих одну эпоху хранения или

   «ход» игры PoRep.

### Поведение валидации

1. Валидаторы присоединяются к сети и начинают искать аккаунты архиватора на каждом

   на каждой границе эпохи / периода хранения.

2. Каждый ход валидаторы подписывают значение PoH на границе и используют эту подпись

   для случайного выбора доказательств для проверки из каждого аккаунта хранения, найденной на границе хода.

   Это подписанное значение также отправляется в аккаунт хранения валидатора и будет использоваться

   архиваторами на более позднем этапе для перекрестной проверки.

3. Каждые слоты `NUM_SLOTS_PER_TURN` валидатор объявляет значение PoH. Это значение

   также передается архиваторам через интерфейсы RPC.

4. Для данного хода N, все проверки закрываются до поворота N+3 \(разрыв 2 оборота/эпоха\).

   На каком этапе все проверки в течение этого поворота доступны для сбора наград.

5. Любые неправильные проверки будут отмечены во время промежуточного хода.

### Поведение архиватора

1. Поскольку архиватор - это своего рода легкий клиент и не загружает все

   данные реестра, им приходится полагаться на другие валидаторы и архиваторы для получения информации.

   Любой конкретный валидатор может быть или не быть вредоносным и давать неверную информацию, хотя

   не существует каких-либо очевидных векторов атаки, которые он мог бы выполнить, кроме того,

   что архиватор выполнял дополнительную бесполезную работу. Для многих операций есть несколько вариантов, в зависимости от того, насколько параноидален архиватор

   в зависимости от того, насколько неуравновешен архиватор:

   - \ (a \) архиватор может запросить валидатор
   - \ (b \) архиватор может запрашивать несколько валидаторов
   - \ (c \) архиватор может спросить у других архиваторов
   - \(d\) архиватор может подписаться на полный поток транзакций и генерировать

     информацию сам \ (при условии, что слот достаточно свежий \)

   - \ (e \) архиватор может подписаться на сокращенный поток транзакций, чтобы

     генерировать саму информацию \ (при условии, что слот достаточно свежий \)

2. Архиватор получает хэш PoH, соответствующий последнему ходу со своим слотом.
3. Архиватор подписывает хэш PoH своей парой ключей. Эта подпись является

   сидом, используемым для выбора сегмента для репликации, а также ключа шифрования. Архиватор

   модифицирует подпись со слотом, чтобы узнать, какой сегмент

   реплицировать.

4. Архиватор извлекает реестр, запрашивая одноранговых валидаторов и

   архиваторов. см. 6.5.

5. Затем архиватор шифрует этот сегмент ключом с помощью алгоритма

   в режиме CBC с `NUM_CHACHA_ROUNDS` шифрованием.

6. Архиватор инициализирует сеанс связи с недавним подписанным значением PoH в качестве начального

   сида.

7. Архив генерирует `NUM_STORAGE_SAMPLES` образцы в диапазоне

   размер записи и образцы зашифрованного сегмента с sha256 для 32 байт в каждом

   значение сдвига. Выборка состояния должна выполняться быстрее, чем создание зашифрованного

   сегмента.

8. Архиватор отправляет подтвержденную транзакцию PoRep, которая содержит ее состояние sha

   в конце операции выборки, ее начальное значение и использованные ею образцы

   текущему лидеру, и она помещается в реестр.

9. Во время данного хода архиватор должен представить множество доказательств для одного и того же сегмента,

   и на основании `RATIO_OF_FAKE_PROOFS` некоторые из этих доказательств должны быть поддельными.

10. Когда игра PoRep входит в следующий ход, архиватор должен отправить транзакцию с маской,

    доказательства которой были поддельными во время последнего хода. Эта

    транзакция определит вознаграждение как для архиваторов, так и для валидаторов.

11. Наконец, для хода N, когда игра PoRep входит в ход N + 3, доказательства архиватора

    для хода N будут засчитаны в их награды.

### Игра PoRep

Доказательство репликации игры имеет 4 начальных этапа. Для каждого «хода» может выполняться несколько игр PoRep, но каждая на своей стадии.

Четыре этапа игры PoRep являются следующими:

1. Этап подтверждения доказательств
   - Архиваторы: предоставьте как можно больше подтверждений на этом этапе
   - Валидаторы: No-op
2. Подтвержденный этап проверки
   - Архиваторы: No-op
   - Валидаторы: выберите архиваторов и проверьте их доказательства с предыдущего хода
3. Подтверждение этапа испытания
   - Архиваторы: отправьте маску доказательства с обоснованиями \ (для поддельных доказательств, представленных 2 хода назад \)
   - Валидаторы: No-op
4. Этап сбора наград
   - Архиваторы: собирайте награды за прошедших 3 хода
   - Архиваторы: собирайте награды за прошедших 3 хода

На каждом этапе игры PoRep и валидаторы, и архиваторы оценивают каждый этап. Этапы выполняются как отдельные транзакции в программе хранения.

### Поиск того, у кого есть данный блок реестра

1. Валидаторы отслеживают ходы в игре PoRep и проверяют корневой банк

   на границах хода на предмет каких-либо доказательств.

2. Валидаторы поддерживают карту сегментов реестра и соответствующих публичных ключей архиватора.

   Карта обновляется, когда валидатор обрабатывает доказательства архиватора для сегмента.

   Валидатор предоставляет интерфейс RPC для доступа к этой карте. Используя этот API, клиентов

   может отобразить сегмент на сетевой адрес архиватора \ (сопоставив его с помощью таблицы cluster_info \).

   Затем клиенты могут отправлять запросы на восстановление в архиватор для извлечения сегментов.

3. Валидаторам необходимо будет аннулировать этот список каждые N ходов.

## Атаки Sybil

Для любого случайного сида мы заставляем всех использовать подпись, полученную из хэша PoH на границе поворота. Все используют одно и то же количество, поэтому каждый участник подписывает один и тот же хэш PoH. Затем каждая подпись криптографически привязывается к паре ключей, что не позволяет лидеру обработать результирующее значение для более чем одной идентичности.

Поскольку идентификаторов клиентов гораздо больше, чем идентификаторов шифрования, нам необходимо разделить вознаграждение для нескольких клиентов и предотвратить создание атак Sybil множества клиентов для получения одного и того же блока данных. Чтобы оставаться BFT, мы не хотим, чтобы один человек мог хранить все копии одного фрагмента реестра.

Наше решение - заставить клиентов продолжать использовать ту же личность. Если первый раунд используется для получения одного и того же блока для многих идентификаторов клиентов, второй раунд для тех же идентификаторов клиентов вызовет перераспределение подписей и, следовательно, идентификаторов и блоков PoRep. Таким образом, чтобы получить вознаграждение, архиваторам необходимо хранить первый блок бесплатно, и сеть может вознаграждать долгоживущие идентификаторы клиентов больше, чем новые.

## Атаки валидатора

- Если валидатор утверждает поддельные доказательства, архиватор может легко их распознать,

  показывает начальное состояние хеша.

- Если валидатор помечает реальные доказательства как поддельные, вычисления в цепочке не могут быть выполнены

  чтобы отличить, кто прав. Награды должны зависеть от результатов

  несколько валидаторов, чтобы поймать злоумышленников и архиваторов, которым отказывают в вознаграждении.

- Валидатор крадет для себя результаты доказательства майнинга. Доказательства получены

  из подписи архиватора, поскольку валидатор не знает

  приватный ключ, используемый для генерации ключа шифрования, он не может быть генератором

  доказательства.

## Поощрения за вознаграждение

Поддельные доказательства легко создать, но сложно проверить. По этой причине транзакции с подтверждением PoRep, сгенерированные архиваторами, могут потребовать более высокой комиссии, чем обычная транзакция, чтобы представить вычислительные затраты, требуемые валидаторами.

Некоторый процент поддельных доказательств также необходим для получения вознаграждения за майнинг хранилища.

## Примечания

- Мы можем снизить затраты на проверку PoRep с помощью PoH и фактически

  сделать возможным проверку большого количества доказательств для глобального набора данных.

- Мы можем устранить измельчение, заставив всех подписать один и

  тот же хеш PoH и использовать подписи в качестве сида

- Игра между валидаторами и архиваторами заключается в случайных блоках, случайных

  идентификаторах шифрования и случайных выборках данных. Цель рандомизации -

  предотвратить перекрытие сговорившихся групп по данным или валидации.

- Клиенты архиватора ловят ленивых валидаторов, представляя поддельные доказательства, которые,

  как они могут доказать, являются поддельными.

- Чтобы защититься от идентификаторов клиентов Sybil, которые пытаются сохранить один и тот же блок, мы

  заставляем клиентов хранить несколько раундов, прежде чем получить вознаграждение.

- Валидаторы также должны получать вознаграждение за проверку предоставленных доказательств

  хранения в качестве стимула для хранения реестра. Они могут проверять доказательства только в том случае,

  если хранят этот фрагмент реестра.

# Репликация реестра не реализована

Поведение репликации еще не реализовано.

## Эпоха хранения

Эпохой хранения должно быть количество слотов, в результате чего для архиваторов будет создано около 100–1 Тб реестра. Архиваторы начнут хранить реестр, когда для данного форка высока вероятность того, что откат не будет.

## Поведение валидации

1. Каждые NUM_KEY_ROTATION_TICKS он также проверяет образцы, полученные от

   архиваторов. В этот момент он подписывает хэш PoH и использует следующий

   алгоритм с подписью в качестве входных данных:

   - Нижние 5 бит первого байта подписи создают индекс в

     другой начальный байт подписи.

   - Затем валидатор просматривает набор доказательств хранения, где байт

     вектора состояния sha доказательства, начиная с младшего байта, точно совпадает

     с выбранным байтом \ (s \) подписи.

   - Если набор доказательств больше, чем может обработать валидатор, то он

     увеличивается до соответствия 2 байтам в подписи.

   - Валидатор продолжает увеличивать количество совпадающих байтов, пока

     не будет найден работоспособный набор.

   - Затем он создает маску действительных и поддельных доказательств и отправляет ее

     лидеру. Это транзакция подтверждения доказательства хранения.

2. После периода блокировки в NUM_SECONDS_STORAGE_LOCKOUT секунд

   валидатор затем отправляет транзакцию требования доказательства хранения, которая затем вызывает

   распределение вознаграждения за хранилище, если не было замечено никаких проблем для доказательства,

   валидаторам и архиваторам, участвующим в доказательствах.

## Поведение архиватора

1. Затем архиватор генерирует еще один набор смещений, который отправляет поддельное

   доказательство с неправильным состоянием sha. Можно доказать, что это подделка,

   предоставив сидов для результата хеширования.

   - Поддельное доказательство должно состоять из хэша архиватора подписи PoH

     значения. Таким образом, когда архиватор обнаружит поддельное доказательство, его можно будет

     проверить по цепочке.

2. Архиватор следит за реестром, если он видит интегрированное поддельное доказательство, он

   создает транзакцию запроса и отправляет ее текущему лидеру. Транзакция

   доказывает, что валидатор неправильно проверил поддельное доказательство хранения.

   Архиватор получает вознаграждение, а баланс стейкинга валидатора сокращается или

   замораживается.

## Логика контракта доказательства хранения

У каждого архиватора и валидатора будет свой аккаунт хранения. Аккаунт валидаторов будет отделен от их идентификатора gossip, как и его аккаунта для голосования. Они должны быть реализованы как две программы: одна обрабатывает валидатор как подписчик ключей, а другая - архиватор. Они должны быть реализованы как две программы: одна обрабатывает валидатор как подписчик ключей, а другая - архиватор.

### SubmitMiningProof

```text
SubmitMiningProof {
    slot: u64,
    sha_state: Hash,
    signature: Signature,
};
keys = [archiver_keypair]
```

Архиваторы создают их после анализа хранимых в них данных бухгалтерской книги на предмет определенного хэш-значения. Архиваторы создают их после анализа хранимых в них данных реестра на предмет определенного хэш-значения. Подпись - это подпись, которая была создана, когда они подписали значение PoH для текущей эпохи хранения. Список доказательств из текущей эпохи хранения должен быть сохранен в состоянии реестре, а затем перенесен в список доказательств для предыдущей эпохи, когда эпоха пройдет. В данную эпоху хранения данный архиватор должен представлять подтверждения только для одного сегмента.

Программа должна иметь список слотов, которые являются допустимыми слотами для майнинга хранилища. Этот список следует поддерживать, отслеживая слоты, которые являются корневыми слотами, за которые значительная часть сети проголосовала с высоким значением блокировки, возможно, с 32 голосами давности. Каждое количество слотов SLOTS_PER_SEGMENT будет добавлено к этому набору. Программа должна проверить, входит ли слот в этот набор. Набор может поддерживаться путем получения AdvertiseStorageRecentBlockHash и проверки его состояния банка / башни BFT.

Программа должна выполнить проверку подписи для подписи, открытого ключа от отправителя транзакции и сообщения о значении PoH предыдущей эпохи хранения.

### ProofValidation

```text
ProofValidation {
   proof_mask: Vec<ProofStatus>,
}
keys = [validator_keypair, archiver_keypair(s) (unsigned)]
```

Валидатор отправит эту транзакцию, чтобы указать, что набор доказательств для данного сегмента действителен / недействителен или пропущен там, где валидатор не смотрел на него. Пары ключей для архиваторов, которые он просматривал, должны быть указаны в ключах, чтобы логика программы могла перейти к этим учетным записям и увидеть, что доказательства были сгенерированы в предыдущую эпоху. Выборка доказательств хранения должна быть проверена, гарантируя, что правильные доказательства пропущены валидатором в соответствии с логикой, изложенной в поведении валидатора при выборке.

Включенные ключи архиватора будут указывать на образцы хранилища, на которые ссылаются; длина маски proof_mask должна сравниваться с набором доказательств хранения в указанном аккаунте архиватора \ (s \) и должна совпадать с количеством доказательств, отправленных в предыдущую эпоху хранения в состоянии указанном аккаунте архиватора.

### ClaimStorageReward

```text
ClaimStorageReward {
}
keys = [validator_keypair or archiver_keypair, validator/archiver_keypairs (unsigned)]
```

Архиваторы и валидаторы будут использовать эту транзакцию для получения оплаченных токенов из состояния программы, в котором SubmitStorageProof, ProofValidation и ChallengeProofValidations находятся в состоянии, когда подтверждения были отправлены и проверены, и нет ChallengeProofValidations, ссылающихся на эти подтверждения. Для валидатора он должен ссылаться на пары ключей архиватора, на которых он проверил подтверждения в соответствующую эпоху. А для архиватора он должен ссылаться на пары ключей валидатора, которые он проверил и хочет получить вознаграждение.

### ChallengeProofValidation

```text
ChallengeProofValidation {
    proof_index: u64,
    hash_seed_value: Vec<u8>,
}
keys = [archiver_keypair, validator_keypair]
```

Эта транзакция предназначена для поимки ленивых валидаторов, которые не выполняют работу по проверке доказательств. Архиватор отправит эту транзакцию, когда увидит, что валидатор одобрил поддельную транзакцию SubmitMiningProof. Поскольку архиватор - это легкий клиент, не просматривающий всю цепочку, ему придется запросить эту информацию у валидатора или некоторого набора валидаторов, возможно, через вызов RPC, чтобы получить все ProofValidations для определенного сегмента в предыдущую эпоху хранения. Поскольку архиватор - это легкий клиент, не просматривающий всю цепочку, ему придется запросить эту информацию у валидатора или некоторого набора валидаторов, возможно, через вызов Rpc, чтобы получить все ProofValidations для определенного сегмента в предыдущую эпоху хранения. Если это так, то он сохранит задачу в списке задач, которые она имеет в своем состоянии.

### AdvertiseStorageRecentBlockhash

```text
AdvertiseStorageRecentBlockhash {
    hash: Hash,
    slot: u64,
}
```

Валидаторы и архиваторы представят это, чтобы указать, что новая эпоха хранения прошла, и что доказательства хранения, которые являются текущими доказательствами, теперь должны быть для предыдущей эпохи. Другие транзакции должны проверить, что эпоха, на которую они ссылаются, является точной в соответствии с текущим состоянием цепочки.
