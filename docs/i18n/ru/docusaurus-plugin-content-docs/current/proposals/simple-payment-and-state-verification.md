---
title: Простой платеж и проверка состояния
---

Часто бывает полезно разрешить клиентам с ограниченными ресурсами участвовать в кластере Solana. Будь то экономическое участие или исполнение контракта, проверка того, что деятельность клиента была принята сетью, обычно стоит дорого. Это предложение излагает механизм для таких клиентов, чтобы подтвердить, что их действия были зафиксированы в состоянии реестра с минимальными затратами ресурсов и доверием третьих сторон.

## Наивный подход

Валидаторы хранят подписи недавно подтвержденных транзакций в течение короткого периода времени, чтобы гарантировать, что они не будут обработаны более одного раза. Валидаторы предоставляют конечную точку JSON RPC, которую клиенты могут использовать для запроса кластера, если транзакция была недавно обработана. Валидаторы также предоставляют уведомление PubSub, посредством чего клиент регистрируется, чтобы получить уведомление, когда данная подпись будет обнаружена валидатором. Хотя эти два механизма позволяют клиенту проверить платеж, они не являются доказательством и полагаются на полное доверие валидатору.

Мы опишем способ минимизировать это доверие с помощью Merkle Proofs, чтобы закрепить ответ валидатора в реестре, позволяя клиенту самостоятельно подтвердить, что достаточное количество предпочитаемых им валидаторов подтвердили транзакцию. Требование нескольких подтверждений валидатора еще больше снижает доверие к валидатору, поскольку увеличивает как технические, так и экономические трудности, связанные с компрометацией нескольких других участников сети.

## Лёгкий клиент

«Легкий клиент» - это участник кластера, который сам не запускает валидатор. Этот легкий клиент обеспечит уровень безопасности выше, чем доверие удаленному валидатору, не требуя от легкого клиента тратить много ресурсов на проверку реестра.

Вместо того, чтобы предоставлять подписи транзакций непосредственно легкому клиенту, валидатор вместо этого генерирует доказательство Меркла от интересующей транзакции до корня Дерева Меркла всех транзакций во включающем блоке. Этот корень Меркла хранится в записи реестра, за которую голосуют валидаторы, что обеспечивает ее законность на основе консенсуса. Дополнительный уровень безопасности для легкого клиента зависит от начального канонического набора валидаторов, который легкий клиент считает заинтересованными сторонами кластера. При изменении этого набора клиент может обновить свой внутренний набор известных валидаторов с помощью [ чеков ](simple-payment-and-state-verification.md#receipts). Это может стать проблемой при большом количестве делегированных ставок.

Сами валидаторы могут захотеть использовать легкие клиентские API из соображений производительности. Например, во время первоначального запуска валидатора, валидатор может использовать предоставленную кластером контрольную точку состояния и проверять ее с помощью чеков.

## Чеки

Чек- минимальное доказательство того, что транзакция была включена в блок, за блок проголосовал предпочтительный набор валидаторов клиента и что голоса достигли желаемой глубины подтверждения.

### Подтверждение включения транзакции

Доказательство включения транзакции - это структура данных, которая содержит путь Меркла от транзакции через Entry-Merkle к Block-Merkle, который включен в Bank-Hash с необходимым набором голосов валидатора. Цепочка записей PoH, содержащих последующие голоса валидаторов, происходящие от Bank-Hash, является доказательством подтверждения.

#### Транзакция Меркла

Entry-Merkle - это корень Merkle, включающий все транзакции в данной записи, отсортированные по подписи. Каждая транзакция в записи уже размещена здесь: https://github.com/solana-labs/solana/blob/b6bfed64cb159ee67bb6bdbaefc7f833bbed3563/ledger/src/entry.rs#L205. Это означает, что мы можем показать, что транзакция ` T ` была включена в запись ` E `.

Block-Merkle - это корень Меркла для всех секвенированных в блоке Entry-Merkle.

![Диаграмма Merkle блока](/img/spv-block-merkle.svg)

Вместе два доказательства Меркла показывают, что транзакция ` T ` была включена в блок с банковским хешем ` B `.

Accounts-Hash - это хэш конкатенации хэшей состояния каждом аккаунте, измененной в текущем слоте.

Статус транзакции необходим для квитанции, потому что квитанция о состоянии создается для блока. Две транзакции в одном и том же состоянии могут появиться в блок, и, следовательно, нет никакого способа сделать вывод только по состоянию на основе того, была ли транзакция, зафиксированная в реестре, успешной или неудачной при изменении предполагаемого состояния. Может потребоваться кодирование не полного кода состояния, а только одного бита состояния, чтобы указать на успешность транзакции.

В настоящее время Block-Merkle не реализован, поэтому для проверки того, что ` E ` был записью в блоке с банковским хешем ` B `, нам нужно будет предоставить все хэши записей в блокировать. В идеале этот Block-Merkleдолжен быть реализован, поскольку альтернатива очень неэффективна.

#### Заголовки Блоков
Чтобы проверить доказательства включения транзакции, легкие клиенты должны иметь возможность делать выводы о топологии форков в сети

В частности, легкому клиенту потребуется отслеживать заголовки входящих блоков, чтобы, учитывая два хэша банка для блоков ` A ` и ` B `, они могли определить, соответствует ли ` A ` является предком ` B ` (ниже в разделе ` Оптимистическое подтверждение подтверждения ` объясняется, почему!). Содержание заголовка - это поля, необходимые для вычисления банковского хэша.

Bank-Hash - это хэш слияния Block-Merkle и Accounts-Hash описанный выше в разделе `Transaction Merkle`.

![Диаграмма хеша банка](/img/spv-bank-hash.svg)

В коде:

https://github.com/solana-labs/solana/blob/b6bfed64cb159ee67bb6bdbaefc7f833bbed3563/runtime/src/bank.rs#L3468-L3473

```
        let mut hash = hashv(&[
            // bank hash of the parent block
            self.parent_hash.as_ref(),
            // hash of all the modifed accounts
            accounts_delta_hash.hash.as_ref(),
            // Number of signatures processed in this block
            &signature_count_buf,
            // Last PoH hash in this block
            self.last_blockhash().as_ref(),
        ]);
```

Хорошее место для реализации этой логики наряду с существующей логикой потоковой передачи в логике воспроизведения валидатора: https://github.com/solana-labs/solana/blob/b6bfed64cb159ee67bb6bdbaefc7f833bbed3563/core/src/replay_stage.rs#L1092-L1096

#### Оптимистическое подтверждение

В настоящее время оптимистичное подтверждение обнаруживается через слушателя, который отслеживает gossip и replay pipeline голосов: https://github.com/solana-labs/solana/blob/b6bfed64cb159ee67bb6bdbaefc7f833bbed3563/core/src/cluster_info_vote_listener.rs#L604-L614.

Каждый голос представляет собой подписанную транзакцию, которая включает в себя банковский хэш блока, за который проголосовал валидатор, то есть ` B ` из раздела ` Transaction Merkle ` выше. После того, как определенный порог ` T ` сети проголосовал за блок, блок считается оптимально подтвержденным. Голоса, сделанные этой группой валидаторов ` T ` необходимы, чтобы показать, что блок с банковским хешем ` B ` был оптимистично подтвержден.

Однако, за исключением некоторых метаданных, подписанные голоса в настоящее время нигде не хранятся, поэтому их нельзя получить по запросу. Эти голоса, вероятно, необходимо сохранить в базе данных Rocksdb, проиндексировав ключом ` (Slot, Hash, Pubkey) `, который представляет слот для голосования, банковский хеш-код голоса и pubkey аккаунта для голосования, ответственный за голосование.

Вместе доказательства транзакции и оптимистичного подтверждения могут быть предоставлены подписчикам через RPC путем расширения существующей логики подписки на подпись. Клиенты, подписавшиеся на подтверждение «SingleGossip» уровня уже уведомлены, когда обнаружено оптимистичное подтверждение, может быть предоставлен флаг, сигнализирующий, что два вышеупомянутых доказательства также должны быть возвращены.

Важно отметить, что оптимистическое подтверждение ` B ` также подразумевает, что все блоки-предки ` B ` также оптимистично подтверждены, а также что не все блоки будут подтверждены оптимистично.

```

B -> B'

```

Таким образом, в приведенном выше примере, если блок ` B '` оптимизирован, то также и ` B `. Таким образом, если транзакция была в блоке ` B `, транзакция в доказательстве будет для блока ` B `, но голоса, представленные в доказательстве, будут для блока ` B '`. Вот почему важны заголовки в разделе ` Заголовки блоков ` выше, клиенту необходимо будет убедиться, что ` B ` действительно является предком ` B '`.

#### Подтверждение распределения стейка

После представления транзакции и оптимистичных подтверждений подтверждения выше, клиент может проверить, что транзакция ` T ` была оптимистично подтверждена в блоке с банковским хешем ` B `. Последний недостающий элемент - это как проверить, что голоса в приведенных выше оптимистических доказательствах фактически составляют действительный ` T ` процент ставки, необходимый для обеспечения гарантий безопасности «оптимистического подтверждения».

Один из способов приблизиться к этому может заключаться в том, чтобы для каждой эпохи, когда набор ставок изменяется, записывать все ставки в системный аккаунт, а затем иметь валидаторы, подписывающиеся на эту системный аккаунт. Затем полные узлы могут предоставить Меркл, доказывающий, что состояние системного аккаунта было обновлено в каком-то блоке ` B `, а затем показать, что блок ` B ` был оптимистично подтвержден / внедрен.

### Верификация состояния аккаунта

Состояние аккаунта (баланс или другие данные) можно проверить, отправив транзакцию с помощью **_TBD_** инструкции для кластера. Затем клиент может использовать [ подтверждение включения транзакции ](#transaction-inclusion-proof), чтобы проверить, согласен ли кластер с тем, что счет достиг ожидаемого состояния.

### Голоса валидаторов

Лидеры должны объединить голоса валидаторов по весу ставок в одну запись. Это уменьшит количество записей, необходимых для создания чека.

### Цепочка записей

Чек имеет ссылку PoH от корня платежа или состояния Merkle Path до списка последовательных проверочных голосов.

В нем содержится следующее:

- Транзакция -&gt; Вход-Меркле -&gt; Блок-Меркле -&gt; Банк-хэш

И вектор PoH записей:

- Записи о голосовании валидатора
- Тики
- Лёгкие записи

```text
/// Это определение записи пропускает транзакции и содержит только
/// хеш транзакций, используемых для изменения PoH.
LightEntry {
    /// Количество хэшей с предыдущего идентификатора.
    pub num_hashes: u64,
    /// SHA-256 хэш `num_hashes` после предыдущего идентификатора записи.
    hash: Hash,
     /// Корень Меркла транзакций, закодированных во Входе.
    entry_hash: Hash,
}
```

Легкие записи реконструируются из записей и просто показывают запись Merkle Root, которая была подмешана к хешу PoH, вместо полного набора транзакций.

Клиентам не нужно состояние начала голосования. Алгоритм [ выбора форка ](../implemented-proposals/tower-bft.md) определен таким образом, что только голоса, которые появляются после транзакции, обеспечивают окончательность транзакции, и окончательность не зависит от начальное состояние.

### Верификация

Легкий клиент, который знает о валидаторах набора супербольшинства, может проверить получение, следуя Merkle Path к цепочке PoH. Блок-Меркл является Корнем Меркла и будет отображаться в голосах, включенных в Заявку. Легкий клиент может имитировать [ выбор форка ](../implemented-proposals/tower-bft.md) для последовательных голосований и убедитесь, что получение подтверждено на желаемом пороге блокировки.

### Синтетическое состояние

Синтетическое состояние должно быть вычислено в Банк-хэш вместе с состоянием, сгенерированным банком.

Пример:

- Аккаунти валидатора эпохи, их ставки и веса.
- Вычисляемые комиссии

Эти значения должны иметь запись в Банк-Хаш. Они должны жить под известными аккаунтами и, следовательно, иметь индекс в хеш-конкатенации.
