---
title: Служба Gossip
---

Служба Gossip работает как шлюз к узлам в плоскости управления. Валидаторы используют сервис для обеспечения доступности информации для всех других узлов кластера. Сервис транслирует информацию, используя протокол Gossip.

## Обзор Gossip

Узлы постоянно обмениваются между собой подписанными объектами данных для управления кластером. Например, они обмениваются контактной информацией, высотой реестра и голосами.

Каждую десятую секунды каждый узел посылает сообщение "push" и/или сообщение "pull". Push и pull сообщения могут вызывать ответы, а push-сообщения могут быть направлены другим в кластере.

Gossip работает на хорошо известном UDP/IP порту или порту в известном диапазоне. После начальной загрузки кластера узлы сообщают друг другу, где найти их конечную точку Gossip \(адрес сокета\).

## Записи Gossip

Записи, передаваемые через gossip, являются произвольными, но подписываются и версируются \(с отметкой времени\), что необходимо, чтобы иметь смысл для узла, принимающего их. Если узел получает две записи из одного и того же источника, он обновляет свою собственную копию записью с самой последней меткой времени.

## Интерфейс службы Gossip

### Push-сообщение

Узел отправляет push-сообщение для того, чтобы сообщить кластеру, что у него есть информация для распространения. Узлы отправляют push-сообщения `PUSH_FANOUT` push-пирам.

После получения push-сообщения узел проверяет сообщение:

1. Дублирование: если сообщение было просмотрено ранее, узел отбрасывает сообщение и может ответить `PushMessagePrune`, если перенаправлено с узла с низким стейком
2. Новые данные: если сообщение является новым для узла

   - Сохраняет новую информацию с обновленной версией в информации о кластере и

     очищает все предыдущие значения

   - Сохраняет сообщение в `pushed_once` \(используется для обнаружения дубликатов,

     очищается после `PUSH_MSG_TIMEOUT * 5` мс\)

   - Перенаправляет сообщения своим пирам push

3. Истечение срока действия: узлы отбрасывают push-сообщения старше `PUSH_MSG_TIMEOUT`

### Push-пиры, Prune сообщение

Узлы случайным образом выбирают своих push-пиров из активного набора известных пиров. Узел сохраняет этот выбор в течение относительно долгого времени. Когда получено сообщение об удалении, узел удаляет push-пир, который отправил prune. Prune - это указание на то, что существует другой путь к этому узлу с более высоким стейком, чем прямой push.

Набор push-пиров постоянно обновляется за счет смены на новый узел в набор каждые `PUSH_MSG_TIMEOUT/2` миллисекунд.

### Pull-сообщение

Узел посылает сообщение pull, чтобы спросить кластер, есть ли какая-нибудь новая информация. Сообщение pull отправляется случайным образом одному пиру и содержит фильтр Блума. Узел, получающий pull-сообщение, перебирает свои значения и формирует pull-ответ из того, что пропускает фильтр и помещается в сообщении.

Узел создает фильтр Блума pull, перебирая текущие значения и недавно очищенные значения.

Узел обрабатывает элементы в ответе pull так же, как он обрабатывает новые данные в push-сообщении.

## Purging

Узлы сохраняют предыдущие версии значений \(обновленные pull или push\) и просроченные значения \(которые старше `GOSSIP_PULL_CRDS_TIMEOUT_MS`\) в `purged_values` \(чем у меня были недавно\). Узлы очищают `purged_values`, которые старше, чем `5 * GOSSIP_PULL_CRDS_TIMEOUT_MS`.

## Атаки затмения

Атака затмения - это попытка захватить контроль над набором соединений узла.

Это имеет отношение к нашей реализации следующим образом.

- Pull-сообщения выбирают случайный узел в сети. Атака затмения на _pull_ потребует от злоумышленника повлиять на случайный выбор таким образом, чтобы для pull выбирались только враждебные узлы.
- Push-сообщения поддерживают активный набор узлов и выбирают случайное разветвление для каждого push-сообщения. Атака затмения на _push_ повлияет на выбор активного набора или случайный выбор разветвления.

### Веса на основе времени и стейка

Вес рассчитывается на основе `времени с момента последнего выбора` и `натурального логарифма` от `веса стейка`.

Взятие `ln` от веса стейка, дает всем узлам более справедливые шансы на покрытие сети в разумные сроки. Это помогает нормализовать большие возможные различия в `весе стейка` между узлами. Таким образом узел с низким `весом стейка` по сравнению с узлом с большим `весом стейка` должен будет ждать только несколько значений, кратных ln\(`стейка`\) секунд, прежде чем он будет выбран.

У злоумышленника нет возможности повлиять на эти параметры.

### Pull-сообщение

Узел выбирается в качестве pull-цели на основе весов, описанных выше.

### Push-сообщение

Сообщение об удалении может только удалить злоумышленника из потенциального соединения.

Точно так же как в _pull-сообщениях_, узлы выбираются в активный набор на основе весов.

## Заметные отличия от PlumTree

Активный push-протокол, описанный здесь, основан на [Plum Tree](https://haslab.uminho.pt/sites/default/files/jop/files/lpr07a.pdf). Основные различия заключаются в следующем:

- У push-сообщений есть часы, подписанные отправителем. По истечении срока действия часов сообщение сбрасывается. Ограничение переходов трудно реализовать в настройках злоумышленника.
- Lazy Push не реализован, потому что не очевидно, как предотвратить подделку отпечатка сообщения злоумышленником. Наивный подход позволил бы противнику получить приоритет для pull на основе его действий.
