---
title: Хранилище блоков Blockstore
---

После того, как блок станет необратимым, все блоки от него и до блока генезиса образуют линейную цепочку с привычным названием - блокчейн. До этого момента валидатор должен поддерживать все потенциально допустимые цепочки, называемые _форки_. Процесс, при котором форки естественным образом образуются в результате ротации лидера, описан в [генерации форков](../cluster/fork-generation.md). Описанная здесь структура данных хранилища блоков _blockstore_ — это то, как валидатор управляет этими форками до тех пор, пока блоки не будут финализированы.

Хранилище блоков позволяет валидатору записывать каждый кусочек, который он наблюдает в сети, в любом порядке, пока этот кусочек подписан ожидаемым лидером для данного слота.

Шреды перемещаются в пространство ключей -- кортеж значений `лидер слота` + `индекс шреда`(находящегося в слоте), где в дальнейшем может произойти форк. Это позволяет хранить структуру списка пропусков протокола Solana в полном объеме, без предварительного выбора за каким форком следовать, какие записи сохранять и когда их сохранять.

Запросы на исправление недавних кусочков выдаются из оперативной памяти или из более глубокого хранилища для менее свежих кусочков, как это реализовано хранилищем, поддерживающим хранилище блоков Blockstore.

## Функциональные возможности Blockstore

1. Постоянство: Blockstore находится перед конвейером

   проверки узлов, сразу за сетевым приемом и проверкой подписи. Если

   полученный кусочек соответствует расписанию лидера \(например, был подписан

   лидером для указанного слота\), он немедленно сохраняется.

2. Восстановление: ремонт такой же, как и ремонт окон, описанный выше, но может обслуживать

   любой полученный кусочек. Blockstore хранит кусочки с подписями,

   сохраняя цепочку происхождения.

3. Форки: Blockstore поддерживает произвольный доступ к кусочкам, поэтому может поддерживать

   потребность валидатора в откате и воспроизведении с контрольной точки банка.

4. Перезапуск: при правильной отсечке/отбраковке Blockstore может быть воспроизведено

   упорядоченным перечислением записей из слота 0. Логика этапа повтора

   \(т.е. в случае с форками\) должна быть использована для самых последних записей в

   Blockstore.

## Дизайн Blockstore

1. Записи в Blockstore хранятся в виде пар ключ-значение, где ключом является составной индекс слотов и индекс кусочков записи, а значение - это данные ввода. Обратите внимание, что шред индексы отсчитываются от нуля для каждого слота \(т.е. они относятся к слоту\).
2. Blockstore хранит метаданные для каждого слота в структуре `SlotMeta`, содержащей:

   - `slot_index` - индекс этого слота
   - `num_blocks` - Количество блоков в слоте \(используется для привязки к предыдущему слоту\)
   - `consumed` - Последний по высоте индекс шреда `n`, таким образом при условии `m < n`, в данном слоте всегда существует шред с индексом равным `n` \(или, наивысший последовательный индекс шреда\).
   - `received` - наивысший полученный индекс шреда для конкретного слота
   - `next_slot` - Список будущих слотов, к которым может присоединиться этот слот. Используется при перестройке

     реестра для поиска возможных точек форка.

   - `last_index` - Индекс шреда, отмеченный как последний шред для конкретного слота. Этот метка будет установлен на шреде лидером слота, когда будет передан последний шред слота.
   - `is_rooted` - True, если каждый блок от 0...формирует целостную последовательность без дыр. Мы можем получить is_rooted для каждого слота по следующим правилам. Пусть slot\(n\) будет слот с индексом `n`, и slot\(n\).is_full\(\) истинно, если слот с индексом `n` имеет все тики, ожидаемые для этого слота. Пусть is_rooted\(n\) является утверждением "slot\(n\).is_rooted истинно". Тогда:

     is_rooted\(0\) is_rooted\(n+1\) iff \(is_rooted\(n\) and slot\(n\).is_full\(\)

3. Объединение в цепь - Когда приходит шред для нового слота `x`, мы проверяем число блоков \(`num_blocks`\) для текущего слота \(эта информация кодируется в шреде\). Затем мы знаем, что этот новый слот связан со слотом `х - num_blocks`.
4. Подписка - Blockstore записывает набор слотов, на которые были "подписаны". Это означает, что записи, которые связаны с этими слотами, будут отправлены по каналу Blockstore для использования ReplayStage. Смотрите `Blockstore API` для подробностей.
5. Уведомления об обновлениях - Blockstore уведомляет слушателей, когда slot\(n\).is_rooted переключается из false в true для любого `n`.

## Blockstore APIs

Blockstore предлагает API на основе подписки, который ReplayStage использует для запроса интересующих его записей. Записи будут отправлены по каналу, указанному в Blockstore. Эти API подписки следующие: 1. `fn get_slots_since(slot_indexes: &[u64]) -> Vec<SlotMeta>`: Возвращает новые слоты, соединяющиеся с любым элементом списка `slot_indexes`.

1. `fn get_slot_entries(slot_index: u64, entry_start_index: usize, max_entries: Option<u64>) -> Vec<Entry>`: Возвращает вектор входа для слота начиная с `entry_start_index`, до значения `max` если `max_entries == Some(max)`, в противном случае, ограничения на длинну возвращаемого вектора не накладываются.

Примечание. В совокупности это означает, что этап воспроизведения теперь должен будет знать, когда слот закончен, и должен подписаться на следующий слот, в котором он заинтересован, чтобы получить следующий набор записей. Раньше бремя цепочки слотов ложилось на Blockstore.

## Взаимодействие с банком

Банк предлагает для стадии воспроизведения:

1. `prev_hash`: над какой цепочкой PoH он работает, как указано хешем последней

   обработанной записи

2. `tick_height`: тики в цепочке PoH, которые в настоящее время проверяются этим

   банком

3. `votes`: стек записей, содержащих: 1. `prev_hashes`: что-либо после этого голоса, что должно быть привязано к PoH 2. `tick_height`: высота тика, на котором был отдан конкретный голос 3. `lockout period`: как долго последовательсноть должна находиться в реестре, чтобы

   ее можно было связать под этим голосом

Этап воспроизведения использует API-интерфейсы Blockstore, чтобы найти самую длинную последовательность записей, которая может зависеть от предыдущего голосования. Если эта последовательность записей не зависит от последнего голосования, этап воспроизведения откатывает банк до этого голоса и воспроизводит последовательность оттуда.

## Очистка Blockstore

Когда записи в Blockstore становятся достаточно старыми, представление всех возможных форков становится менее полезным, возможно, даже проблематичным для повторного воспроизведения при перезапуске. Однако, как только количество голосов валидатора достигнет максимальной блокировки, любое содержимое Blockstore, которое не входит в цепочку PoH для этого голосования, может быть удалено.
