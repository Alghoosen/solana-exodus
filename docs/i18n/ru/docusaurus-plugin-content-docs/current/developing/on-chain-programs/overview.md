---
title: "Общий обзор"
---

Разработчики могут писать и развертывать свои собственные программы в блокчейн Solana.

Пример [Helloworld](examples.md#helloworld) - это отличный старт, который позволит увидеть как программа написана, создана, развернута и взаимодействует с цепями.

## Berkley Packet Filter (BPF)

On-chain программы Solana компилируются [инфраструктурой компилятора LLVM](https://llvm.org/) в формат [Executable and Linkable Format (ELF)](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) содержажий вариацию байткода [Berkley Packet Filter (BPF)](https://en.wikipedia.org/wiki/Berkeley_Packet_Filter).

Поскольку Solana использует инфраструктуру компилятора LLVM, программа может быть написана на любом языке программирования, способном взаимодействовать с BPF бэкэндом LLVM. Solana в настоящее время поддерживает написание программ в Rust and C/C++.

BPF предоставляет эффективный набор инструкций [ ](https://github.com/iovisor/bpf-docs/blob/master/eBPF.md), которые могут быть выполнены непосредственно в интерпретируемой виртуальной машине (EVM) или как нативный код JIT-компилятора.

## Карта памяти

Виртуальная карта адресов памяти, используемая программами Solana BPF, фиксирована и размещена следующим образом

- Код программы использует адреса с 0x100000000
- Данные стека используют адреса с 0x200000000
- Данные кучи используют адреса с 0x300000000
- Начальные параметры программы адресуются с 0x400000000

Вышеуказанные виртуальные адреса являются стартовыми адресами, а программам предоставляется доступ к соответствующим подмножествам адресов памяти. При операциях чтения/записи с виртуальным адресом, доступ к которому не был предоставлен программе, будет возвращена сообщение о ошибке `AccessViolation`, содержащее соответствующий адрес памяти и размер данных.

## Стек

BPF использует стековые кадры вместо переменной стекового указателя. Каждый стековый кадр имеет размер 4KB.

Если программа превысит казанный размер стекового фрейма, компилятор выдаст предупреждение.

For example: `Error: Function _ZN16curve25519_dalek7edwards21EdwardsBasepointTable6create17h178b3d2411f7f082E Stack offset of -30728 exceeded max offset of -4096 by 26632 bytes, please minimize large stack variables`

Сообщение указывает какой символ превышает максимальный размер стекового фрейма, но имя может быть декорировано, если это символ Rust или С++. Чтобы убрать декорирование в случае с Rust используйте инструмент [rustfilt](https://github.com/luser/rustfilt). Вышеуказанное предупреждение было сделано из Rust программы, так что имя символа без декорирования будет иметь следующий вид:

```bash
$ rustfilt _ZN16curve25519_dalek7edwards21EdwardsBasepointTable6create17h178b3d2411f7f082E
curve25519_dalek::edwards::EdwardsBasepointTable::create
```

Чтобы убрать декорирование символа C++ используйте `c++filt` из библиотеки binutils.

Причина, по которой компилятор выдает предупреждение, а не ошибку, заключается в том что функционал, превышающую лимит стекового фрейма, программа может не использовать. Например, он может содержаться в зависимостях программы. Если программа нарушает лимит размера стека во время работы, компилятор сообщит об ошибке `AccessViolation`.

Стековые фреймы BPF занимают виртуальный адресный диапазон памяти, начиная с 0x200000000.

## Глубина стека

Для ускорения запуска и облегчения работы программ, стек вызовов ограничивается максимальной глубиной 64 стековых фрейма.

## Куча

Программы имеют доступ к куче во время выполнения непосредственно в C или через `alloc` API в Rust. Для ускорения выделения памяти используется простая динамическая куча размером 32 Кб. Куча не поддерживает `free` или `realloc` поэтому используйте ее внимательно.

Внутри, программы имеют доступ к диапазону памяти размером в 32KB, начиная с виртуального адреса 0x300000000 и могут реализовывать кучу, основываясь на специфических потребностях.

- [Использование кучи в Rust](developing-rust.md#heap)
- [Использование кучи в C](developing-c.md#heap)

## Поддержка Операций с Плавающей Точкой

Programs support a limited subset of Rust's float operations, if a program attempts to use a float operation that is not supported, the runtime will report an unresolved symbol error.

Float operations are performed via software libraries, specifically LLVM's float builtins. Due to be software emulated they consume more compute units than integer operations. In general, fixed point operations are recommended where possible.

The Solana Program Library math tests will report the performance of some math operations: https://github.com/solana-labs/solana-program-library/tree/master/libraries/math

To run the test, sync the repo, and run:

`$ cargo test-bpf -- --nocapture --test-threads=1`

Recent results show the float operations take more instructions compared to integers equivalents. Fixed point implementations may vary but will also be less then the float equivalents:

```
         u64   f32
Multipy    8   176
Divide     9   219
```

## Статические записываемые данные

Общедоступные объекты в программе не поддерживают записываемые общие данные. Программы распределяются на несколько параллельных исполняемых экзеплярjd и используют один и тот же код и одни и те же данные, открытые только для чтения. Это означает, что разработчики не должны использовать глобальные или статические открытые для записи переменные. В будущем для поддержки записи данных возможно будет добавлен механизм копирования при записи.

## Деление чисел со знаком

Набор инструкций BPF не поддерживает операции [ деления чисел со знаком ](https://www.kernel.org/doc/html/latest/bpf/bpf_design_QA.html#q-why-there-is-no-bpf-sdiv-for-signed-divide-operation). Возможность добавления инструкций деления чисел со знаком рассматривается.

## Загрузчики

Программы разворачиваются и исполняются с помощью загрузчиков времени исполнения, в настоящее время существует два поддерживаемых загрузчика [BPF Загрузчик](https://github.com/solana-labs/solana/blob/7ddf10e602d2ed87a9e3737aa8c32f1db9f909d8/sdk/program/src/bpf_loader.rs#L17) и [ устаревший BPF загрузчик](https://github.com/solana-labs/solana/blob/7ddf10e602d2ed87a9e3737aa8c32f1db9f909d8/sdk/program/src/bpf_loader_deprecated.rs#L14)

Загрузчики могут поддерживать различные бинарные интерфейсы приложений, поэтому разработчики должны писать код и разворачивать программу их в один и тот же загрузчик. Если программа написана для одного загрузчика, а развернута в другой - то результат, как правило, вызовет ошибку `AccessViolation` из-за несовпадения десериализации входных параметров программы.

На практике программа должна всегда создаваться для наиболее актуальной версии BPF загрузчика, который по умолчанию используется для интерфейса командной строки и javascript API.

Для получения информации о реализации программ для загрузчика на конкретном языке программирования смотрите:

- [Точки входа для Rust](developing-rust.md#program-entrypoint)
- [Точки входа для C](developing-c.md#program-entrypoint)

### Развертывание

Развертывание программ BPF - это процесс загрузки общего объекта BPF в данные аккаунта программы и маркировка этого аккаунта программы как исполняемого. Клиент разделяет общий объект на несколько меньших частей и посылает их в загрузчик как данные инструкций [`Записи`](https://github.com/solana-labs/solana/blob/bc7133d7526a041d1aaee807b80922baa89b6f90/sdk/program/src/loader_instruction.rs#L13), а загрузчик пишет эти данные в данные аккаунта программы. Как только все части общего объекта получены, клиент отправит загрузчику инструкцию [`Финализировать`](https://github.com/solana-labs/solana/blob/bc7133d7526a041d1aaee807b80922baa89b6f90/sdk/program/src/loader_instruction.rs#L30), после чего загрузчик проверит валидность BPF данных и пометит аккаунт программы как _исполняемый_. После того, как аккаунт программы помечен как выполняемый, последующие транзакции могут вызывать инструкции данной программы для обработки.

Когда инструкция направлена на исполняемую программу BPF загрузчик конфигурирует ее исполняемое окружение, сериализует исходные параметры, вызывает точку входа программы и сообщает о любых возможных ошибках.

Дополнительную информацию см. в [развертывание](deploying.md)

### Сериализация Исходных Параметров

Загрузчики BPF сериализуют входные параметры программы в байтовый массив и затем передаются на точку входа программы, где программа отвечает за ее on-chain десериализацию. Одно из изменений между устаревшим загрузчиком и текущим загрузчиком заключается в том, что входные параметры сериализируются таким образом, чтобы различные параметры размещались в выровненном байтовом массиве с выравнивающим смещением. Это позволяет реализациям десериализации напрямую ссылаться на массив байт и обеспечивать выравнивание указателей на программу.

Для информации о сериализации для специфического языка см:

- [Десериализация параметров программы для Rust](developing-rust.md#parameter-deserialization)
- [Десериализация параметров программы для C](developing-c.md#parameter-deserialization)

Актуальный загрузчик сериализует входные параметры программы следующим образом (вся кодировка little endian):

- 8 байт неподписанное число колличество аккаунтов
- Для каждого аккаунта
  - 1 байт определяет является ли аккаунт дублирующим, если не дублирующий то значение будет 0xff, в противном случае значением будет индекс дублируемого аккаунта.
  - 7 байт отступа
    - если это не дублирующий аккаунт
      - 1 байт отступа
      - 1 байт булево значение, истина, если аккаунт подписывающий
      - 1 байт булево значение, истина, если аккаунт доступен для записи
      - 1 байт булево значение, истина, если аккаунт исполняемый
      - 4 байт отступа
      - 32 байта публичный ключ аккаунта
      - 32 байта публичный ключ владельца аккаунта
      - 8 байт неподписанного числа lamports, принадлежащих аккаунту
      - 8 байт неподписанные целое данные аккаунта
      - x байт данных аккаунта
      - 10k байт отступ, используется для realloc
      - x байт отступа, достаточно для выравнивания смещения до 8 байт.
      - 8 байт рента эпохи
- 8 байт неподписанного числа данных инструкции
- x байт данных инструкции
- 32 байта id программы
