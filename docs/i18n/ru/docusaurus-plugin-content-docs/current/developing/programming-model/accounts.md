---
title: "Аккаунты"
---

## Сохранение состояния между транзакциями

Если программе необходимо хранить состояние между транзакциями, она делает это с помощью _аккаунтов_. Аккаунты похожи на файлы в операционных системах, таких как Linux. Как и файл, аккаунт может содержать произвольные данные и что данные сохраняются сверх срока службы программы. Также как и файл, аккаунт включает в себя метаданные, которые говорит о том, кому разрешен доступ к данным и каким образом.

В отличие от файла, аккаунт содержит метаданные за время жизни файла. Это время жизни выражается в "токенах", который является рядом дробных родных токенов, называемых _лэмпортами_. Аккаунты хранятся в памяти валидатора и платят ["аренду"](#rent), чтобы остаться там. Каждый валидатор периодически сканирует все аккаунты и собирает аренду. Любой аккаунт, который падает на нулевые лэмпорты, очищается. Accounts can also be marked [rent-exempt](#rent-exemption) if they contain a sufficient number of lamports.

Так же как пользователь Linux использует путь для поиска файла, клиент Solana использует _адрес_ для поиска аккаунта. Адрес является 256-битным публичным ключом.

## Подписанты

Транзакции могут включать цифровые [подписи](terminology.md#signature) соответствующие публичным ключам аккаунтов, на которые ссылается транзакция. Когда соответствующая цифровая подпись присутствует, это означает, что владелец приватного ключа аккаунта подписал и таким образом "авторизовал" транзакцию, и в этом случае аккаунт аккаунт называется _подписантом_. Независимо от того, является ли аккаунт стороной или нет, передается программе в рамках метаданных аккаунта. Программы могут использовать эту информацию для принятия решений.

## Только для чтения

Транзакции могут [указывать](transactions.md#message-header-format) на то, что некоторые из аккаунтов, которые она ссылается, рассматриваются как _аккаунты только для чтения_ для того, чтобы включить параллельную обработку счетов между транзакциями. Среда выполнения разрешает только чтение аккаунта для одновременного чтения несколькими программами. Если программа пытается изменить аккаунт только для чтения, транзакция будет отклонена во время выполнения.

## Исполняемые

Если учетная запись помечена в метаданных как «исполняемая», она считается программой, которая может быть выполнена путем включения публичного ключа аккаунта инструкции [id программы ](transactions.md#program-id). Аккаунты отмечены как исполняемый файл во время успешного процесса развертывания программы загрузчиком, который владеет аккаунтом. Например, во время внедрения программы BPF, после того, как определит, что байт-код BPF в данных аккаунта верен, загрузчик навсегда помечает аккаунт программы исполняемым. После исполняемого файла среда выполнения обеспечивает неизменность данных аккаунта (программы).

## Создание

Чтобы создать аккаунт клиент генерирует _ключевые пары_ и регистрирует свой публичный ключ с помощью инструкции `SystemProgram::CreateAccount` с предустановленным размер хранилища в байтах. Максимальный размер данных аккаунта составляет 10 мегабайт.

Адрес аккаунта может быть любым произвольным 256 битным значением, и существуют механизмы для создания опытными пользователями полученных адресов (`SystemProgram::CreateAccountWithSeed`, [`Pubkey::CreateProgramAddress`](calling-between-programs.md#program-derived-addresses)).

Аккаунты, которые никогда не были созданы через системную программу, также могут быть переданы программам. Когда инструкция ссылается на аккаунт, который не был ранее создан, программе будет передан аккаунт, принадлежащий системной программе нулевые лэмпарты и нулевые данные. Но аккаунт будет отражаться независимо от того, подписывает ли он транзакцию или нет и, следовательно, может использоваться в качестве полномочий. Авторы в этом контексте передают программе, что владелец приватного ключа, связанного с публичным ключом аккаунта, подписал транзакцию. Публичный ключ аккаунта может быть известен программе или записан в другой аккаунт и обозначать какое-либо право собственности на актив или операцию управления или выполнения программы.

## Владение программами и их распределение

Создаваемый аккаунт инициализирован для _владения_ встроенной программой под названием Системная программа и называется _системным аккаунтом_ соответственно. Аккаунт включает в себя метаданных "владельца". Владелец - это идентификатор программы. Время выполнения предоставляет программе доступ на запись аккаунта, если ее идентификатор соответствует владельцу. В случае системной программы среда выполнения позволяет клиентам передавать лэмпорты и, что важно, _назначать_ владельца аккаунта, что означает смену владельца на другой id программы. Если аккаунт не принадлежит программе, программе разрешено только читать ее данные и пополнить счет.

## Verifying validity of unmodified, reference-only accounts

For security purposes, it is recommended that programs check the validity of any account it reads but does not modify.

The security model enforces that an account's data can only be modified by the account's `Owner` program. Doing so allows the program to trust that the data passed to them via accounts they own will be in a known and valid state. The runtime enforces this by rejecting any transaction containing a program that attempts to write to an account it does not own. But, there are also cases where a program may merely read an account they think they own and assume the data has only been written by themselves and thus is valid. But anyone can issues instructions to a program, and the runtime does not know that those accounts are expected to be owned by the program. Therefore a malicious user could create accounts with arbitrary data and then pass these accounts to the program in the place of a valid account. The arbitrary data could be crafted in a way that leads to unexpected or harmful program behavior.

To check an account's validity, the program should either check the account's address against a known value or check that the account is indeed owned correctly (usually owned by the program itself).

One example is when programs read a sysvar. Unless the program checks the address or owner, it's impossible to be sure whether it's a real and valid sysvar merely by successful deserialization. Accordingly, the Solana SDK [checks the sysvar's validity during deserialization](https://github.com/solana-labs/solana/blob/a95675a7ce1651f7b59443eb146b356bc4b3f374/sdk/program/src/sysvar/mod.rs#L65).

If the program always modifies the account in question, the address/owner check isn't required because modifying an unowned (could be the malicious account with the wrong owner) will be rejected by the runtime, and the containing transaction will be thrown out.

## Аренда

Поддержание аккаунтов в Solana требует затрат на хранение, называемых _арендной платой _, потому что кластер должен активно поддерживать данные для обработки любых будущих транзакций для него. Это отличается от Bitcoin и Ethereum, где хранение аккаунтов не влечет за собой никаких затрат.

Арендная плата списывается с баланса аккаунта средой выполнения при первом доступе (включая первоначальное создание аккаунта) в текущую эпоху по транзакций или один раз за эпоху, если транзакций нет. Комиссия составляет в настоящее время фиксированную ставку, измеряемую в bytes-times-epochs. Комиссия может измениться в будущем.

Для упрощения расчета арендной платы арендная плата всегда взимается за одну полную эпоху. Арендная плата не рассчитывается пропорционально, что означает, что за отдельные эпохи не взимается ни сборов, ни возмещения. Это означает, что при создании аккаунта первая плата, собранная не за текущую частичную эпоху, а собирается заранее для следующей полной эпохи. Последующие сборы аренды относятся к будущим эпохам. С другой стороны, если баланс счета, на котором уже собрана аренда, упадет ниже другой арендной платы в середине эпохи, счет будет продолжать существовать в течение текущей эпохи и будет очищен немедленно в начале предстоящей эпохи.

Аккаунты могут освобождаться от уплаты аренды, если они сохраняют минимальный баланс. Это освобождение от арендной платы описано ниже.

### Расчёт аренды

Примечание: Цена аренды может измениться в будущем.

На момент написания фиксированная арендная плата составляла 19,055441478439427 лэмпорт за байт-эпоху в кластерах тестовой сети и бета-версии основной сети. [Эпоха](terminology.md#epoch) планируется на 2 дня (для devnet арендная плата составляет 0,3608183131797095 лэмпортов на байт-эпоху с продолжительностью 54 м 36 с).

Это значение рассчитано для целевого 0,01 SOL на mebibyte-day (точно соответствует 3,56 SOL на mebibyte-year):

```text
Rent fee: 19.055441478439427 = 10_000_000 (0.01 SOL) * 365(approx. day in a year) / (1024 * 1024)(1 MiB) / (365.25/2)(epochs in 1 year)
```

И расчет арендной платы производится с точностью `f64`, а конечный результат усекается `u64` в лэмпорте.

Расчет арендной платы включает метаданные аккаунта (адрес, владелец, лэмпорты и т. д.) в размере аккаунта. Таким образом, минимальный размер аккаунта для расчетов аренды составляет 128 байтов.

Например, аккаунт создается с первоначальной передачей 10 000 лэмпорт и без дополнительных данных. С него сразу же списывается аренда при создании, в результате получается баланс в 7561 лэмпорт:

```text
Rent: 2,439 = 19.055441478439427 (rent rate) * 128 bytes (minimum account size) * 1 (epoch)
Account Balance: 7,561 = 10,000 (transfered lamports) - 2,439 (this account's rent fee for an epoch)
```

Баланс аккаунта будет уменьшен до 5122 лэмпортов в следующую эпоху, даже если нет активности:

```text
Account Balance: 5,122 = 7,561 (current balance) - 2,439 (this account's rent fee for an epoch)
```

Соответственно, аккаунт минимального размера будет немедленно удален после создания, если количество перенесенных лэмпортов меньше или равно 2439.

### Освобождение от арендной платы

В качестве альтернативы аккаунт может быть полностью освобожден от взимания арендной платы путем внесение арендной платы не менее чем за 2 года. Это проверяется каждый раз, когда баланс счета уменьшается, и арендная плата немедленно списывается, как только баланс становится ниже минимальной суммы.

Среда выполнения требует, чтобы аккаунты исполняемых программ не облагались арендой, чтобы избежать очистки.

Примечание: Используйте [`getMinimumBalanceForRentExemption` RPC конечную точку](developing/clients/jsonrpc-api.md#getminimumbalanceforrentexemption) для вычисления минимального баланса для конкретного размера счета. Следующий расчет носит исключительно иллюстративный характер.

Например, программа, размер которой составляет 15000 байт, требует баланса 105,290,880 лэмпорт(=~ 0.105 SOL), чтобы быть освобождённой от аренды:

```text
105,290,880 = 19.055441478439427 (fee rate) * (128 + 15_000)(account size including metadata) * ((365.25/2) * 2)(epochs in 2 years)
```

Rent can also be estimated via the [`solana rent` CLI subcommand](cli/usage.md#solana-rent)

```text
$ solana rent 15000
Rent per byte-year: 0.00000348 SOL
Rent per epoch: 0.000288276 SOL
Rent-exempt minimum: 0.10529088 SOL
```

Note: Rest assured that, should the storage rent rate need to be increased at some point in the future, steps will be taken to ensure that accounts that are rent-exempt before the increase will remain rent-exempt afterwards
