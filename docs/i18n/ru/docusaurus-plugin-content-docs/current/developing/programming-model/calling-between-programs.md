---
title: Вызовы между программами
---

## Межпрограммные вызовы

Среда выполнения Solana позволяет программам обращаться друг к другу через механизм межпрограммных вызовов.  Межпрограммные вызовы возникают тогда, когда одна программа вызывает инструкции другой программы.  Вызывающая программа приостанавливается до тех пор, пока вызываемая программа не закончит обработку инструкции.

Например, клиент может создать транзакцию, изменяющую два аккаунта, каждый из которых принадлежит отдельной on-chain программе:

```rust,ignore
let message = Message::new(vec![
    token_instruction::pay(&alice_pubkey),
    acme_instruction::launch_missiles(&bob_pubkey),
]);
client.send_and_confirm_message(&[&alice_keypair, &bob_keypair], &message);
```

Вместо этого клиент может разрешить программе `acme` вызывать инструкции программы `token` от своего имени:

```rust,ignore
let message = Message::new(vec![
    acme_instruction::pay_and_launch_missiles(&alice_pubkey, &bob_pubkey),
]);
client.send_and_confirm_message(&[&alice_keypair, &bob_keypair], &message);
```

Возьмем для примера две on-chain программы `token` и `acme`, содержащие инструкции `pay()` и `launch_missiles()` соответственно. В этом случае модуль acme может вызвать функцию, определенную в модуле `token`, через механизм межпрограммных вызовов:

```rust,ignore
mod acme {
    use token_instruction;

    fn launch_missiles(accounts: &[AccountInfo]) -> Result<()> {
        ...
    }

    fn pay_and_launch_missiles(accounts: &[AccountInfo]) -> Result<()> {
        let alice_pubkey = accounts[1].key;
        let instruction = token_instruction::pay(&alice_pubkey);
        invoke(&instruction, accounts)?;

        launch_missiles(accounts)?;
    }
```

Метод `invoke()` встроен в среду выполнения Solana и отвечает за передачу указанной инструкции модулю `token` на основе содержащегося в ней поля `program_id`.

Обратите внимание, что при вызове метода `invoke` вызывающая программа должна передать все аккаунты, требуемые для вызываемой инструкции.  Это означает, что в процессор команд передаются как аккаунты, так и исполняемый аккаунт (соответствующий идентификатору program_id, содержащемуся в инструкции).

Перед вызовом метода `pay()` среда выполнения должна проверить, что модуль `acme` не изменил никакие аккаунты, принадлежащие модулю `token`. Это обеспечивается путем применения политики среды выполнения к текущему состоянию аккаунтов в момент вызова метода `invoke` модулем `acme`, которая сравнивает его с состоянием аккаунтов перед началом выполнения инструкции модуля `acme`. После выполнения метода `pay()` среда выполнения снова должна проверить, что модуль `token` не изменил никакие аккаунты, принадлежащие модулю `acme`, снова применяя политику, но уже к идентификатору программы `token`. Наконец, после выполнения метода `pay_and_launch_missiles()` политика применяется еще раз там, где она должна применяться, но при этом используются уже обновленные переменные `pre_*`. Если выполнение цепочки методов от `pay_and_launch_missiles()` до `pay()`, выполнение метода `pay()` и выполнение цепочки методов от `pay()` до возвращения результатов методом `pay_and_launch_missiles()` не привели к некорректным изменениям аккаунтов, то среда выполнения считает, что метод `pay_and_launch_missiles()` в целом не сделал никаких некорректных изменений, и фиксирует все изменения аккаунтов.

### Инструкции, требующие привилегий

Среда выполнения выдает привилегии вызывающим программам для определения того, какие из этих привилегий можно применить к вызываемым программам. В этом контексте привилегии связаны с аккаунтами подписантов и доступными для записи (writable) аккаунтами. Например, если вызывающая программа выполняет инструкцию, содержащую аккаунт подписанта или доступный для записи аккаунт, то эта программа может вызывать инструкцию, которая также содержит аккаунт подписанта и/или доступный для записи аккаунт.

Это расширение привилегий основывается на том, что программы неизменяемы. В примере с программой `acme` среда выполнения может безопасно считать подпись транзакции подписью инструкции программы `token`. Когда среда выполнения встречает инструкцию модуля `token`, ссылающуюся на ключ `alice_pubkey`, она ищет этот ключ в инструкции модуля `acme` для проверки того, что этот ключ соответствует подписанному аккаунту. В нашем случае ключ будет найден, и поэтому программе `token` будет разрешено модифицировать аккаунт Alice.

### Аккаунты, подписанные программами

Программы могут выполнять инструкции с подписанными аккаунтами, которые не были подписаны в исходной транзакции при помощи [получаемых от программ адресов](#program-derived-addresses).

Программа может подписать аккаунт полученными от нее адресами при помощи метода `invoke_signed()`.

```rust,ignore
        invoke_signed(
            &instruction,
            accounts,
            &[&["First addresses seed"],
              &["Second addresses first seed", "Second addresses second seed"]],
        )?;
```

### Глубина вызовов

Межпрограммные вызовы позволяют программам напрямую вызывать другие программы с определенной глубиной. В настоящее время эта глубина ограничена до 4 вызовов.

### Реентерабельность

В настоящее время реентерабельность ограничена прямой само-рекурсией фиксированной глубины. Существующие ограничения предотвращают ситуации, в которых программа может вызывать другую программу из промежуточного состояния, не зная о том, что она может быть вызвана позже снова. Прямая рекурсия предоставляет программе полный контроль над своим состоянием в точке, в которой она вызывается обратно.

## Получаемые от программ адреса

Получаемые от программ адреса позволяют использовать программно сгенерированные подписи при [межпрограммных вызовах](#cross-program-invocations).

Используя полученный от программы адрес, программа может получить полномочия на аккаунт, а затем передать их другой программе. Это возможно, поскольку программа может выступать в роли подписанта транзакции, предоставляющей полномочия.

Например, если два пользователя хотят сделать ставку на результат игры в Solana, каждый из них должен перевести свой взнос посреднику, который будет соблюдать заключенное соглашение. В настоящее время в Solana невозможно реализовать такую программу-посредника, поскольку она не может передавать активы победителям.

Эти возможности необходимы многим приложениям, работающим с децентрализованными финансами, поскольку они должны направлять средства депозитным агентам до наступления определенного события, определяющего нового владельца.

- Децентрализованные биржи, которые переводят активы между выигравшими ставками и запрашивают ордеры.

- Аукционы, которые переводят активы победителям.

- Игры или рынки предсказаний, которые собирают и перераспределяют призы победителям.

Получаемые от программ адреса:

1. Позволяют программам контролировать специальные адреса, которые называются программными адресами, таким образом, чтобы никакой внешний пользователь не мог генерировать валидные транзакции с подписями для этих адресов.

2. Позволяют программно подписывать программные адреса, содержащиеся в инструкциях, вызываемых через механизм [межпрограммных вызовов](#cross-program-invocations).

Принимая во внимание эти два условия, пользователи могут безопасно переводить on-chain активы и передавать полномочия на программные адреса, а программы могут впоследствии назначать владельцев по своему усмотрению.

### Закрытые ключи для программных адресов

Программный адрес не лежит на кривой ed25519, и поэтому не имеет связанного закрытого ключа. Как следствие, для него невозможно сгенерировать подпись.  Поскольку он не имеет собственного закрытого ключа, программы могут использовать его для выполнения инструкций, включающих в себя программный адрес в качестве подписанта.

### Программные адреса, генерируемые на основе хэша

Программные адреса детерминированно генерируются на основе набора seed-чисел и идентификатора программы с использованием 256-битной устойчивой к прообразу хэш-функции.  Программный адрес не должен лежать на кривой ed25519, чтобы гарантировать отсутствие связанного закрытого ключа. Если во время генерации адреса обнаружится, что он лежит на кривой, будет возвращена ошибка.  Вероятность, что это произойдет для заданного набора seed-чисел и идентификатора программы составляет 50%.  Если это произойдет, то для нахождения валидного программного адреса, не лежащего на кривой, будет использован другой набор seed-чисел или же в этот набор будет добавлено дополнительное 8-битное seed-число.

Детерминированные программные адреса для программ следуют той же цепочке происхождения, что и аккаунты, созданные с помощью вызова `SystemInstruction::CreateAccountWithSeed` реализованного в `system_instruction::create_address_with_seed`.

Данная реализация выглядит следующим образом:

```rust,ignore
pub fn create_address_with_seed(
    base: &Pubkey,
    seed: &str,
    program_id: &Pubkey,
) -> Result<Pubkey, SystemError> {
    if seed.len() > MAX_ADDRESS_SEED_LEN {
        return Err(SystemError::MaxSeedLengthExceeded);
    }

    Ok(Pubkey::new(
        hashv(&[base.as_ref(), seed.as_ref(), program_id.as_ref()]).as_ref(),
    ))
}
```

Программы могут детерминированно создавать любое количество адресов с использованием seed-чисел. Эти seed-числа могут символически определять, как используются адреса.

From `Pubkey`::

```rust,ignore
/// Генерация программного адреса
///     * seeds, символические ключевые слова, используемые для создания ключа
///     * program_id, идентификатор программы, для которой создается адрес
pub fn create_program_address(
    seeds: &[&[u8]],
    program_id: &Pubkey,
) -> Result<Pubkey, PubkeyError>
```

### Использование программных адресов

Для генерации адреса назначения клиенты могут использовать функцию `create_program_address`.

```rust,ignore
// детерминированное создание ключа депозита
let escrow_pubkey = create_program_address(&[&["escrow"]], &escrow_program_id);

// создание сообщения передачи с использованием этого ключа
let message = Message::new(vec![
    token_instruction::transfer(&alice_pubkey, &escrow_pubkey, 1),
]);

// запуск сообщения, выполняющего перевод 1 токена на депозит
client.send_and_confirm_message(&[&alice_keypair], &message);
```

Программы могут использовать ту же функцию для создания того же адреса. В функции, которая приведена ниже, программа генерирует метод `token_instruction::transfer` из программного адреса, как будто у нее есть закрытый ключ для подписи транзакции.

```rust,ignore
fn transfer_one_token_from_escrow(
    program_id: &Pubkey,
    keyed_accounts: &[KeyedAccount]
) -> Result<()> {

    // Пользователь указывает назначение
    let alice_pubkey = keyed_accounts[1].unsigned_key();

    // Детерминированное создание ключа депозита.
    let escrow_pubkey = create_program_address(&[&["escrow"]], program_id);

    // Создание инструкции передачи
    let instruction = token_instruction::transfer(&escrow_pubkey, &alice_pubkey, 1);

    // Среда выполнения создает детерминированный ключ из идентификатора
    // выполняющейся программы и указанных ключевых слов.
    // Если созданный адрес совпадает с ключом, отмеченным в инструкции как подписанный,
    // то этот ключ принимается как подписанный.
    invoke_signed(&instruction,  &[&["escrow"]])?
}
```

### Инструкции, требующие подписантов

Адреса, сгенерированные с помощью `create_program_address`, неотличимы от любого другого публичного ключа. Единственный способ, с помощью которого среда выполнения может убедиться в том, что адрес принадлежит программе - это запросить у программы seed-числа, использовавшиеся для генерации адреса.

Среда выполнения делает внутренний вызов `create_program_address` и сравнивает результат с адресом, содержащимся в инструкции.

## Примеры

Примеры использования межпрограммных вызовов вы можете найти в разделах [Разработка на Rust](developing/deployed-programs/../../../deployed-programs/developing-rust.md#examples) и [Разработка на C](developing/deployed-programs/../../../deployed-programs/developing-c.md#examples).
