---
title: المدفوعات البسيطة والتحقق من الحالة (Simple Payment and State Verification)
---

غالبًا ما يكون من المُفيد السماح للعملاء ذوي الموارد المُنخفضة بالمُشاركة في مجموعة Solana. سواء كانت هذه المُشاركة إقتصادية أو تنفيذ العقد، فإن التحقق من أن نشاط العميل قد تم قبوله من قبل الشبكة يكون مُكلفًا في العادة. يضع هذا الإقتراح آلية لهؤلاء العملاء لتأكيد أن أفعالهم قد تم الإلتزام بها في حالة دفتر الأستاذ (ledger) مع الحد الأدنى من نفقات الموارد وثقة الطرف الثالث.

## نهج ساذج (A Naive Approach)

يقوم المُدقّقون (validators) بتخزين تواقيع المُعاملات التي تم تأكيدها مُؤخرًا لفترة قصيرة من الوقت لضمان عدم مُعالجتها أكثر من مرة. يُوفر المُدقّقون (validators) نقطة نهاية JSON RPC، والتي يُمكن للعملاء إستخدامها للإستعلام عن نظام المجموعة إذا تمت مُعالجة إحدى المُعاملات مؤخرًا. يُوفر المُدقّقون (validators) أيضًا إشعارًا لـ PubSub، حيث سجل العميل ليتم إخطاره عند مُلاحظة توقيع مُعين بواسطة المُدقّق (validator). بينما تسمح هاتان الآليتان للعميل بالتحقق من الدفع، إلا أنهما ليسا دليلًا ويعتمدان على الثقة الكاملة في المُدقّق (validator).

سنصف طريقة لتقليل هذه الثقة إلى الحد الأدنى بإستخدام Merkle إثباتات لترسيخ إستجابة المُدقّق (validator) في دفتر الأستاذ (ledger)، مما يسمح للعميل بأن يُؤكد بنفسه أن عددًا كافيًا من المُدقّقين (validators) المُفضلين لديهم قد أكدوا المُعاملة. يُؤدي طلب شهادات المُدقّق (validator) المُتعددة إلى تقليل الثقة في المُدقّق بشكل أكبر، لأنه يزيد من الصعوبة التقنية والإقتصادية في المُساومة على العديد من المُشاركين الآخرين في الشبكة.

## العملاء الخفيفون (Light Clients)

"العميل الخفيف" (light client) هو أحد المُشاركين في نظام المجموعة (cluster) الذي لا يقوم بنفسه بتشغيل مُدقّق (validator). سيُوفر هذا العميل الخفيف (light client) مُستوى من الأمان أكبر من الوثوق بمُدقّق (validator) عن بُعد، دون مُطالبة العميل الخفيف (light client) بإنفاق الكثير من الموارد للتحقق من دفتر الأستاذ (ledger).

بدلاً من تقديم توقيعات المُعاملات مُباشرة إلى عميل خفيف (light client)، يقوم المُدقّق (validator) بدلاً من ذلك بإنشاء إثبات Merkle من المُعاملة ذات الأهمية إلى شجرة Merkle لجميع المُعاملات في الكتلة (block) المعنية. يتم تخزين ThisbMerkle Root في مُدخل (entry) دفتر الأستاذ (ledger) الذي يتم التصويت عليه من قبل المُدقّقين (validators)، مما يُوفر شرعية إجماع (consensus) عليها. يعتمد المُستوى الإضافي من الأمان للعميل الخفيف (light client) على مجموعة أولية أساسية من المُدقّقين (validators) الذين يعتبرهم العميل الخفيف (light client) أصحاب المصلحة في المجموعة (cluster). عند تغيير هذه المجموعة، يُمكن للعميل تحديث مجموعته الداخلية من المُدقّقين (validators) المعروفين بالإيصالات [receipts](simple-payment-and-state-verification.md#receipts). قد يصبح هذا صعبًا مع وجود عدد كبير من الحِصَص المُفوضة (delegated stakes).

قد يرغب المُدقّقون (validators) أنفسهم في إستخدام واجهات برمجة تطبيقات (API) العميل الخفيف (light client) لأسباب تتعلق بالأداء. على سبيل المثال، أثناء الإطلاق الأولي للمُدقّق (validator)، قد يستخدم المُدقّق نقطة تفتيش مُتفرعة من الحالة وتتحقق منها بإيصال.

## الإيصالات (Receipts)

الإيصال (receipt) هو الدليل الأدنى على ذلك؛ تم تضمين مُعاملة في كتلة (block)، الكتلة (block) التي تم التصويت عليها من قبل مجموعة المُدقّقين (validators) المُفضلين لدى العميل (client) وأن الأصوات قد وصلت إلى عمق التأكيد المطلوب.

### إثبات إدراج المُعاملة (Transaction Inclusion Proof)

إثبات إدراج المُعاملة (Transaction Inclusion Proof) هو بنية بيانات تحتوي على مسار Merkle من مُعاملة، من خلال Entry-Merkle إلى Block-Merkle، والذي يتم تضمينه في تجزئة البنك (Bank-Hash) مع المجموعة المطلوبة من أصوات المُدقّقين (validators). سلسلة مُدخلات (entries) الـ PoH التي تحتوي على أصوات المُدقّقين (validators) اللاحقة، المُستمدة من تجزئة البنك (Bank-Hash)، هي دليل التأكيد.

#### مُعاملة Merkle أو Transaction Merkle

إن Entry-Merkle هو Merkle Root بما في ذلك جميع المُعاملات في مُدخل (entry) مُعين، مُرتبة حسب التوقيع. تم دمج كل مُعاملة في المُدخل (entry) بالفعل هنا: https://github.com/solana-labs/solana/blob/b6bfed64cb159ee67bb6bdbaefc7f833bbed3563/ledger/src/entry.rs#L205. هذا يعني أنه يُمكننا إظهار مُعاملة تم تضمين `T` في المُدخل `E`.

الـ Block-Merkle هو Merkle Root لجميع Entry-Merkles المُتسلسلة في الكتلة (block).

![كتلة مُخطط Merkle أو Block Merkle Diagram](/img/spv-block-merkle.svg)

تُظهر الإثباتان معًا أن المُعاملة `T`قد تم تضمينها في كتلة (block) مع تجزئة البنك (Bank Hash) الخاصة بـ `B`.

تجزئة الحسابات (Accounts-Hash) هي تجزئة تسلسل تجزئات الحالة لكل حساب تم تعديله أثناء الفُتحة (Slot) الحالية.

تُعتبر حالة المُعاملة ضرورية للإيصال نظرًا لإنشاء إيصال الحالة للكتلة (block). يُمكن أن تظهر مُعاملتان على نفس الحالة في الكتلة (block)، وبالتالي، لا توجد طريقة للإستدلال من الحالة فقط على ما إذا كانت المُعاملة المُلتزمة بدفتر الأستاذ (ledger) قد نجحت أو فشلت في تعديل الحالة المقصودة. قد لا يكون من الضروري ترميز كود الحالة بالكامل، ولكن من الضروري ترميز حالة bit واحدة للإشارة إلى نجاح المُعاملة.

حاليًا، لم يتم تنفيذ Block-Merkle، لذا للتحقق من أن `E` كان مُدخلًا (entry) في الكتلة (block) مع تجزئة البنك (bank hash) الخاصة بـ `B`، سنحتاج إلى توفير جميع تجزئات (hashes) المُدخل (entry) في الكتلة (block). من الناحية المثالية، سيتم تنفيذ Block-Merkle، لأن البديل غير فعال للغاية.

#### رؤوس الكتلة (block headers)

من أجل التحقق من إثباتات تضمين المُعاملات، يحتاج العملاء الخفيفون (light clients) إلى أن يكونوا قادرين على إستنتاج هيكل الإنقسامات أو الشوكات (forks) في الشبكة

بشكل أكثر تحديدًا، سيحتاج العميل الخفيف (light client) إلى تتبع رؤوس الكتل (block headers) الواردة بحيث يُمكن لتجزئات البنك (Bank Hashes) للكتل (blocks) الخاصة بـ `A` و `B`، تحديد ما إذا كان `A` سلف مُشترك (ancestor) لـ `B` (القسم أدناه في إثبات التأكيد المُتفائل `Optimistic Confirmation Proof` يشرح السبب!). محتويات الرأس (header) هي الحقول اللازمة لحساب تجزئة البنك (bank hash).

تجزئة البنك (Bank-Hash) هي تجزئة سلسلة Block-Merkle وتجزئة الحسابات (Accounts-Hash) المُوضحة في قسم `Transaction Merkle` أعلاه.

![مُخطط تجزئة البنك (Bank Hash Diagram)](/img/spv-bank-hash.svg)

في التعليمة البرمجية:

https://github.com/solana-labs/solana/blob/b6bfed64cb159ee67bb6bdbaefc7f833bbed3563/runtime/src/bank.rs#L3468-L3473

```
        let mut hash = hashv(&[
            // bank hash of the parent block
            self.parent_hash.as_ref(),
            // hash of all the modifed accounts
            accounts_delta_hash.hash.as_ref(),
            // Number of signatures processed in this block
            &signature_count_buf,
            // Last PoH hash in this block
            self.last_blockhash().as_ref(),
        ]);
```

مكان جيد لتنفيذ هذا المنطق على طول منطق التدفق الحالي في منطق إعادة التشغيل للمُدقّق: https://github.com/solana-labs/solana/blob/b6bfed64cb159ee67bb6bdbaefc7f833bbed3563/core/src/replay_stage.rs#L1092-L1096

#### إثبات التأكيد المُتفائل (Optimistic Confirmation Proof)

تم الكشف حاليًا عن تأكيد مُتفائل (Optimistic Confirmation) من خلال المُستمع (listener) الذي يُراقب القيل والقال (gossip) وخط أنابيب (pipeline) الإعادة للأصوات: https://github.com/solana-labs/solana/blob/b6bfed64cb159ee67bb6bdbaefc7f833bbed3563/core/src/cluster_info_vote_listener.rs#L604-L614.

كل تصويت عبارة عن مُعاملة مُوقعة تتضمن تجزئة البنك(bank hash) للكتلة (block) التي صوت المُدقّق (validator) عليها، أي `B` من قسم `Transaction Merkle` أعلاه. بمجرد تصويت عتبة مُعينة `T` من الشبكة على كتلة (block)، يتم إعتبار الكتلة مُؤكدة بشكل مُتفائل. هناك حاجة إلى الأصوات التي تم إجراؤها بواسطة هذه المجموعة المُكونة من `T` مُدقّق لإظهار الكتلة (block) بإستخدام تجزئة بنك `B` تم تأكيدها بتفاؤل.

مع ذلك، بخلاف بعض البيانات الوصفية (metadata)، فإن الأصوات المُوقعة نفسها لا يتم تخزينها حاليًا في أي مكان، لذا لا يُمكن إسترجاعها عند الطلب. ربما تحتاج هذه الأصوات إلى الإستمرار في قاعدة بيانات Rocksdb، المُفهرسة بواسطة مفتاح `(Slot, Hash, Pubkey)` الذي يُمثل فُتحة (slot) التصويت، وتجزئة البنك (bank hash) للتصويت، والمفتاح العمومي (pubkey) لحساب التصويت المسؤول عن التصويت.

معًا، يُمكن تقديم دليل المُعاملة وإثباتات التأكيد المُتفائل (optimistic confirmation proofs) عبر RPC للمُشتركين من خلال توسيع منطق الإشتراك الحالي للتوقيع. Clients who subscribe to the "Confirmed" confirmation level are already notified when optimistic confirmation is detected, a flag can be provided to signal the two proofs above should also be returned.

من المهم أن نُلاحظ أن التأكيد المُتفائل لـ `B` يعني أيضًا أن جميع كتل (blocks) السلف المُشترك من `B` تم تأكيدها أيضًا بشكل مُتفائل، وأيضًا أنه لن يتم تأكيد جميع الكتل (blocks) بشكل مُتفائل.

```

B -> B'

```

لذلك في المثال أعلاه، إذا تم تأكيد الكتلة `B'` على النحو الأمثل، فسيكون كذلك لـ `B`. بالتالي، إذا كانت المُعاملة في الكتلة `B`، فستكون مُعاملة merkle في الإثبات للكتلة `B`، لكن الأصوات المُقدمة في الإثبات ستكون للكتلة `B'`. هذا هو سبب أهمية الرؤوس (headers) في قسم رؤوس الكتلة `Block headers` أعلاه، سيحتاج العميل إلى التحقق من أن `B` هو بالفعل سلف مُشترك (ancestor) لـ `B'`.

#### إثبات توزيع الحِصَّة (Proof of Stake Distribution)

بمجرد تقديم مُعاملة merkle وإثباتات التأكيد المُتفائل (Optimistic Confirmation Proofs) أعلاه، يُمكن للعميل التحقق من أن المُعاملة `T` تم تأكيدها بتفاؤل في كتلة (block) بها تجزئة البنك `B`. آخر قطعة مفقودة هي كيفية التحقق من أن الأصوات في الإثباتات المُتفائلة أعلاه تشكل في الواقع النسبة الصحيحة `T` من الحِصَّة الضرورية لدعم ضمانات السلامة "للتأكيد المتفائل" (optimistic confirmation).

قد تكون إحدى الطرق للتعامل مع هذا هو أن تقوم كل فترة (epoch)، عندما تتغير مجموعة الحِصَّة (stake)، بكتابة جميع الحِصص (stakes) إلى حساب النظام، ثم جعل المُدقّقين (validators) يشتركون في حساب النظام هذا. يُمكن أن تُوفر العُقد (nodes) الكاملة بعد ذلك Merkle يُثبت أن حالة حساب النظام قد تم تحديثها في كتلة `B`، ثم تُظهر أن الكتلة `B` قد تم تأكيدها / تجذيرها بشكل مُتفائل.

### التحقق من حالة الحساب (Account State Verification)

يُمكن التحقق من حالة الحساب (الرصيد أو البيانات الأخرى) عن طريق إرسال مُعاملة مع توجيه تعليمات **_TBD_** إلى المجموعة (cluster). يُمكن للعميل بعد ذلك إستخدام إثبات إدراج المُعاملة [Transaction Inclusion Proof](#transaction-inclusion-proof) للتحقق مما إذا كانت المجموعة (cluster) تُوافق على أن الحساب قد وصل إلى الحالة المُتوقعة.

### أصوات المُدقّق (Validator Votes)

يجب على القادة (Leaders) دمج أصوات المُدقّقين (validators) حسب وزن الحِصَّة (stake) في مُدخل (entry) واحد. سيُؤدي هذا إلى تقليل عدد المُدخلات (entries) اللازمة لإنشاء إيصال (receipt).

### سلسلة المُدخلات (Chain of Entries)

يحتوي الإيصال (receipt) على رابط PoH من جذر Merkle Path للدفع أو الحالة إلى قائمة أصوات المُصادقة المُتتالية (consecutive validation votes).

يحتوي على ما يلي:

- Transaction -&gt; Entry-Merkle -&gt; Block-Merkle -&gt; Bank-Hash

وناقل (vector) لمُدخلات (entries) الـ PoH:

- مُدخلات تصويت المُدقّق (Validator vote entries)
- العلامات (Ticks)
- المُدخلات الخفيفة (Light entries)

```text
/// This Entry definition skips over the transactions and only contains the
/// hash of the transactions used to modify PoH.
LightEntry {
    /// The number of hashes since the previous Entry ID.
    pub num_hashes: u64,
    /// The SHA-256 hash `num_hashes` after the previous Entry ID.
    hash: Hash,
    /// The Merkle Root of the transactions encoded into the Entry.
    entry_hash: Hash,
}
```

يُعاد بناء مُدخلات (entries) الضوء من المُدخلات وتُظهر ببساطة مُدخل Merkle Root الذي تم خلطه في تجزئة PoH، بدلاً من مجموعة المُعاملات الكاملة.

لا يحتاج العملاء (Clients) إلى حالة بدء التصويت. يتم تعريف خوارزمية [fork selection](../implemented-proposals/tower-bft.md) بحيث أن الأصوات التي تظهر بعد المُعاملة فقط هي التي تُوفر وقت إثبات المُعاملة (Finality)، ووقت إثبات المُعاملة مُستقل عن حالة البداية.

### التحقّق (Verification)

يُمكن للعميل الخفيف (light client) الذي يدرك مجموعة الأغلبية العظمى (supermajority) التحقق من الإيصال (receipt) بإتباع مسار Merkle إلى سلسلة PoH. Block-Merkle هو Merkle Root وسيظهر في الأصوات المُدرجة في المُدخل (entry). يُمكن للعميل الخفيف مُحاكاة اختيار الإنقسام أو الشوكة [ fork selection ](../implemented-proposals/tower-bft.md) للأصوات المُتتالية والتحقق من تأكيد الإيصال (receipt) عند حد الإغلاق المطلوب.

### الحالة الإصطناعية (Synthetic State)

يجب إحتساب الحالة الإصطناعية (Synthetic state) في تجزئة البنك (Bank-Hash) جنبًا إلى جنب مع الحالة التي تم إنشاؤها من قبل البنك.

على سبيل المثال:

- فترة (epoch) حسابات المُدقّق (validator) وحِصَصها (stakes) وأوزانها.
- مُعدلات الرسوم المُحَوْسَبَة (Computed fee rates)

يجب أن يكون لهذه القيم مُدخل (entry) في تجزئة البنك (Bank-Hash). يجب أن يعيشوا تحت حسابات معروفة، وبالتالي يكون لديهم فهرس في سلسلة التجزئة (hash concatenation).
