---
title: النسخ المُتماثل لدفتر الأستاذ (Ledger Replication)
---

مُلاحظة: تم تنفيذ حل النسخ المُتماثل لدفتر الأستاذ (ledger replication) هذا جزئيًا، ولكن لم يكتمل. تمت إزالة التطبيق الجزئي بواسطة https://github.com/solana-labs/solana/pull/9992 من أجل منع المخاطر الأمنية للتعليمات البرمجية غير المُستخدمة. يعكس الجزء الأول من مُستند التصميم هذا الأجزاء التي تم تنفيذها مرة واحدة من النسخ المُتماثل لدفتر الأستاذ (ledger replication). يصف الجزء الثاني من هذه الوثيقة [second part of this document](#ledger-replication-not-implemented) أجزاء الحل التي لم يتم تنفيذها مُطلقًا.

## دليل النسخ المُتماثل (Proof of Replication)

ستُولد Solana بكامل طاقتها على شبكة 1 1gbps في الثانية الواحدة، عدد 4 petabytes من البيانات سنويًا. لمنع الشبكة من التمركز حول المُدقّقين (validators) الذين يتعين عليهم تخزين مجموعة البيانات الكاملة، يقترح هذا البروتوكول طريقة للعُقد المُعدِّنة (mining nodes) لتوفير سعة تخزين لأجزاء من البيانات.

الفكرة الأساسية لـ دليل النسخ المُتماثل (Proof of Replication) هي تشفير مجموعة بيانات بمفتاح مُتماثل (symmetric key) عام بإستخدام تشفير CBC، ثم تجزئة (hash) مجموعة البيانات المُشفرة. المُشكلة الرئيسية في النهج الساذج هي أن عُقدة التخزين (storage nodes) غير النزيهة يُمكنها بث التشفير وحذف البيانات لأنها مُجزأة. الحل البسيط هو إعادة إنشاء التجزئة (hash) بشكل دوري بناءً على قيمة PoH المُوقَّعة. هذا يضمن أن جميع البيانات موجودة أثناء إنشاء الدليل ويتطلب أيضًا أن يكون لدى المُدقّقين (validators) كامل البيانات المُشفرة للتحقق من كل إثبات لكل هوية. لذا فإن المساحة المطلوبة للتحقق هي حجم الإثباتات ضارب حجم البيانات `number_of_proofs * data_size`

## التحسين بإستخدام الـ PoH

يتمثل تحسيننا في هذا النهج في أخذ عينات عشوائية من المقاطع المُشفرة بشكل أسرع مما يتطلبه الأمر للتشفير، وتسجيل تجزئة (hash) تلك العينات في دفتر أستاذ الـ PoH. بالتالي تظل المقاطع بالترتيب نفسه تمامًا لكل PoRep ويُمكن التحقق من دفق البيانات والتحقق من جميع البراهين في دفعة واحدة. بهذه الطريقة يُمكننا التحقق من البراهين المُتعددة في نفس الوقت، كل واحد على أساس CUDA الخاص به. إجمالي المساحة المطلوبة للتحقق هي `1_ledger_segment + 2_cbc_blocks * number_of_identities` مع عدد أساسي يساوي `number_of_identities`. نحن نستخدم حجم كتلة 64-byte chacha CBC.

## الشبكة (Network)

مُدقّقو (validators) لـ PoRep هم نفس المُدقّقين الذين يتحققون من المُعاملات. إذا تمكن أمين الأرشيف من إثبات أن المُدقّق (validator) قد قام بالتحقق من برنامج PoRep المُزيف، فلن يتلقى المُدقّق مُكافأة عن فترة التخزين تلك.

المُؤرشفون (Archivers) هم عملاء خفيفون_light clients_ مُتخصصون. يقومون بتنزيل جزء من دفتر الأستاذ \(ويعرف أيضًا بإسم الجزء\) وتخزينه، وتوفير PoReps لتخزين دفتر الأستاذ. لكل أرشفة PoRep تم التحقق منها، تحصل على مُكافأة من عملة sol من مُجمع التعدين (mining pool).

## القيود (Constraints)

لدينا القيود التالية:

- يتطلب التحقق إنشاء كتل CBC. ويتطلب ذلك مساحة عدد 2

  من الكتل (blocks) لكل هوية، ونواة CUDA واحدة لكل هوية لمجموعة البيانات نفسها. لذلك

  يجب تجميع العديد من الهويات دفعة واحدة مع العديد من الإثباتات لتلك

  الهويات التي تم التحقق منها بشكل مُتزامن لنفس مجموعة البيانات.

- سيقوم المُدقّقون (validators) بأخذ عينات عشوائية من مجموعة إثباتات التخزين إلى المجموعة التي

  يُمكنها التعامل معها، وفقط مُنشئو تلك الإثباتات المُختارة

  ستتم مُكافأتهم. يُمكن للمُدقّق (validator) تشغيل إختبار معياري متى تكون إعدادات الأجهزة الخاصة به

  تغييرت لتحديد المُعدل الذي يُمكِّنه من التحقق من صحة إثباتات التخزين.

## بروتوكول التحقق من الصحة والنسخ المُتماثل (Validation and Replication Protocol)

### الثوابت (Constants)

1. SLOTS_PER_SEGMENT: عدد الفُتحات (slots) في مقطع بيانات دفتر الأستاذ (ledger). ال

   وحدة لتخزين أرشيفي.

2. NUM_KEY_ROTATION_SEGMENTS: عدد المقاطع التي بعدها المُؤرشفون (Archivers)

   يُعيدون إنشاء مفاتيح التشفير الخاصة بهم وتحديد مجموعة بيانات جديدة لتخزينها.

3. NUM_STORAGE_PROOFS: عدد أدلة التخزين المطلوبة لمُكافأة

   مُطالبة إثبات التخزين بنجاح.

4. RATIO_OF_FAKE_PROOFS: نسبة الإثباتات المُزيفة مقارنة بالإثباتات الحقيقية التي يجب أن يحتويها

   إدعاء إثبات تعدين التخزين حتى يكون صالحًا للحصول على مُكافأة.

5. NUM_STORAGE_SAMPLES: عدد العينات المطلوبة لإثبات التعدين

   بالتخزين.

6. NUM_CHACHA_ROUNDS: عدد جولات التشفير التي تم إجراؤها لإنشاء

   حالة التشفير.

7. NUM_SLOTS_PER_TURN: عدد الفُتحات (Slots) التي تُحدد فترة (epoch) تخزين واحدة أو

   "دورة" لعبة PoRep.

### سلوك المُدقّق (Validator behavior)

1. ينضم المُدقّقون (validators) إلى الشبكة ويبدأون في البحث عن حسابات المُؤرشف (Archiver) في كل

   فترة (epoch) تخزين/حدود مُنعطف.

2. في كل مُنعطف، يوقع المُدقّقون (validators) قيمة الـ PoH عند الحدود ويستخدمون هذا التوقيع

   لإختيار الإثباتات بشكل عشوائي للتحقق من كل حساب تخزين (storage account) موجود في حدود المُنعطف.

   يتم إرسال هذه القيمة المُوقعة أيضًا إلى حساب تخزين المُدقّق (validator) وسيتم إستخدامها بواسطة

   المُؤرشفين (Archivers) في مرحلة لاحقة للتحقق المُتبادل.

3. Every `NUM_SLOTS_PER_TURN` slots the validator advertises the PoH value. يتم تقديم هذه القيمة

   أيضًا إلى أجهزة الأرشفة عبر واجهات RPC.

4. بالنسبة لدور مُعين N، يتم قفل جميع عمليات التحقق حتى تتحول N+3 \(فجوة 2 دورات/ الفترة\).

   عند هذه النقطة، تكون جميع عمليات التحقق من الصحة خلال هذا الدور مُتاحة لجمع المُكافآت.

5. سيتم وضع علامة على أي عمليات تحقق غير صحيحة أثناء الدور بينهما.

### سلوك المُؤرشف (Archiver behavior)

1. نظرًا لأن برنامج المُؤرشف (Archiver) هو عميل خفيف (light client) إلى حد ما ولا يقوم بتنزيل جميع

   بيانات دفتر الأستاذ (ledger)، فيجب عليه الإعتماد على المُدقّقين (validators) والمُؤرشفين (Archivers) الآخرين للحصول على المعلومات.

   قد يكون أو لا يكون أي مُدقّق (validator) ضار ويُعطي معلومات غير صحيحة، على الرغم من

   عدم وجود أي ناقلات هجوم (attack vectors) واضحة يُمكن أن يُحققها هذا بالإضافة إلى قيام

   المُؤرشف (Archiver) بعمل إضافي ضائع. بالنسبة للعديد من العمليات، هناك عدد من الخيارات

   إعتمادًا على مدى إرتياب المُؤرشف (Archiver):

   - \(a\) يُمكن للمُؤرشف (Archiver) أن يسأل المُدقّق (validator)
   - \(b\) يُمكن للمُؤرشف (Archiver) أن يطلب عدة مُدقّقين (validators)
   - \(c\) يُمكن للمُؤرشف (Archiver) أن يسأل مُؤرشفون (Archivers) آخرين
   - \(d\) يُمكن للمُؤرشف (Archiver) الإشتراك في تدفق المُعاملات الكامل وإنشاء

     (بإفتراض أن الفُتحة أو الـ slot حديثة بما يكفي\)

   - \(e\) يُمكن للمُؤرشف (Archiver) الإشتراك في تدفق المُعاملات ل

     توليد المعلومات نفسها \(بإفتراض أن الفترة أو الـ slot حديثة بما يكفي\)

2. يحصل المُؤرشف (Archiver) على تجزئة (hash) الـ PoH المُقابلة للإنعطاف الأخير بفُتحته (slot).
3. يُوقع المُؤرشف (Archiver) تجزئة (hash) الـ PoH بزوج المفاتيح (keypair) الخاص به. هذا التوقيع

   هو الأصل المُستخدم لإختيار المقطع المُراد نسخه وكذلك مفتاح التشفير. يقوم

   المُؤرشف (Archiver) بتعديل التوقيع بالفُتحة (Slot) للحصول على الجزء المُراد

   نسخه.

4. يسترجع المُؤرشف (Archiver) دفتر الأستاذ (ledger) عن طريق سؤال المُدقّقين (validators) النظراء و

   المُؤرشفين (Archivers). راجع 6.5.

5. يقوم المُؤرشف (Archiver) بعد ذلك بتشفير هذا المقطع بالمفتاح بإستخدام خوارزمية chacha

   في وضع CBC بإستخدام `NUM_CHACHA_ROUNDS` من التشفير.

6. يقوم المُؤرشف (Archiver) بتهيئة chacha rng مع قيمة PoH المُوقَّعة مؤخرًا

   كبذرة.

7. يُنشئ برنامج الأرشفة `NUM_STORAGE_SAMPLES` عينة في نطاق حجم

   الإدخال (entry) ويأخذ عينات من المقطع المُشفر بإستخدام sha256 لـ 32-bytes في كل منها

   قيمة تعويض. يجب أن يكون أخذ عينات الحالة أسرع من إنشاء

   المقطع المُشفر.

8. يرسل المُؤرشف (Archiver) مُعاملة إثبات PoRep والتي تحتوي على حالة sh

   في نهاية عملية أخذ العينات، وبذورها والعينات التي إستخدمتها إلى

   القائد (leader) الحالي ويتم وضعها في دفتر الأستاذ (ledger).

9. خلال دورة مُعينة، يجب على المُؤرشف (Archiver) تقديم العديد من البراهين لنفس المقطع

   وبناءً على نسبة الإثباتات المُزيفة `RATIO_OF_FAKE_PROOFS`، يجب أن تكون بعض هذه الأدلة مُزيفة.

10. مع دخول لعبة PoRep إلى المُنعطف التالي، يجب على المُؤرشف (Archiver) إرسال

    مُعاملة مع القناع الذي كانت فيه الإثباتات مُزيفة أثناء المنعطف الأخير. هذه

    المُعاملة ستُحدد المُكافآت لكل من المُؤرشفين (Archivers) والمُدقّقين (validators).

11. أخيرًا الإنعطاف N، مع دخول لعبة PoRep في الدور N+3، سيتم إحتساب إثباتات المُؤرشفين (Archivers)

    للدور N في مُكافآتهم.

### لعبة Porep أو The PoRep Game

تحتوي لعبة دليل النسخ المُتماثل (Proof of Replication) على 4 مراحل أساسية. كل "دور" (turn) يُمكن أن تكون ألعاب PoRep المُتعددة قيد التقدم ولكن كل منها في مرحلة مُختلفة.

المراحل الأربع من لعبة PoRep كما يلي:

1. مرحلة تقديم الإثبات (Proof submission stage)
   - المُؤرشفون (Archivers): تقديم أكبر عدد مُمكن من الإثباتات خلال هذه المرحلة
   - المُدقّقون: No-op
2. مرحلة التحقق من الإثبات (Proof verification stage)
   - المُؤرشفون: No-op
   - المُدقّقون (validators): يختارون المُؤرشفين (Archivers) ويتحققون من الإثباتات الخاصة بهم من المُنعطف السابق
3. مرحلة تحدي الإثبات (مرحلة تحدي الإثبات)
   - المُؤرشفون (Archivers): يرسلون قناع الإثبات مع التبريرات\(للإثباتات المُزيفة التي تم تقديمها قبل دورتين\)
   - المُدقّقون: No-op
4. مرحلة جمع المكافآت (Reward collection stage)
   - المُؤرشفون (Archivers): يجمعون المُكافآت قبل 3 أدوار (turns)
   - المُدقّقون (validators): يجمعون المُكافآت لمدة 3 أدوار (turns) مضت

لكل دور (turn) في لعبة PoRep، يقوم كل من المُدقّقين (validators) و المُؤرشفين (Archivers) بتقييم كل مرحلة. يتم تشغيل المراحل كعمليات مُنفصلة في برنامج التخزين (storage program).

### العثور على من لديه كتلة (block) مُعينة من دفتر الأستاذ (ledger)

1. يُراقب المُدقّقون (validators) المُنعطفات في لعبة PoRep وينظرون إلى البنك المُتجذر

   عند حدود الدور (turn) بحثًا عن أي إثباتات.

2. يحتفظ المُدقّقون (validators) بخريطة شرائح دفتر الأستاذ (ledger) والمفاتيح العامة (public keys) للأرشيف المناسب.

   يتم تحديث الخريطة عندما يُعالج المُدقّق (validator) أدلة المُؤرشفين (Archivers) لجزء ما.

   يُوفر المُدقّق (validator) واجهة RPC للوصول إلى هذه الخريطة. بإستخدام واجهة برمجة التطبيقات (API) هذه، يُمكن للعملاء

   تعيين مقطع إلى عنوان شبكة المُؤرشفين (Archivers) \ (ربطه عبر جدول معلومات المجموعة\).

   يمكن للعملاء بعد ذلك إرسال طلبات الإصلاح إلى المُؤرشف (Archiver) لإسترداد المقاطع.

3. سيحتاج المُدقّقون (validators) إلى إبطال هذه القائمة كل في كل مُنعطف (turn) الـ N.

## هجمات Sybil أو Sybil attacks

بالنسبة لأي بذرة عشوائية، نجبر الجميع على إستخدام توقيع مُشتق من تجزئة (hash) الـ PoH عند حدود المُنعطف (turn). يستخدم الجميع العدد نفسه، لذلك يتم توقيع نفس تجزئة (hash) الـ PoH بواسطة كل مُشارك. ثم يتم ربط كل توقيعات مُشفرة بزوج المفاتيح (keypair)، مما يمنع القائد (leader) من الطحن على القيمة الناتجة لأكثر من هوية واحدة.

نظرًا لوجود العديد من هويات العملاء ثم هويات التشفير، نحتاج إلى تقسيم المُكافأة لعدة عملاء، ومنع هجمات Sybil من إنشاء العديد من العملاء للحصول على نفس كتلة (block) البيانات. لإبقاء BFT، نُريد تجنب أن يكون كيان بشري واحد يُخزن جميع النسخ المُكررة لجزء واحد من دفتر الأستاذ (ledger).

حلنا لهذا هو إجبار العملاء على الإستمرار في إستخدام نفس الهوية. إذا تم إستخدام الجولة الأولى للحصول على نفس الكتلة (block) للعديد من هويات العملاء، فإن الجولة الثانية لنفس هويات العميل ستفرض إعادة توزيع التواقيع، وبالتالي هويات وكتل PoRep. بالتالي، للحصول على مُكافأة للمُؤرشفين (Archivers)، يجب تخزين الكتلة (block) الأولى مجانًا ويُمكن للشبكة أن تُكافئ هويات العملاء طويلة الأمد أكثر من الهويات الجديدة.

## هجمات المُدقّقين (Validator attacks)

- إذا وافق المُدقّق (validator) على الإثباتات المُزيفة، فيُمكن للمُؤرشف (Archiver) إخراجها بسهولة

  من خلال إظهار الحالة الأولية للتجزئة (hash).

- إذا قام المُدقّق (validator) بتمييز البراهين الحقيقية على أنها مُزيفة، فلا يُمكن إجراء أي حساب على على الشبكة (On-Chain)

  لتمييز من هو الصحيح. يجب أن تعتمد المُكافآت على النتائج من

  عدة مُدقّقين (validators) للقبض على المُمثلين السيئين والمُؤرشفين (Archivers) من الحرمان من المُكافآت.

- المُدقّق (validator) يسرق نتائج إثبات التعدين (mining proof) لنفسه. تُستمد الإثباتات

  من توقيع من المُؤرشف (Archiver)، نظرًا لأن المُدقّق (validator) لا يعرف

  المفتاح الخاص (private key) المُستخدم لإنشاء مفتاح التشفير (encryption key)، فلا يُمكن أن يكون مُنشئ

  الإثبات.

## حوافز المُكافأة (Reward incentives)

من السهل إنشاء الإثباتات المُزيفة ولكن من الصعب التحقق منها. لهذا السبب، قد تتطلب مُعاملات إثبات PoRep التي يتم إنشاؤها بواسطة المُؤرشفون (Archivers) رسومًا أعلى من المُعاملة العادية لتمثيل التكلفة الحسابية التي يطلبها المُدقّقون (validators).

بعض النسبة المئوية من الإثباتات المُزيفة ضرورية أيضًا لتلقي مُكافأة من تعدين التخزين (storage proof).

## الملاحظات (Notes)

- يُمكننا تقليل تكاليف التحقق من PoRep بإستخدام الـ PoH، وجعلها بالفعل

  قابلة للتحقق من عدد كبير من الإثباتات لمجموعة بيانات عامة.

- يُمكننا القضاء على الطحن عن طريق إجبار الجميع على توقيع نفس تجزئة (hash) الـ PoH و

  إستخدام التوقيعات كبذرة

- تدور اللعبة بين المُدقّقين (validators) والمُؤرشفون (Archivers) على الكتل (blocks) العشوائية

  وهويات التشفير العشوائية وعينات البيانات العشوائية. الهدف من التوزيع العشوائي هو

  منع المجموعات المُتآمرة من التداخل في البيانات أو التحقق من إثبات الصحة أو المُصادقة (validation).

- يقوم عملاء المُؤرشف (Archiver) بالبحث عن المُدقّقين (validators) الكسالى من خلال تقديم أدلة مُزيفة على ذلك

  يُمكنهم إثبات أنها مُزيفة.

- للدفاع ضد هويات عملاء Sybil التي تُحاول تخزين نفس الكتلة (block)،

  نُجبر العملاء على التخزين لعدة جولات قبل إستلام المكافأة.

- يجب أيضًا مُكافأة المُدقّقين (validators) على التحقق من صحة أدلة التخزين (storage proofs) المُقدمة

  كحافز لتخزين دفتر الأستاذ (ledger). يُمكنهم فقط التحقق من صحة الإثباتات إذا كانوا

  يُخزنون تلك الشريحة من دفتر الأستاذ (ledger).

# لم يتم بعد تنفيذ النسخ المُتماثل لدفتر الأستاذ (Ledger Replication Not Implemented)

لم يتم تنفيذ سلوك النسخ المُتماثل بعد.

## فترة التخزين (Storage epoch)

يجب أن تكون فترة التخزين (storage epoch) عبارة عن عدد الفُتحات (Slots) التي ينتج عنها حوالي 100GB-1TB من دفتر الأستاذ (ledger) ليتم إنشاؤه للمُؤرشفون (Archivers) لتخزينه. سيبدأ المُؤرشفين (Archivers) في تخزين دفتر الأستاذ (ledger) عندما يكون للإنقسام أو الشوكة (fork) إحتمالية كبيرة بعدم التراجع.

## سلوك المُدقّق (Validator behavior)

1. كل NUM_KEY_ROTATION_TICKS يقوم أيضًا بالتحقق من صحة العينات المُتلقاة من

   المُؤرشفين (Archivers). يُوقع على تجزئة تجزئة (hash) الـ PoH عند تلك النقطة ويستخدم ما يلي

   خوارزمية مع التوقيع كمُدخل (input):

   - تُنشئ الـ 5 bits المُنخفضة من الـ byte الأول من التوقيع فهرسًا إلى

     بداية byte آخر من التوقيع.

   - ثم ينظر المُدقّق (validator) في مجموعة إثباتات التخزين (storage proofs) حيث يتطابق byte

     مُتجه حالة sha (أو sha state vector) للإثبات بدءًا من الـbyte المُنخفض تمامًا

     مع الـbyte المُختار للتوقيع.

   - إذا كانت مجموعة الإثباتات أكبر مما يُمكن للمُدقّق (validator) التعامل معه، فإنه

     يزداد إلى 2 bytes في التوقيع.

   - يستمر المُدقّق (validator) في زيادة عدد وحدات الـ bytes المُطابقة حتى يتم العثور

     على مجموعة قابلة للتطبيق.

   - ثم يقوم بإنشاء قناع من الإثباتات الصالحة والإثباتات المُزيفة ويُرسله إلى

     القائد (leader). هذه مُعاملة تأكيد إثبات التخزين.

2. بعد فترة إغلاق مُدتها NUM_SECONDS_STORAGE_LOCKOUT من الثواني، يُرسل

   يُرسل المُدقّق (validator) بعد ذلك مُعاملة مُطالبة بإثبات التخزين والتي تُؤدي بعد ذلك

   إلى توزيع مُكافأة التخزين في حالة عدم ظهور إعتراضات على الإثبات في إثباتات

   كل من المُدقّقين (validators) والمُؤرشفين (Archivers).

## سلوك المُؤرشف (Archiver behavior)

1. يقوم المُؤرشف (Archiver) بعد ذلك بإنشاء مجموعة أخرى من عمليات الإزاحة (offsets) التي يُقدمها دليلًا مُزيفًا

   بحالة sha غير صحيحة. يُمكن إثبات أنها مُزيفة من خلال توفير

   البذور لنتيجة التجزئة (hash).

   - يجب أن يتكون الدليل المُزيف من تجزئة (hash) مُؤرشف (Archiver) لتوقيع

     قيمة PoH. بهذه الطريقة عندما يكشف المُؤرشف (Archiver) الدليل المُزيف، يُمكن

     التحقق منه على الشبكة.

2. يُراقب المُؤرشف (Archiver) دفتر الأستاذ (ledger)، إذا رأى إثباتًا مُزيفًا مُدمجًا، فإنه

   يُنشئ مُعاملة تحدي ويُرسلها إلى القائد (leader) الحالي. يُثبت

   التحويل أن المُدقّق (validator) قد قام بالتحقق من صحة إثبات التخزين المُزيف بشكل غير صحيح.

   تتم مُكافأة المُؤرشف (Archiver) ويتم الإقتطاع (slashing) أو

   تجميد رصيد إثبات الحِصَّة أو التَّحْصِيص (staking) الخاص بالمُدقّق (validator).

## منطق عقد إثبات التخزين (Storage proof contract logic)

سيكون لكل مُؤرشف (Archiver) والمُدقّق (validator) حساب تخزين خاص به. سيكون حساب المُدقّقون (validators) مُنفصلاً عن مُعرف القيل والقال (gossip id) مُشابه لحساب تصويتهم. يجب تنفيذ هذين البرنامجين كبرنامجين، أحدهما يتعامل مع المُدقّق (validator) بإعتباره المُصمم والآخر للمُؤرشف (Archiver). بهذه الطريقة عندما تُشير البرامج إلى حسابات أخرى، يُمكنهم التحقق من مُعرّف البرنامج للتأكد من أنه مُدقق أو حساب مُؤرشف (Archiver) يراجعونه.

### تقديم دليل التعدين (SubmitMiningProof)

```text
SubmitMiningProof {
    slot: u64,
    sha_state: Hash,
    signature: Signature,
};
keys = [archiver_keypair]
```

يقوم المُؤرشِفون (Archivers) بإنشاء هذه بعد تعدين عن بيانات دفتر الأستاذ (ledger) المُخزن الخاص بهم لقيمة تجزئة (hash) مُعينة. الفُتحة (Slot) هي الفُتحة النهائية لجزء دفتر الأستاذ (ledger) الذي يقومون بتخزينه، وهي الحالة الناتجة عن مُؤرشِف (Archiver) يستخدام وظيفة التجزئة (hash) لأخذ عينات من مقطع دفتر الأستاذ الشفر. التوقيع هو التوقيع الذي تم إنشاؤه عند توقيعهم على قيمة الـ PoH لفترة التخزين (Storage epoch) الحالية. يجب حفظ قائمة الإثباتات من فترة التخزين (Storage epoch) الحالية في حالة الحساب، ثم نقلها إلى قائمة الإثباتات للفترة (epoch) السابقة عندما تمر الفترة. في فترة التخزين (Storage epoch) مُعينة، يجب على المُؤرشِف (Archiver) تقديم الإثباتات لجزء واحد فقط.

يجب أن يحتوي البرنامج على قائمة بالفُتحات (Slots) التي تُعد فُتحات (Slots) تعدين صالحة للتخزين. يجب الحفاظ على هذه القائمة من خلال تتبع الفُتحات (slots) التي هي فُتحات مُتجذرة صوّت عليها جزء كبير من الشبكة بقيمة تأمين عالية، ربما 32 صوتًا. ستتم إضافة كل عدد SLOTS_PER_SEGMENT من الفُتحات (Slots) إلى هذه المجموعة. يجب أن يتحقق البرنامج من أن الفُتحة (Slot) في هذه المجموعة. يُمكن الحفاظ على المجموعة من خلال تلقي الإعلان عن التخزين الأخير لتجزئة الكتلة (AdvertiseStorageRecentBlockHash) والتحقق من حالة البنك / Tower BFT.

يجب أن يقوم البرنامج بإجراء التحقق من التوقيع والتحقق من التوقيع والمفتاح العمومي (public key) من مُقدم المُعاملة ورسالة قيمة الـ PoH في فترة التخزين (Storage epoch) السابقة.

### إثبات الصِّحة (ProofValidation)

```text
ProofValidation {
   proof_mask: Vec<ProofStatus>,
}
keys = [validator_keypair, archiver_keypair(s) (unsigned)]
```

سيقوم المُدقّق (validator) بإرسال هذه المُعاملة للإشارة إلى أن مجموعة الإثباتات لشريحة مُعينة صالحة / غير صالحة أو تم تخطيها حيث لم ينظر المُدقّق (validator) إليها. يجب الإشارة إلى أزواج المفاتيح (keypairs) الخاصة بالمُؤرشِفين (Archivers) التي تم فحصها في المفاتيح حتى يتمكن منطق البرنامج من الإنتقال إلى تلك الحسابات ومعرفة أن الإثباتات تم إنشاؤها في الفترة (epoch) السابقة. يجب التحقق من أخذ عينات إثباتات التخزين (storage proofs) لضمان تخطي المُدقّق (validator) الإثباتات الصحيحة وفقًا للمنطق المُوضح في سلوك أخذ المُدقّق (validator) للعينات.

ستُشير مفاتيح المُؤرشِف (Archiver) المُضمنة إلى عينات التخزين التي يتم الرجوع إليها؛ يجب التحقق من طول قناع الإثبات (proof_mask) مُقابل مجموعة إثباتات التخزين (storage proofs) في حساب المُؤرشِف (Archiver) المُشار إليه، ويجب أن يتطابق مع عدد الأدلة المُقدمة في فترة التخزين (Storage epoch) السابقة في حالة حساب المُؤرشِف (Archiver) المذكور.

### المُطالبة بمُكافأة التخزين (ClaimStorageReward)

```text
ClaimStorageReward {
}
keys = [validator_keypair or archiver_keypair, validator/archiver_keypairs (unsigned)]
```

سيستخدم المُؤرشِفين (Archivers) والمُدقّقون (validators) هذه المُعاملة للحصول على رموز مدفوعة من حالة البرنامج حيث يوجد إرسال إثبات التخزين (SubmitStorageProof) وإثبات الصِّحة (ProofValidation) والتحقق من صِّحة إثبات التحدي (ChallengeProofValidations) في حالة تم فيها تقديم الإثباتات والتحقق من صحتها ولا يوجد تحقق من صِّحة إثبات التحدي (ChallengeProofValidations) يُشير إلى تلك الإثباتات. بالنسبة للمُدقّق (validator)، يجب أن يُشير إلى أزواج مفاتيح (keypairs) المُؤرشِف (Archiver) الذي قام بالتحقق من صحة الإثباتات في الفترة (epoch) ذات الصلة. بالنسبة للمُؤرشِف (Archiver)، يجب أن يُشير إلى أزواج مفاتيح (keypairs) المُدقّق (validator) التي تم التحقق من صحتها ويُريد الحصول على مُكافأتة مُقابلها.

### صِّحة إثبات التحدي (ChallengeProofValidation)

```text
ChallengeProofValidation {
    proof_index: u64,
    hash_seed_value: Vec<u8>,
}
keys = [archiver_keypair, validator_keypair]
```

هذه المُعاملة مُخصصة لإصطياد المُدقّقين (validators) الكسالى الذين لا يقومون بالعمل للتحقق من صحة الإثباتات. سيُرسل المُؤرشِف (Archiver) هذه المُعاملة عندما يرى أن المُدقّق (validator) قد وافق على مُعاملة تقديم دليل التعدين (SubmitMiningProof) وهمية. نظرًا لأن المُؤرشِف (Archiver) هو عبارة عن عميل خفيف (light client) لا ينظر إلى الشبكة الكاملة، فسيتعين عليه أن يطلب من المُدقّق (validator) أو مجموعة من المُدقّقين لهذه المعلومات ربما عبر إستدعاء RPC للحصول على جميع عمليات التحقق من صحة شريحة مُعينة في فترة التخزين (Storage epoch) السابقة. سيبحث البرنامج في حالة حساب المُدقّق (validator)، ويرى أنه تم تقديم إثبات التحقق في فترة التخزين (Storage epoch) السابقة ويُجزئ التجزئة hash_seed_value ومعرفة أن التجزئة تُطابق مُعاملة تقديم دليل التعدين (SubmitMiningProof) وأن المُدقّق حددها على أنها صالحة. إذا كان الأمر كذلك، فسيتم حفظ التحدي في قائمة التحديات التي يُواجهها في حالته.

### الإعلان عن تخزين تجزئة الكُتلة الحديثة (AdvertiseStorageRecentBlockHash)

```text
AdvertiseStorageRecentBlockhash {
    hash: Hash,
    slot: u64,
}
```

سيقوم المُدقّقون (validators) والمُؤرشِفون (Archivers) بإرسال هذا للإشارة إلى أن فترة تخزين (Storage epoch) جديدة قد إنقضت وأن إثباتات التخزين التي هي إثباتات حالية يجب أن تكون الآن للفترة (epoch) السابقة. يجب أن تتحقق المُعاملات الأخرى لمعرفة ما إذا كانت الفترة (epoch) التي تُشير إليها دقيقة وفقًا لحالة الشبكة الحالية.
