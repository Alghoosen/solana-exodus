---
title: التأكيد المُتفائل (Optimistic Confirmation)
---

## التعليمات الأولية (Primitives)

`vote(X, S)` - ستزداد الأصوات بفُتحة (Slot) "مرجعية"، `X` وهي أحدث سلف **latest** لهذا الإنقسام أو الشوكة (fork) التي صوّت عليها هذا المُدقّق (validator) مع إثبات التبديل (proof of switching). طالما أن المُدقّق (validator) يقوم بأصوات مُتتالية تنحدر جميعها من بعضها البعض، يجب إستخدام نفس `X` لجميع هذه الأصوات. عندما يجري المُدقّق (validator) تصويتًا على الفُتحة `s` غير المُنحدرة من السابقة، فسيتم تعيين `X` على الفتحة (slot) الجديدة `s`. ستكون جميع الأصوات بعد ذلك بالصيغة `vote(X, S)`، حيث تكون `S` هي القائمة المُصنفة من الفُتحات `(s, s.lockout)` التي يتم التصويت عليها.

بالنظر إلى التصويت `vote(X, S)`، لنفترض أن `S.last == vote.last` تكون الفُتحة (Slot) الأخيرة في `S`.

الآن نُحدد بعض شروط "الإقتطاع المتفائل (Optimistic Slashing)". الحدس لهذه الموضوعات يرد وصفه أدناه:

- `Intuition`: إذا أرسل المُدقّق `vote(X, S)`، فلا يجب أن يُصوت نفس المُدقّق (validator) على إنقسام أو شوكة (fork) مختلفة "تتداخل" مع هذا الإنقسام أو الشوكة. بشكل أكثر تحديدًا، يجب ألا يكون هذا المُدقّق (validator) قد أدلى بصوت آخر `vote(X', S')` حيث يتداخل النطاق `[X, S.last]` مع النطاق `[X', S'.last]`، `X != X'` كما هو موضح أدناه:

```text
                                  +-------+
                                  |       |
                        +---------+       +--------+
                        |         |       |        |
                        |         +-------+        |
                        |                          |
                        |                          |
                        |                          |
                    +---+---+                      |
                    |       |                      |
                X   |       |                      |
                    |       |                      |
                    +---+---+                      |
                        |                          |
                        |                      +---+---+
                        |                      |       |
                        |                      |       |  X'
                        |                      |       |
                        |                      +---+---+
                        |                          |
                        |                          |
                        |                          |
                        |                          |
                        |                      +---+---+
                        |                      |       |
                        |                      |       |  S'.last
                        |                      |       |
                        |                      +-------+
                        |
                    +---+---+
                    |       |
                 s  |       |
                    |       |
                    +---+---+
                        |
                        |
                        |
                        |
                    +---+---+
                    |       |
             S.last |       |
                    |       |
                    +-------+
```

(مثال على الأصوات القابلة للإقتطاع (X '،S') والتصويت (X،S))

في الرسم البياني أعلاه، لاحظ أنه يجب إرسال التصويت لـ `S.last` بعد التصويت لـ `S'.last` (بسبب عمليات الإغلاق، يجب أن يكون التصويت الأعلى قد تم إرساله لاحقًا). بالتالي، يجب أن يكون تسلسل الأصوات: ` X ... S'.الأخير ... S'.الأخير`. هذا يعني أنه بعد التصويت على `S'.last`، يجب أن يكون المُدقّق (validator) قد عاد إلى الإنقسام أو الشوكة (fork) الأخرى في بعض الفُتحات `s > S'.last > X`. بالتالي، فإن التصويت لـ `S.last` يجب أن يستخدم `s` كنقطة "مرجعية" وليس `X`، لأن هذا كان آخر "تبديل" "على الإنقسام أو الشوكة (fork).

لفرض هذا، نُحدد شروط "الإقتطاع المتفائل" (Optimistic Slashing). بالنظر إلى أي صوتين مُميزين `vote(X, S)` و `vote(X', S')` بواسطة المُدقّق (validator) نفسه، يجب أن تفي الأصوات بـ:

- `X <= S.last`, `X' <= S'.last`
- كل `s` في `S` هم أسلاف (ancestors) / سُلالة مُتحدِّرة (descendants) من بعضهم البعض، كل `s'` في `S'` هم أسلاف (ancestors) / سُلالة مُتحدِّرة (descendants) من بعضهم البعض،
-
- يُشير الرقم `X == X'` إلى أن `S` هو أصل `S'` أو أن `S'` هو أصل `S`
- يُشير الرقم `X' > X` إلى `X' > S.last` و `S'.last > S.last` ولجميع ` s ` في `S`, `s + lockout(s) < X'`
- يُشير الرقم `X > X'` إلى `X > S'.last` و `S.last > S'.last` ولكل `s` في `S'`, `s + lockout(s) < X`

(تُشير القاعدتان الأخيرتان إلى عدم إمكانية تداخل النطاقات): وإلا يتم الإقتطاع للمُدقّق (validator).

`Range(vote)` - عند التصويت `v = vote(X, S)`، حدد `Range (v) ` ليكون نطاق الفُتحات `[X, S.last]`.

`SP(old_vote, new_vote)` - هذا هو "إثبات التبديل" (Switching Proof) لـ `old_vote`، أحدث تصويت للمُدقّق (validator). مثل هذا الإثبات ضروري في أي وقت يقوم المُدقّق (validator) بتبديل فُتحة (Slot) "المرجع" (راجع قسم التصويت أعلاه). يتضمن دليل التبديل (switching proof) إشارة إلى `old_vote`، بحيث يكون هناك سجل لما كان عليه "النطاق" من ذلك `old_vote` (لجعل المُفاتيح المُتعارضة الأخرى في هذا النطاق قابلة للكسر). مثل هذا التبديل يجب أن يحترم عمليات الإغلاق.

يُظهر دليل التبديل أن `> 1/3` من الشبكة مُؤمنة في الفُتحة `old_vote.last`.

الإثبات عبارة عن قائمة من العناصر `(validator_id, validator_vote(X, S))`، حيث:

1. مجموع الحِصَص (stakes) لجميع مُعرفات المُدقّق `> 1/3`

2. لكل `(validator_id, validator_vote(X, S))` يُيوجد بعض الفُتحات `s` في `S` حيث: _ a.`s` ليس سلفًا (ancestor) مُشتركًا لكل من `validator_vote.last` و `old_vote.last` و `new_vote.last`. _ b. `s` ليس سليلًا `validator_vote.last`. \* c. `s + s.lockout() >= old_vote.last` (يعني أن المُدقّق (validator) لا يزال مغلقًا على الفُتحة `s` at slot `old_vote.last`).

تبديل الإنقسامات أو الشوكات (forks) بدون دليل صالح للتحويل قابل للإقتطاع.

## التعريفات (Definitions):

التأكيد المُتفائل (Optimistic Confirmation) - يُقال بعد ذلك أن الكتلة `B` قد حققت "تأكيدًا متفائلًا" إذا صوت `>2/3` من الحِصَّة (stake) بأغلبية `v` حيث أن `Range(v)` لكل `v` تتضمن `B.slot`.

تم تم الإنتهاء منه (Finalized) - يُقال إن الكتلة `B` قد تم الإنتهاء منها إذا قام مُدقّق (validator) صحيح واحد على الأقل بتجذير `B` أو سليل `B`.

تم التراجع عنها (Reverted) - يُقال إن الكتلة `B` ستم التراجع عنها إذا تم الإنتهاء من كتلة `B'` أخرى ليست أصل `B` أو مُتفردة منها.

## الضمانات (Guarantees):

لن يتم التراجع عن الكتلة `B` التي وصلت إلى تأكيد تأكيد مُتفائل (Optimistic Confirmation) ما لم يتم الإقتطاع لمُدقّق (validator) واحد على الأقل.

## الإثباتات (Proof):

لنفترض من أجل التناقض، أن الكتلة `B` حققت `optimistic confirmation` في بعض الفُتحات `B + n` لحوالي `n`، و:

- تم الإنتهاء من كتلة أخرى `B'` ليست أصلََا (parent) أو سُلالة مُتحدرين (descendant) من `B`.
- لم ينتهك أي مُدقّق (validator) أيا من شروط الإقتطاع.

من خلال تعريف `optimistic confirmation`، هذا يعني أن `> 2/3` من المُدقّقين (validators) أظهروا بعض التصويت `v` من النموذج `Vote(X, S)` حيث `X <= B <= v.last`. نُسمي هذه المجموعة من المُدقّقين `Optimistic Validators`.

الآن يتم منح المُدقّق `v` في `Optimistic Validators`، بالنظر إلى صوتين تم إجراؤهما بواسطة `v`, `Vote(X, S)` و `Vote(X', S')` حيث `X <= B <= S.last` و `X' <= B <= S'.last`، ثم `X == X'` وإلا تم إنتهاك شرط "الإقتطاع المُتفائل" (ستتداخل "نطاقات" كل صوت عند `B`).

بالتالي تم تحديد `Optimistic Votes` لتكون مجموعة الأصوات التي تم إجراؤها بواسطة `Optimistic Validators`، حيث لكل مُدقّق مُتفائل `v`، يكون التصويت الذي تم إجراؤه بواسطة `v` المُضمَّن في المجموعة هو `maximal` صوت `Vote(X, S)` مع أكبر `S.last` من أي أصوات تم إجراؤها بواسطة `v` والتي ترضي `X <= B <= S.last`. نظرًا لأننا نعلم أن `X` لكل هذه الأصوات التي تم إجراؤها بواسطة `v` هي فريدة من نوعها، فنحن نعلم أن هناك مثل هذا التصويت الفريد `maximal` vote.

### Lemma 1:

`Claim:` نظرًا لتصويت `Vote(X, S)` بواسطة المُدقّق`V` في مجموعة `Optimistic Validators`، و `S` يحتوي على تصويت لفُتحة `s` والتي:

- `s + s.lockout > B`,
- `s` ليس سلف أو سُلالة مُتحدِّرة `B`،

ثم `X > B`.

```text
                                  +-------+
                                  |       |
                        +---------+       +--------+
                        |         |       |        |
                        |         +-------+        |
                        |                          |
                        |                          |
                        |                          |
                        |                      +---+---+
                        |                      |       |
                        |                      |       |  X'
                        |                      |       |
                        |                      +---+---+
                        |                          |
                        |                          |
                        |                      +---+---+
                        |                      |       |
                        |                      |       |  B (Optimistically Confirmed)
                        |                      |       |
                        |                      +---+---+
                        |                          |
                        |                          |
                        |                          |
                        |                      +---+---+
                        |                      |       |
                        |                      |       |  S'.last
                        |                      |       |
                        |                      +-------+
                        |
                    +---+---+
                    |       |
                 X  |       |
                    |       |
                    +---+---+
                        |
                        |
                        |
                        |
                        |
                        |
                    +---+---+
                    |       |
            S.last  |       |
                    |       |
                    +---+---+
                        |
                        |
                        |
                        |
                    +---+---+
                    |       |
      s + s.lockout |       |
                    +-------+
```

`Proof`: إفترض أنه من أجل التناقض، قام المُدقّق `V` من مجموعة "المُدقّقين المُتفائلين " بإجراء مثل هذا التصويت `Vote(X, S)` حيث يحتوي `S` على تصويت للفُتحة `s` ليس سلفََا (ancestor) أو سليلًا (descendant) لـ `B`، حيث `s + s.lockout > B` ولكن `X <= B`.

فليكن التصويت `Vote(X', S')` في مجموعة `Optimistic Votes` بواسطة المُدقّق `V`. حسب تعريف تلك المجموعة (كل الأصوات أكدت بتفاؤل `B`)، `X' <= B <= S'.last` (راجع الرسم البياني أعلاه).

هذا يعني أنه من المُفترض أنه أعلى من `X <= B`، ثم `X <= S'.last`، لذلك وفقًا لقواعد الإقتطاع، إما `X == X'` أو `X < X'` (وإلا سيتداخل النطاق `(X', S'.last)`).

`Case X == X'`:

ضع في إعتبارك `s`. نحن نعرف `s != X` لأنه من المُفترض أن `s` ليس سلف (ancestor) أو سليلًا (descendant) لـ `B`، و `X` هو سلف (ancestor) لـ `B`. نظرًا لأن `S'.last` سليل (descendant) لـ `B` ، فإن هذا يعني أن `s` أيضًا ليس سلفََا (ancestor) أو سليلًا (descendant) لـ `S'.last`. ثم لأن `S.last` ينحدر من `s`، فلا يُمكن أن يكون `S'.last` سلفََا (ancestor) أو سليلًا (descendant) لـ `S.last` أيضًا. هذا يعني `X != X'` حسب قواعد "الإقتطاع المُتفائل " (Optimistic Slashing).

`Case X < X'`:

هذا يعني بشكل بديهي أن `Vote(X, S)` تم إجراؤه "قبل" `Vote(X', S')`.

من الإفتراض أعلاه، `s + s.lockout > B > X'`. نظرًا لأن `s` ليس سلفََا (ancestor) لـ `X'`، فقد تم انتهاك عمليات الإغلاق عندما حاول المُدقّق (validator) إرسال تصويت تبديل إلى `X'` بإستخدام بعض التصويتات من النموذج `Vote(X', S'')`.

نظرًا لعدم صحة أي من هذه الحالات، يجب أن يكون الإفتراض غير صالح، وتم إثبات المُطالبة.

### Lemma 2:

تم إنهاء عملية إستدعاء `B'` على إنقسام أو شوكة (fork) مُختلفة عن الكتلة `B`. المُؤكدة "بتفاؤل".

`Claim`: لأي تصويت `Vote(X, S)` في مجموعة `Optimistic Votes`، يجب أن يكون `B' > X`

```text
                                +-------+
                                |       |
                       +--------+       +---------+
                       |        |       |         |
                       |        +-------+         |
                       |                          |
                       |                          |
                       |                          |
                       |                      +---+---+
                       |                      |       |
                       |                      |       |  X
                       |                      |       |
                       |                      +---+---+
                       |                          |
                       |                          |
                       |                      +---+---+
                       |                      |       |
                       |                      |       |  B (Optimistically Confirmed)
                       |                      |       |
                       |                      +---+---+
                       |                          |
                       |                          |
                       |                          |
                       |                      +---+---+
                       |                      |       |
                       |                      |       |  S.last
                       |                      |       |
                       |                      +-------+
                       |
                   +---+---+
                   |       |
    B'(Finalized)  |       |
                   |       |
                   +-------+
```

`Proof`: فليكن تصويت `Vote(X, S)` في مجموعة `Optimistic Votes`. ثم بحكم التعريف، بالنظر إلى الكتلة (block) "المُؤكدة بشكل مُتفائل"`B`, `X <= B <= S.last`.

نظرًا لأن `X` أصل `B`، و `B'` ليس أصلََا (parent) أو سلفََا (ancestor) لـ `B`، إذن:

- `B' != X`
- `B'` ليس أصلََا (parent) لـ `X`

فكر الآن في ما إذا كان `B'` < `X`:

`Case B' < X`: سنظهر أن هذا يعد إنتهاكًا لعمليات الإغلاق. مما سبق، نعلم أن `B'` ليس أصلََا (parent) لـ `X`. ثم نظرًا لأن `B'` تم تجذيره، و `B'` ليس أصلََا (parent) لـ `X`، فلا ينبغي أن يكون المدقق قادراً على التصويت على الفُتحة (Slot) الأعلى `X` التي لا تنحدر من `B'`.

### إثبات السلامة (Proof of Safety):

نهدف الآن إلى إظهار أن أحد المُدقّقين (validators) على الأقل في المجموعة `Optimistic Validators` إنتهك قاعدة الإقتطاع (slashing).

لاحظ أولاً أنه حتى يتم تجذير `B'`، يجب أن يكون هناك `> 2/3` حِصَّة (stake) تم التصويت عليها على `B'` أو سليل `B'`. بالنظر إلى أن مجموعة `Optimistic Validator` تحتوي أيضًا على `> 2/3` من المُدقّقين المُحَصِّصين (staked validators)، فإن ذلك يتبع أن `> 1/3` من المُدقّقين المُحَصِّصين:

- `B'` المُجذَّرة (rooted) أو سليل `B'`
- تم إرسال تصويت `v` بالشكل `Vote(X, S)` حيث `X <= B <= v.last`.

إجعل مجموعة `Delinquent` هي مجموعة المُدقّقين (validators) التي تفي بالمعايير المذكورة أعلاه.

بحكم التعريف، من أجل الوصول إلى الجذر `B'`، يجب أن يكون كل مُدقّق `V` في `Delinquent` قد قام ببعض "تبديل التصويت" (switching vote) من النموذج `Vote(X_v, S_v)` حيث:

- `S_v.last > B'`
- `S_v.last` هو سليل `B'`، لذلك لا يُمكن أن يكون سليل `B`
- نظرًا لأن `S_v.last` ليس سليلًا (descendant) لـ `B`، فلا يُمكن أن يكون `X_v` سليلًا (descendant) سلفََا أو (ancestor) لـ `B`.

بحكم التعريف، قام هذا المُدقّق (validator) التأخر `V` أيضًا بإجراء بعض الأصوات `Vote(X, S)` في `Optimistic Votes` حيث من خلال تعريف تلك المجموعة (تم التأكيد بتفاؤل `B`) ، نعرف `S.last >= B >= X`.

بحلول `Lemma 2`، نعرف `B' > X`، ومن فوق `S_v.last > B'`، ثم `S_v.last > X`. نظرًا لأن `X_v != X` (لا يُمكن أن يكون سليلًا (descendant) سلفََا أو (ancestor) لـ `B`من أعلى) ، ثم وفقًا لقواعد الإقتطاع (slashing)، فإننا نعرف `X_v > S.last`. من الأعلى، `S.last >= B >= X` لذلك لجميع "تبديل الأصوات" ، `X_v > B`.

الآن طلب كل "تبديل الأصوات" (switching vote) هذا في الوقت المُناسب، دع `V` ليكون المُدقّق (validator) في `Optimistic Validators` الذي قدم لأول مرة مثل "تبديل الأصوات" هذا `Vote(X', S')`، حيث `X' > B`. نحن نعلم أن مثل هذا المُدقّق (validator) موجود لأننا نعلم من الأعلى أن جميع المُدقّقين المُتأخرين يجب أن يكونوا قد أرسلوا مثل هذا التصويت، وأن المُدقّقين المتأخرين هم مجموعة فرعية من `Optimistic Validators`.

دع `Vote(X, S)` هو التصويت الفريد في `Optimistic Votes` الذي أدلى به المُدقّق `V` (بحد أقصى `S.last`).

إعطاء `Vote(X, S)` لأن `X' > B >= X`، ثم `X' > X`، لذلك من خلال قواعد "الإقتطاع المُتفائل"، `X' > S.last`.

من أجل إجراء مثل "تبديل التصويت (swtching vote) " هذا إلى `X'`، يجب أن يُظهر دليل التبديل `SP(Vote(X, S), Vote(X', S'))` أن `> 1/3` من الحِصَّة (stake) مُقفلة عند التصويت الأخير لهذا المُدقّق، `S.last`. إجمع هذا `>1/3` مع حقيقة أن مجموعة المُدقّقين (validators) في مجموعة `Optimistic Voters` تتكون من `> 2/3` من الحِصَّة (stake)، يعني أن مُدقّق مُتفائل (optimistic validator) واحدًا على الأقل `W` من مجموعة `Optimistic Voters` يجب أن يكون قد أرسل تصويتًا (تذكر تعريف إثبات التبديل)، `Vote(X_w, S_w)`ذلك تم تضمينه في إثبات تحويل المُدقّق `V` للفُتحة `X'`، حيث يحتوي `S_w` على فتحة `s` بحيث:

- `s` ليس سلفًا مُشتركًا (common ancestor) لـ `S.last` و `X'`
- `s` ليس سليلًا لـ `S.last`.
- `s' + s'.lockout > S.last`

نظرًا لأن `B` هو أحد أسلاف `S.last`، فإنه صحيح أيضًا إذن:

- `s` ليس سلفًا مُشتركًا (common ancestor) لـ `B` و `X'`
- `s' + s'.lockout > B`

التي تم تضمينها في دليل التبديل `V`.

الآن لأن `W` هو أيضًا عضو في `Optimistic Voters`، ثم بواسطة `Lemma 1` أعلاه، نظرًا للتصويت `W` ، `Vote(X_w, S_w)`، حيث يحتوي `S_w` على تصويت لفُتحة `s` حيث `s + s.lockout > B`، و `s` ليس سلفًا (ancestor) لـ `B`، ثم `X_w > B`.

نظرًا لأن المُدقّق `V` أدرج التصويت `Vote(X_w, S_w)` في دليله على التبديل إلى الفُتحة `X'`، فإن المُدقّق الضمني `V'` المُقدم للتصويت `Vote(X_w, S_w)` **before** أرسل المدقق `V` صوت التحويل للفتحة `X'`، `Vote(X', S')`.

لكن هذا تناقض لأننا إخترنا `Vote(X', S')` ليكون أول تصويت يتم إجراؤه بواسطة أي مُدقّق (validator) في مجموعة `Optimistic Voters` حيث لا يكون `X' > B` و `X'` سليلًا (descendant) لـ `B`.
