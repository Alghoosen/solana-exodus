---
title: Embedding the Move Language
---

## المُشكَل (Problem)

تُمكن Solana المُطورين من كتابة برامج على على الشبكة (on-chain) بلغات البرمجة ذات الأغراض العامة مثل اللغة البرمجية C أو Rust، لكن تلك البرامج تحتوي على آليات خاصة بـ Solana. على سبيل المثال، لا توجد شبكة أخرى تطلب من المُطورين إنشاء وحدة Rust بوظيفة `process_instruction(KeyedAccounts)`. كلما كان ذلك عمليًا، يجب أن توفر Solana لمُطوري التطبيقات المزيد من الخيارات المحمولة.

حتى وقت قريب، لم تقدم أي بلوكشاين شعبية لغة يُمكن أن تكشف قيمة وقت التشغيل [runtime](../validator/runtime.md) المُوازية والهائلة لـ Solana. عقود Solidity، على سبيل المثال، لا تفصل الإشارات إلى البيانات المُشتركة عن كود العقد (contract code)، وبالتالي تحتاج إلى تنفيذها بشكل مُتسلسل لضمان السلوك الحتمي. من الناحية العملية، نرى أن أكثر شبكات البلوكشاين المُستندة إلى EVM المُحسنة بقوة يبدو أنها تتفوق جميعها على على عدد 1200 مُعاملة في الثانية الواحدة (1200 TPS) - وهو جزء صغير مما يُمكن أن تفعله Solana. من ناحية أخرى، صمم مشروع Libra لغة برمجة على الشبكة (on-chain) تُسمى Move تكون أكثر مُلاءمة للتنفيذ المُتوازي 0. مثل وقت تشغيل Solana، تعتمد برامج Move على حسابات لجميع الحالات المُشتركة.

يتمثل أكبر إختلاف في التصميم بين وقت تشغيل Solana و Libra's Move VM في كيفية إدارة الإستدعاءات الآمنة بين الوحدات. إتخذت Solana نهج أنظمة التشغيل وإتخذت Libra منهج اللغة الخاصة بالمجال. في وقت التشغيل، يجب أن تعود الوحدة النمطية إلى وقت التشغيل للتأكد من أن وحدة المُتَّصِل (caller) لم تكتب إلى البيانات التي يمتلكها المُتَّصَل به (callee). بالمثل، عندما يكتمل المُتَّصَل به (callee)، يجب أن يعود مرة أخرى إلى وقت التشغيل للتأكد من أن المُتَّصَل به (callee) لم يكتب إلى البيانات التي يمتلكها المُتَّصِل (caller). من ناحية أخرى، تتضمن اللغة البرمجية Move نظام كتابة مُتقدمًا يسمح بتشغيل هذه الفحوصات بواسطة الـ bytecode الخاص به. نظرًا لأنه يُمكن التحقق من الـ bytecode الخاص بـ Move، يتم دفع تكلفة التحقق مرة واحدة فقط، في وقت تحميل الوحدة النمطية على الشبكة (on-chain). في وقت التشغيل، يتم دفع التكلفة في كل مرة تتقاطع فيها المُعاملة بين الوحدات النمطية. يشبه الإختلاف روحًا الفرق بين لغة مكتوبة ديناميكيًا مثل Python مُقابل لغة مكتوبة بشكل ثابت مثل Java. يسمح وقت تشغيل Solana بكتابة التطبيقات بلغات البرمجة ذات الأغراض العامة، ولكن هذا يأتي مع تكلفة عمليات التحقق من وقت التشغيل عند التنقل بين البرامج.

يحاول هذا الإقتراح تحديد طريقة لتضمين الـ VM الخاص بـ Move بحيث:

- لا تتطلب الإستدعاءات عبر الوحدة النمطية في Move وقت التشغيل

  فحوصات وقت التشغيل عبر البرامج (cross-program runtime checks)

- يمكن لبرامج اللغة البرمجية Move الإستفادة من الوظائف في برامج Solana الأخرى والعكس بالعكس

  بالعكس

- يتعرض التوازي في وقت تشغيل Solana إلى دفعات من Move و non-Move

  المُعاملات (Transactions)

## الحل المُقترح (Proposed Solution)

### قُم بنقل VM كمُحمّل Solana

يجب أن يتم تضمين VM اللغة البرمجية Move كمُحمّل Solana تحت المُعرف `MOVE_PROGRAM_ID`، بحيث يُمكن تمييز وحدات Move على أنها قابلة للتنفيذ `executable` مع الـ VM على أنها المالك `owner`. سيسمح ذلك للوحدات النمطية بتحميل تبعيات الوحدة النمطية، فضلاً عن السماح بالتنفيذ المُتوازي للنصوص النصية (scripts) الللغة البرمجية Move.

يجب على جميع حسابات البيانات المملوكة لوحدات Move تعيين أصحابها على أداة التحميل، `MOVE_PROGRAM_ID`. نظرًا لأن وحدات Move تُغلف بيانات حساباتها بنفس الطريقة التي تُغلف بها برامج Solana بياناتها، يجب تضمين مالك وحدة Move في بيانات الحساب. يمنح وقت التشغيل حق الوصول للكتابة إلى الـ VM الخاص بـ Move، ويمنح Move حق الوصول إلى حسابات الوحدة.

### التفاعل مع برامج Solana

لإستدعاء التعليمات في البرامج غير المُتحركة، ستحتاج Solana إلى تمديد الـ VM الخاص بـ Move بنظام الإستدعاء `process_instruction()`. ستعمل تماما مثل `process_instruction()` برامج Rust BPF.
