---
title: التخزين المُستمر للحساب (Persistent Account Storage)
---

## التخزين المُستمر للحساب (Persistent Account Storage)

تُمثل مجموعة الحسابات الحالة المحسوبة الحالية لجميع المُعاملات التي تمت مُعالجتها بواسطة المُدقّق (validator). كل المُدقّق (validator) يحتاج إلى الحفاظ على هذه المجموعة بأكملها. تُمثل كل كتلة (block) تقترحها الشبكة تغييرًا في هذه المجموعة، وبما أن كل كتلة (block) هي نقطة تراجع مُحتملة ، يجب أن تكون التغييرات قابلة للعكس.

التخزين الدائم مثل NVMEs أرخص 20 إلى 40 مرة من DDR. تكمن مُشكلة التخزين المُستمر في أن أداء الكتابة والقراءة أبطأ بكثير من DDR ويجب توخي الحذر في كيفية قراءة البيانات أو الكتابة إليها. يُمكن تقسيم كل من عمليات القراءة والكتابة بين مُحركات أقراص تخزين مُتعددة والوصول إليها بشكل متوازٍ. يقترح هذا التصميم بنية بيانات تسمح بالقراءات والكتابات المُتزامنة للتخزين. يتم تحسين عمليات الكتابة بإستخدام بنية بيانات AppendVec، والتي تسمح لكاتب واحد بالإلحاق مع السماح بالوصول إلى العديد من أجهزة القراءة المُتزامنة. يحتفظ فهرس الحسابات بمُؤشر إلى النقطة التي تم فيها إلحاق الحساب بكل إنقسام أو شوكة (fork)، وبالتالي إزالة الحاجة إلى نقاط تفتيش صريحة للحالة.

## إلحاق النواقل (AppendVec)

إلحاق النواقل (AppendVec) هو هيكل بيانات يسمح بالقراءات العشوائية المُتزامنة مع كاتب إلحاق واحد فقط. تتطلب زيادة سعة إلحاق النواقل (AppendVec) أو تغيير حجمها وصولاً خاصًا. يتم تنفيذ ذلك بإزاحة ذرية `offset`، والتي يتم تحديثها في نهاية مُلحق مُكتمل.

الذاكرة الأساسية لإلحاق النواقل (AppendVec) هي ملف ذاكرة مُعين (memory-mapped file). تسمح ملفات الذاكرة المُعينة (memory-mapped files) بالوصول العشوائي السريع ويتم التعامل مع الترحيل بواسطة نظام التشغيل.

## فهرس الحساب (Account Index)

تم تصميم فهرس الحساب لدعم فهرس واحد لجميع الحسابات المُتشعبة حاليًا.

```text
type AppendVecId = usize;

type Fork = u64;

struct AccountMap(Hashmap<Fork, (AppendVecId, u64)>);

type AccountIndex = HashMap<Pubkey, AccountMap>;
```

الفهرس عبارة عن خريطة حساب مفتاتيح عمومية (pubkeys) لخريطة الإنقسامات أو الشوكات (Forks) وموقع بيانات الحساب في إلحاق النواقل (AppendVec). للحصول على نسخة حساب لإنقسام أو شوكة (fork):

```text
/// Load the account for the pubkey.
/// This function will load the account from the specified fork, falling back to the fork's parents
/// * fork - a virtual Accounts instance, keyed by Fork.  Accounts keep track of their parents with Forks,
///       the persistent store
/// * pubkey - The Account's public key.
pub fn load_slow(&self, id: Fork, pubkey: &Pubkey) -> Option<&Account>
```

تتم القراءة عن طريق الإشارة إلى موقع مُعين للذاكرة في `AppendVecId` عند الإزاحة المُخزنة. يُمكن إرجاع المرجع بدون نسخة.

### إنقسامات أو شوكات الجذر (Root Forks)

يُحدد [Tower BFT](tower-bft.md) في النهاية إنقسام أو شوكة (fork) كشوكة جذر (root fork) ويتم سحق الإنقسام أو الشوكة. لا يمكن التراجع عن الإنقسام أو الشوكة الجذر / المسحوقة.

عندما يتم سحق الإنقسام أو الشوكة (fork)، يتم سحب جميع الحسابات الموجودة في العناصر الرئيسية غير الموجودة بالفعل في الإنقسام أو الشوكة (fork) إلى أعلى نقطة عن طريق تحديث الفهارس. الحسابات ذات الرصيد الصفري في الإنقسام أو الشوكة (fork) المسحوقة تتم إزالتها من الإنقسام أو الشوكة (fork) عن طريق تحديث الفهارس.

يُمكن أن يتم جمع الحساب الغير مرغوب فيه _garbage-collected_ عندما يجعله السحق غير قابل للوصول.

هناك ثلاثة خيارات مُمكنة:

- الحفاظ على مجموعة تجزئة (HashSet) من الإنقسامات أو الشوكات الجذرية (root forks). من المُتوقع أن يتم إنشاء واحد كل ثانية. الشجرة (tree) بأكملها يُمكن جمعها في وقت لاحق. بدلاً من ذلك، إذا إحتفظت كل إنقسام أو شوكة (fork) بعدد مرجعي للحسابات، فقد تحدث عملية جمع البيانات المُهملة في أي وقت يتم فيه تحديث موقع الفهرس.
- إزالة أي إنقسامات أو شوكات (forks) منبوذة من الفهرس. يُمكن إعتبار أي إنقسامات أو شوكات (forks) مُتبقية أقل في العدد من الجذر على أنها جذر.
- مسح الفهرس، نقل أي جذور قديمة إلى جذور جديدة. أي إنقسام أو شوكة (fork) مُتبقية أقل من الجذر الجديد يُمكن حذفها لاحقاً.

## كتابة مُلحقة فقط (Append-only Writes)

تحدث جميع تحديثات الحسابات كتحديثات مُلحقة فقط (append-only updates). لكل تحديث للحساب، يتم تخزين إصدار جديد في إلحاق النواقل (AppendVec).

من المُمكن تحسين التحديثات داخل إنقسام أو شوكة (fork) واحدة عن طريق إرجاع مرجع قابل للتغيير إلى حساب مُخزن بالفعل في إنقسام أو شوكة (fork). يتتبع البنك بالفعل الوصول المُتزامن للحسابات ويضمن أن الكتابة إلى إنقسام أو شوكة (fork) حساب مُعين لن تكون مُتزامنة مع قراءة إلى حساب في ذلك الإنقسام أو الشوكة (fork). لدعم هذه العملية، يجب على إلحاق النواقل (AppendVec) تنفيذ هذه الوظيفة:

```text
fn get_mut(&self, index: u64) -> &mut T;
```

تسمح واجهة برمجة التطبيقات (API) هذه بالوصول المُتزامن المُتغير إلى منطقة الذاكرة في `index`. وهي تعتمد على البنك لضمان الوصول الحصري إلى هذا الفهرس.

## جمع البيانات المُهملة (Garbage collection)

عندما يتم تحديث الحسابات ، فإنها تنتقل إلى نهاية إلحاق النواقل (AppendVec). بمجرد نفاد السعة، يُمكن إنشاء إلحاق نواقل (AppendVec) جديد ويُمكن تخزين التحديثات هناك. في النهاية ستختفي المراجع إلى إلحاق النواقل (AppendVec) الأقدم لأنه تم تحديث جميع الحسابات، ويُمكن حذف إلحاق النواقل (AppendVec) القديم.

لتسريع هذه العملية، من المُمكن نقل الحسابات التي لم يتم تحديثها مؤخرًا إلى مُقدمة إلحاق النواقل (AppendVec) الجديد. يُمكن إجراء هذا النوع من جمع البيانات المُهملة دون الحاجة إلى تأمينات حصرية لأي من هياكل البيانات بإستثناء تحديث الفهرس.

يتمثل التنفيذ الأولي لجمع البيانات المُهملة (garbage collection) في أنه بمجرد أن تُصبح جميع الحسابات في إلحاق النواقل (AppendVec) إصدارات قديمة، يتم إعادة إستخدامها. لا يتم تحديث الحسابات أو نقلها بمُجرد إلحاقها.

## إستعادة الفهرس (Index Recovery)

تتمتع كل عملية جزئية للبنك (bank thread) بحق وصول خاص إلى الحسابات أثناء الإلحاق، نظرًا لأنه لا يمكن تحرير قفل الحسابات حتى يتم الإلتزام بالبيانات. لكن لا يوجد ترتيب صريح لعمليات الكتابة بين ملفات إلحاق النواقل (AppendVec) المُنفصلة. لإنشاء ترتيب، يحتفظ الفهرس بعداد نسخة الكتابة الذرية. يُسجل كل إلحاق بإلحاق النواقل (AppendVec) رقم إصدار كتابة الفهرس لذلك الإلحاق في المُدخل (entry) الخاص بالحساب في إلحاق النواقل (AppendVec).

لإستعادة الفهرس، يُمكن قراءة جميع ملفات إلحاق النواقل (AppendVec) بأي ترتيب، ويجب تخزين أحدث إصدار للكتابة لكل إنقسام أو شوكة (fork) في الفهرس.

## لقطات (Snapshots)

لأخذ لقطة (snapshot)، يجب مسح الملفات الأساسية المُعينة للذاكرة في إلحاق النواقل (AppendVec) إلى القرص. يُمكن كتابة الفهرس على القرص أيضا.

## الأداء (Performance)

- الكتابات المُلحقة فقط (Append-only Writes) سريعة. تسمح مُحركات الأقراص SSDs و NVME، بالإضافة إلى جميع هياكل بيانات kernel على مُستوى نظام التشغيل، بتشغيل المُلحقات بالسرعة التي يسمح بها عرض النطاق الترددي (bandwidth) لـ PCI أو NVMe \(2,700 MB/الثانية\).
- كل إعادة تشغيل وعملية جزئية للبنك (bank thread) تُكتب بشكل مُتزامن إلى إلحاق النواقل (AppendVec) الخاص به.
- يُمكن إستضافة كل إلحاق النواقل (AppendVec) على NVMe مُنفصل.
- كل إعادة تشغيل وعملية جزئية للبنك (banking thread) لها وصول قراءة مُتزامن لجميع مُلحقات النواقل (AppendVecs) دون حظر عمليات الكتابة.
- يتطلب الفهرس قفل كتابة خاص بالكتابة. أداء عملية جزئية مُفردة (Single-thread) لتحديثات خريطة التجزئة (HashMap) هو في حدود 10 أمتار في الثانية الواحدة.
- يجب أن تستخدم المراحل المصرفية وإعادة التشغيل 32 عملية جزئية (threads) لكل NVMe. تتمتع NVMes بأداء مثالي مع 32 قارئًا أو كاتبًا مُتزامنًا.
