---
title: عملية إدارة التحليلات والذكاء التجاري (ABI) الخاص بـ Solana
---

تقترح هذه الوثيقة عملية إدارة الـ ABI الخاص بـ Solana. عملية إدارة الـ ABI هي مُمارسة هندسية وإطار تقني داعم لتجنب إدخال تغييرات ABI غير مُتوافقة وغير مقصودة.

# المُشكل (Problem)

يتم تعريف الـ ABI حاليًا (الواجهة الثنائية للفُتحة) بشكل ضمني فقط من خلال التنفيذ وتتطلب عينًا شديدة الحذر لمُلاحظة التغييرات الفاصلة. هذا يجعل من الصعب للغاية ترقية البرنامج على مجموعة موجودة دون إعادة تشغيل دفتر الأستاذ (ledger).

# المُتطلبات والأهداف (Requirements and objectives)

- يُمكن إكتشاف تغييرات الـ ABI غير المقصودة على أنها حالات فشل CI ميكانيكيًا.
- يجب أن يكون التطبيق الأحدث قادرًا على مُعالجة البيانات الأقدم (منذ التكوين) بمُجرد الإنتقال إلى الشبكة الرئيسية (mainnet).
- الهدف من هذا الإقتراح هو حماية الـ ABI مع الحفاظ على التطور السريع إلى حد ما من خلال إختيار عملية ميكانيكية بدلاً من عملية تدقيق طويلة جدًا يقودها الإنسان.
- بمجرد التوقيع بالتشفير، يجب أن تكون البيانات الثنائية الكبيرة مُتطابقة، لذلك لا يمكن تحديث تنسيق البيانات في المكان بغض النظر عن الوارد والصادر من النظام عبر الأنترنات. بالنظر أيضًا إلى الحجم الهائل للمُعاملات التي نهدف إلى مُعالجتها، فإن التحديث الموضعي بأثر رجعي غير مرغوب فيه في أحسن الأحوال.

# الحل (Solution)

بدلاً من العناية الواجبة بالعين البشرية الطبيعية، والتي ينبغي إفتراض أنها تفشل بإنتظام، نحتاج إلى ضمان منهجي بعدم كسر الفُتحة (cluster) عند تغيير كود المصدر.

لهذا الغرض، نُقدم آلية لتمييز كل الأشياء المُتعلقة بالـ ABI في كود المصدر (`struct`s, `enum`s) بالسمة الجديدة `#[frozen_abi]` attribute. هذا يأخذ قيمة خلاصة مُشفرة ثابتة مُشتقة من أنواع مجالاتها عبر `ser::Serialize`. تقوم السمة تلقائيًا بإنشاء إختبار وحدة لمُحاولة إكتشاف أي تغييرات غير مُصرح بها للأشياء ذات الصلة بالـ ABI.

مع ذلك، لا يمكن أن يكون الإكتشاف كاملاً؛ بغض النظر عن مدى صعوبة تحليل شفرة المصدر بشكل ثابت، لا يزال من المُمكن كسر الـ ABI. على سبيل المثال، لا يشمل ذلك `derive` المكتوب بخط اليد `ser::Serialize`، وتغييرات تطبيق المكتبة الأساسية (على سبيل المثال `bincode`)، وإختلافات بنية وحدة المُعالجة المركزية. يعد إكتشاف حالات عدم توافق الـ ABI المُحتملة خارج نطاق إدارة الـ ABI.

# التعريفات (Definitions)

عنصر / نوع الـ ABI: أنواع مختلفة لإستخدامها في التسلسل، والتي تشتمل مُجتمعة على الـ ABI بالكامل لأي من مُكمونات النظام. على سبيل المثال، تتضمن هذه الأنواع `struct`s و `enum`s.

مُلخص عنصر الـ ABI: بعض التجزئة (hash) الثابتة المُشتقة من معلومات نوع حقول عنصر الـ ABI.

# مثال (Example)

```patch
+#[frozen_abi(digest="eXSMM7b89VY72V...")]
 #[derive(Serialize, Default, Deserialize, Debug, PartialEq, Eq, Clone)]
 pub struct Vote {
     /// A stack of votes starting with the oldest vote
     pub slots: Vec<Slot>,
     /// signature of the bank's state at the last slot
     pub hash: Hash,
 }
```

# سير عمل المطور (Developer's workflow)

لمعرفة المُلخص لعناصر الـ ABI الجديدة، يمكن للمُطورين إضافة `Glory_abi` بقيمة مُلخص عشوائي وتشغيل إختبارات الوحدة وإستبدالها بالمُلخص الصحيح من رسالة خطأ إختبار التأكيد.

بشكل عام، بمجرد إضافة `frozen_abi` ونشر التغيير في قناة الإصدار الثابت، يجب ألا يتغير مُلخصه أبدًا. إذا كان هذا التغيير مطلوبًا، فيجب علينا إختيار تحديد هيكل `struct` جديد مثل `FooV1`. يجب التعامل مع تدفق التحرير الخاص مثل الإنقسامات أو الشوكات (forks) الصلبة.

# ملاحظات التنفيذ (Implementation remarks)

نحن نستخدم درجة مُعينة من الماكينات الكلية لإنشاء إختبارات الوحدة تلقائيًا وحساب مُلخص من عناصر الـ ABI. يُمكن تحقيق ذلك من خلال الإستخدام الذكي لـ `serde::Serialize` (`[1]`) و `any::type_name` (`[2]`). لسابقة تنفيذ مُشابه، يُمكن أن يكون `ink` من تكنلوجيات Parity `[3]` معلوماتية.

# تفاصيل التنفيذ (Implementation details)

هدف التنفيذ هو إكتشاف تغييرات الـ ABI غير المقصودة تلقائيًا قدر الإمكان. تحقيقا لهذه الغاية، يتم حساب مُلخص معلومات الـ ABI الهيكلية بدقة وإستقرار بأفضل جهد.

عند تشغيل فحص ملخص الـ ABI ، فإنه يحسب بشكل ديناميكي ملخص الـ ABI عن طريق هضم الـ ABI بشكل مُتكرر لحقول عنصر الـ ABI، عن طريق إعادة إستخدام وظيفة التسلسل `serde` والتخصص الكلي والعام لـ proc. بعد ذلك، تُؤكد علامة التحقق `assert!` أن قيمة المُلخص النهائية لها مُطابقة لما تم تحديده في السمة `frozen_abi`.

لإدراك ذلك، يقوم بإنشاء مثال للنوع ومثيل `Serializer` مُخصص لـ `serde` لإجتياز حقوله بشكل مُتكرر كما لو كان يتم إجراء تسلسل للمثال بشكل حقيقي. يجب أن يتم هذا العبور عبر `serde` لإلتقاط أنواع البيانات التي سيتم تسلسلها فعليًا بواسطة `serde`، حتى مع الأخذ في الإعتبار تطبيقات السمات المُخصصة بخلاف `derive` و `Serialize`.

# عملية الهضم الخاص بالـ ABI أو The ABI digesting process

هذا الجزء مُعقد بعض الشيء. هناك ثلاثة أجزاء مُترابطة: `AbiDigester` ، `AbiExample` و `AbiEnumVisitor`.

أولاً، يُنشئ الإختبار الذي تم إنشاؤه مثالاً للنوع المهضوم بسمة تسمى `AbiExample`، والتي يجب تنفيذها لجميع الأنواع المهضومة مثل `Serialize` وإرجاع `Self` مثل سمة `Default`. عادةً ما يتم توفيره من خلال تخصص السمات العامة لمُعظم الأنواع الشائعة. كما يُمكن إشتقاق `derive` لـ `Struct` و `enum` ويُمكن كتابتها يدويًا إذا لزم الأمر.

الـ `Serializer` المُخصص يُسمى `AbiDigester`. عندما يتم إستدعاؤه بواسطة `serde` لإجراء تسلسل لبعض البيانات، فإنه يجمع معلومات الـ ABI بشكل مُتكرر قدر الإمكان. يتم تحديث حالة `AbiDigester` الداخلية لمُلخص الـ ABI بشكل تفاضلي إعتمادًا على نوع البيانات. يتم إعادة توجيه هذا المنطق على وجه التحديد من خلال سمة تُسمى `AbiEnumVisitor` لكل نوع `enum`. كما يوحي الإسم، ليست هناك حاجة لتنفيذ `AbiEnumVisitor` لأنواع أخرى.

لتلخيص هذا التفاعل، يُعالج `serde` تدفق التحكم في التسلسل العودي جنبًا إلى جنب مع `AbiDigester`. تستخدم نقطة الدخول الأولية في الإختبارات والطفل `AbiDigester` يستخدم `AbiExample` بشكل مُتكرر لإنشاء مثال للرسم البياني الهرمي للكائن. `AbiDigester` يستخدم `AbiEnumVisitor` للإستعلام عن معلومات الـ ABI الفعلية بإستخدام العينة المُنشأة.

لا يكفي `Default` لـ `AbiExample`. مجموعة متنوعة `:: default ()` فارغة، مع ذلك، نريد إستيعابها بالعناصر الفعلية. لا يمكن تحقيق هضم الـ ABI إلا بإستخدام `AbiEnumVisitor`. `AbiExample` مطلوب نظرًا لضرورة وجود مثيل فعلي من النوع لإجتياز البيانات فعليًا عبر `serde`.

من ناحية أخرى، لا يمكن أيضا إجراء هضم الـ ABI بإستخدام `AbiExample` فقط. `AbiEnumVisitor` مطلوب لأنه لا يمكن إجتياز جميع مُتغيرات `enum` فقط بإستخدام مُتغير واحد منه كمثال الـ ABI.

معلومات قابلة للهضم (Digestable information):

- إسم نوع rust
- إسم نوع البيانات `serde`
- جميع الحقول في `struct`
- جميع المُتغيرات في `enum`
- `struct`: عادي (`struct {...}`) ونمط tuple-style (`struct(...)`)
- `enum`: المُتغيرات العادية وأنماط `struct` و `tuple`.
- السماة: `serde(serialize_with=...)` و `serde(skip)`

معلومات غير قابلة للهضم (Not digestable information):

- أي مسار شفرة مُخَصَّص للتسلسل لم يتأثر بالعينة المُقدمة بواسطة `AbiExample`. (غير مُمكن من الناحية التقنية)
- المُعلِّمات (يجب أن يكون نوعًا ملموسًا؛ يستخدم `frozen_abi` في الأسماء المُستعارة للنوع الملموس)

# المراجع (References)

1. [(De)Serialization with type info · Issue #1095 · serde-rs/serde](https://github.com/serde-rs/serde/issues/1095#issuecomment-345483479)
2. [`std::any::type_name` - Rust](https://doc.rust-lang.org/std/any/fn.type_name.html)
3. [Parity's ink to write smart contracts](https://github.com/paritytech/ink)
