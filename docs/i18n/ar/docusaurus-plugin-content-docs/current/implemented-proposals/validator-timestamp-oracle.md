---
title: أوراكل الختم الزمني للمُدقّق (Validator Timestamp Oracle)
---

يحتاج مُستخدمو Solana من الجهات الخارجية أحيانًا إلى معرفة الوقت الفعلي الذي تم فيه إنتاج كتلة (block)، بشكل عام لتلبية مُتطلبات الإمتثال للمُدقّقين (validators) الخارجيين أو تطبيق القانون. يصف هذا الإقتراح أوراكل الختم الزمني (Timestamp) للمُدقّق (validators) الذي من شأنه أن يسمح لمجموعة Solana بتلبية هذه الحاجة.

المُخطط العام للتنفيذ المُقترح كما يلي:

- يُسجل كل مُدقّق (validator) على فترات مُنتظمة وقته الملحوظ لفُتحة (slot) معروفة على على الشبكة (On-Chain) (عبر ختم زمني مُضاف إلى فُتحة تصويت)
- يُمكن للعميل طلب وقت الكتلة (block time) لكتلة جذر بإستخدام طريقة RPC بالأمر البرمجي `getBlockTime` للحصول على وقت الكتلة. عندما يطلب العميل ختما زمنيا (Timestamp) للكتلة N:

  1. يُحدد المُدقّق (validator) ختما زمنيا (Timestamp) "للمجموعة" (cluster) لفُتحة (slot) ذات ختم زمني حديث قبل الكتلة N من خلال مُراقبة جميع تعليمات التصويت ذات الختم الزمني المُسجلة في دفتر الأستاذ (ledger) الذي يُشير إلى تلك الفُتحة (slot)، وتحديد مُتوسط الختم الزمني المُرجح بالحِصَّة (stake-weighted).

  2. ثم يتم إستخدام مُتوسط الختم الزمني (Timestamp) الأخير هذا لحساب الختم الزمني للكتلة N بإستخدام مُدة الفُتحة (slot) المُحددة للمجموعة (cluster)

المُتطلبات (Requirements):

- يجب أن يأتي أي مُدقّق (validator) يعيد تشغيل دفتر الأستاذ (ledger) في المُستقبل في نفس الوقت لكل كتلة (block) منذ مرحلة التكوين (Genesis)
- يجب ألا تنحرف أوقات الكتل (block times) المُقدرة أكثر من ساعة أو نحو ذلك قبل الإنتقال إلى بيانات (oracle) العالم الحقيقي
- لا يتم التحكم في أوقات الكتل (block times) بواسطة أوراكل (oracle) مركزي واحد، ولكن يعتمد بشكل مثالي على وظيفة تستخدم مُدخلات (entries) من جميع المُدقّقين (validators)
- يجب أن يحتفظ كل مُدقّق (validator) بأوراكل (oracle) ختم زمني (Timestamp)

يمكن أن يُوفر التطبيق نفسه تقدير ختم زمني (Timestamp) لكتلة (block) لم يتم تجذيرها بعد. مع ذلك، نظرًا لأن أحدث فُتحة (slot) ذات ختم زمني (Timestamp) قد يتم تجذيرها (rooted) أو عدم تجذيرها حتى الآن، فإن هذا الختم الزمني سيكون غير مُستقر (من المُحتمل أن يفشل في المُتطلبات 1). سيستهدف التنفيذ الأولي الكتل ذات الجذر (rooted blocks)، ولكن إذا كانت هناك حالة إستخدام للختم الزمني (Timestamp) للكتلة الحديثة (recent-block)، فسيكون من التافه إضافة RPC apis في المُستقبل.

## وقت التسجيل (Recording Time)

على فترات مُنتظمة أثناء التصويت على فُتحة (slot) مُعينة، يُسجل كل مُدقّق (validator) وقته الملحوظ من خلال تضمين ختم زمني (Timestamp) في تقديم تعليمات التصويت. الفُتحة (slot) المُقابلة للختم الزمني (Timestamp) هي أحدث فُتحة (Slot) في ناقل التصويت (`Vote::slots.iter().max()`). يتم توقيعه من قبل زوج مفاتيح (keypair) هوية المُدقّقين (validators) كالتصويت المُعتاد. من أجل تمكين هذا التقرير، يجب توسيع هيكل التصويت ليشمل حقل الختم الزمني، `timestamp: Option<UnixTimestamp>`، والذي سيتم تعيينه إلى `None` في مُعظم الأصوات.

إعتبارًا من https://github.com/solana-labs/solana/pull/10630 ، يُقدم المدقّقون (validators) ختما زمنيا (Timestamp) لكل تصويت. يتيح ذلك تنفيذ خدمة التخزين المُؤقت لوقت الكتلة (block time) التي تسمح للعُقد (nodes) بحساب الختم الزمني (Timestamp) المُقدر فورًا بعد تجذير الكتلة (block)، وتخزين هذه القيمة مُؤقتًا في مخزن الكتلة (blockstore). يُوفر هذا بيانات ثابتة وإستعلامات سريعة، مع إستمرار تلبية المُتطلبات 1) أعلاه.

### حسابات التصويت (Vote Accounts)

سيحتفظ حساب تصويت المُدقّق (validator) بآخر ختم زمني (Timestamp) للفُتحة (slot) في VoteState.

### برنامج التصويت (Vote Program)

يحتاج برنامج التصويت على الشبكة (on-chain) إلى أن يتم تمديده لمُعالجة الختم الزمني (Timestamp) المُرسل مع تعليمات التصويت من المُدقّقين (validators). بالإضافة إلى وظيفة process_vote الحالية (بما في ذلك تحميل حساب التصويت الصحيح والتحقق من أن المُوقّع أو signer على المُعاملة هو المُدقّق المُتوقع)، تحتاج هذه العملية إلى مُقارنة الختم الزمني (Timestamp) والفُتحة (slot) المُقابلة للقيم المُخزنة حاليًا للتحقق من أن كلاهما يتزايد بشكل رتي ، وتخزين الفُتحة والختم الزمني الجديد في الحساب.

## حساب مُتوسط الختم الزمني المُرجح بالحِصَّة (Calculating Stake-Weighted Median Timestamp)

لحساب الختم الزمني (Timestamp) المُقدر لكتلة (block) مُعينة، يحتاج المُدقّق (validator) أولاً إلى تحديد أحدث فُتحة (slot) مختومة زمنيا (timestamped):

```text
let timestamp_slot = floor(current_slot / timestamp_interval);
```

ثم يحتاج المُدقّق (validator) إلى جمع جميع مُعاملات الأصوات ذات الختم الزمني (Vote WithTimestamp) من دفتر الأستاذ (ledger) الذي يُشير إلى تلك الفُتحة (slot)، بإستخدام `Blockstore::get_slot_entries()`. نظرًا لأن هذه المُعاملات قد تستغرق بعض الوقت للوصول إلى القائد (leader) ومُعالجتها، يحتاج المُدقّق (validator) إلى فحص العديد من الكتل (blocks) المُكتملة بعد الختم الزمني للفُتحة (timestamp_slot) للحصول على مجموعة معقولة من الأختام الزمنية (Timestamps). يجب ضبط العدد الدقيق للفُتحات (Slots): ستُتيح المزيد من الفُتحات مُشاركة أكبر للمجموعة (cluster) والمزيد من نقاط بيانات الختم الزمني (Timestamp)؛ يُؤدي عدد أقل من الفُتحات (Slots) إلى تسريع المُدة التي تستغرقها تصفية الأختام الزمنية.

من هذه المجموعة من المُعاملات، يقوم المُدقّق (validator) بحساب مُتوسط الختم الزمني (Timestamp) المُرجح بالحِصَّة (stake-weighted)، والإحالة المرجعية إلى حِصص الفترة من `staking_utils::staked_nodes_at_epoch()`.

يجب على أي مُدقّق (validator) يُعيد تشغيل دفتر الأستاذ (ledger) أن يشتق نفس مُتوسط الختم الزمني (Timestamp) المُرجح بالحِصَّة (stake-weighted) من خلال مُعالجة مُعاملات الختم الزمني من نفس عدد الفُتحات (Slots).

## حساب الوقت المُقدر لكتلة مُعينة (Calculating Estimated Time for a Particular Block)

بمجرد حساب مُتوسط الختم الزمني (Timestamp) لفترة زمنية معروفة، من السهل حساب الختم الزمني المُقدر للكتلة (block) اللاحقة N:

```text
let block_n_timestamp = mean_timestamp + (block_n_slot_offset * slot_duration);
```

حيث `block_n_slot_offset` هو الفرق بين فُتحة (Slot) الكتلة N و timestamp_slot، و `slot_duration` مُشتق من `slots_per_year` للمجموعة المُخزنة في كل بنك
