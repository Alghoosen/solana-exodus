---
title: عملية التناوب على لعب دور القائد أو الleader
---

تتوقع المجموعة أو الcluster في أي لحظة أن يقوم مدقق أو validator واحد فقط بإنتاج مدخالات دفتر الأستاذ أو ledger. بوجود قائد أو leader واحد فقط في كل مرة، يستطيع جميع المدققين أو validators إعادة عرض نسخ متطابقة من دفتر الأستاذ أو ledger. بيد أن العيب الذي تعانيه عملية وجود قائد أو leader واحد فقط في كل مرة هو أن القائد الخبيث قادر على فرض الرقابة على الأصوات والمعاملات. بما أنه لا يمكن التمييز بين الرقابة والشبكة التي تسقط الحزم أو الpackets فإن المجموعة أو الcluster لا يمكنها ببساطة أن تنتخب عقدة أو nods واحدة للقيام بدور القائد أو الleader إلى ما لا نهاية. بدلا من ذلك، تقلل المجموعة أو الcluster من نفوذ القائد أو الleader الخبيث عن طريق تدوير أو تبديل عملية تناوب تولي تولي القيادة على العقد أو nodes.

كل مدقق أو validator يختار القائد أو الleader المتوقع بإستخدام نفس الخوارزمية الموضحة أدناه. عندما يتلقى المدقق أو validator مُدخل دفتر الأستاذ أو ledger الموقع الجديد، يمكن أن يكون من المُؤكد أن القائد أو الleader المتوقع قد أنتج مُدخلا. ترتيب الفُتحات (Slots) التي يتم تعيين كل قائد (leader) لها تُسمى جدول القادة _leader schedule_.

## جدولة عملية التناوب على لعب دور القائد (leader)

يرفض المُدقّق (validator) الكتل (blocks) التي لم يتم توقيعها من قبل قائد الفُتحة _slot leader_. قائمة هويات جميع قادة الفُتحات (slot leaders) تُسمى جدول القائد _leader schedule_. يُعاد حساب جدول عملية التناوب على لعب دور القائد (leader) بطريقة محلية ودورية. تقوم بتعيين قادة الفُتحات (slot leaders) لمدة من الوقت تُسمى فترة _epoch_. يجب حساب الجدول قبل وقت طويل من فترة تعيينه للفُتحات (Slots)، بحيث يتم الإنتهاء من حالة دفتر الأستاذ (ledger) الذي يستخدمه لحساب الجدول. هذه المدة تُسمى جدول القائد المُعَوِّض _leader schedule offset_. تُحدد Solana قائمة المُعَوِّضين على مدة الفُتحات (Slots) حتى الفترة (epoch) التالية. أي أن الجدول الزمني للقائد (leader) لفترة (epoch) ما يُحسب من حالة دفتر الأستاذ (ledger) في بداية الفترة (epoch) السابقة. يتسم التعويض عن فترة (epoch) واحدة إعتباطيا إلى حد ما ويُفترض أنه طويل بما فيه الكفاية بحيث يكون جميع المُدقّقين (validators) قد أكملوا حالة دفتر الأستاذ (ledger) قبل وضع الجدول الزمني التالي. قد تختار مجموعة (cluster) من المجموعات لتقصير فترة التعويض لتقليص الوقت بين التغييرات المُتعلقة بالحِصَّة (stake) وتحديثات الجدول الزمني للقائدين (leaders).

بينما التشغيل بدون تقسيم يدوم أطول من فترة (epoch) واحدة، لا يلزم إنشاء الجدول الزمني إلا عندما يتجاوز جذر الإنقسام أو الشوكة (fork) حدود الفترة (epoch). بما أن الجدول الزمني للفترة (epoch) اللاحقة، فإن أي حِصَص (stakes) جديدة يلتزم بها في الإنقسام أو الشوكة (fork) الأصلية لن تكون نشطة إلا في الفترة (epoch) التالية. الكتلة (block) المُستخدمة لإنشاء الجدول الزمني للقائد (leader schedule) هي أول كتلة (block) تعبر حدود الفترة (epoch).

بدون تقسيم يدوم أكثر من فترة (epoch)، ستعمل المجموعة (cluster) على النحو التالي:

1. يقوم المُدقّق (validator) بتحديث جذر الإنقسام أو الشوكة (fork) الخاصة به بإستمرار أثناء تصويته.
2. يقوم المُدقّق (validator) بتحديث الجدول الزمني لقائده (leader) في كل مرة يعبر إرتفاع (height) الفُتحة (Slot) حدود الفترة (epoch).

على سبيل المثال:

مُدة الفترة (epoch) هي 100 فُتحة (Slots). يتم تحديث جذر الإنقسام أو الشوكة (fork) من الإنقسام أو الشوكة المحسوبة عند الإرتفاع 99 للفُتحة (Slot) إلى الإنقسام أو الشوكة المحسوبة عند الإرتفاع 102 للفُتحة. الإنقسام أو الشوكة (fork) مع فُتحات (Slots) في الإرتفاع 100، 101 تم تخطيها بسبب الفشل. يتم حساب الجدول الزمني الجديد للقائد (leader schedule) بإستخدام الإنقسام أو الشوكة (fork) عند إرتفاع الفُتحة (Slot) إلى 102. وهو نشط من الفُتحة (Slot) عدد 200 حتى يتم تحديثه مرة أخرى.

لا يُمكن أن يوجد أي تضارب لأن كل مُدقّق (validator) يُصوت مع المجموعة (cluster) تخطى 100 و 101 عندما يتجاوز جذره 102. جميع المُدقّقين (validators)، بغض النظر عن نمط التصويت، سيكونون مُلتزمين إما بجذر 102 أو سليل 102.

### عملية التناوب على لعب دور القائد (leader) مع تقسيمات حجم الفترة (epoch).

مدة تعويض الجدول الزمني للقائد (leader) لها علاقة مُباشرة بإحتمال أن تكون هناك رؤية غير مُتسقة للمجموعة (cluster) للجدول الزمني الصحيح للقائد.

ضع في الإعتبار السيناريو التالي:

قسمان يولدان نصف الكتل (blocks) لكل منهما. لا يصل أي منهما إلى إنقسام أو شوكة (fork) ذات أغلبية عُظمى (supermajority) نهائية. كلاهما سيتخلفان عن الفترة (epoch) عدد 100 و 200 دون أن يلتزما فعليا بجذورهما ومن ثم بالإلتزام على نطاق المجموعة بجدول زمني جديد للقائد (leader).

في هذا السيناريو غير المُستقر، تتواجد جداول زمنية صحيحة مُتعددة للقائد (leader).

- يتم إنشاء جدول زمني للقائد أو leader لكل إنقسام أو شوكة أو Fork يكون أحد مولديه المباشرين في الفترة أو epoch السابقة.
- الجدول الزمني للقائد (leader schedule) صالح بعد بداية الفترة (epoch) التالية للإنقسامات أو الشوكات (forks) المُتحدِّرة (descendant) حتى يتم تحديثه.

سيتباعد الجدول الزمني لكل قسم بعد أن يدوم التقسيم أكثر من فترة (epoch). لهذا السبب، يجب إختيار مدة الفترة (epoch) لتكون أكبر بكثير من وقت الفُتحة (Slot) والمُدة المُتوقعة للإنقسام أو الشوكة (fork) ليتم الإلتزام بجذورها.

بعد مُراقبة المجموعة (cluster) لفترة كافية من الوقت، يُمكن إختيار الجدول الزمني لتعويض القائد (leader) على أساس مُتوسط مُدة التقسيم وإنحرافه المعياري. على سبيل المثال، من شأن التعويض الأطول من مُتوسط مُدة التقسيم بالإضافة إلى ستة إنحرافات معيارية أن تُقلل من إحتمال وجود جدول دفتر أستاذ (ledger) غير مُتسق في المجموعة (cluster) إلى 1 من المليون.

## جدول توليد القائد في فترة التكوين (Leader Schedule Generation at Genesis)

إعداد فترة التكوين (Genesis) تُعلن القائد (leader) الأول للفترة (epoch) الأولى. ينتهي هذا القائد (leader) إلى تحديد موعده لأول فترتين (epochs) لأن الجدول الزمني للقائد يتم إنشاؤه أيضا في الفُتحة (Slot) عدد 0 للفترة (epoch) التالية. يُمكن تحديد أطول أول فترين (epochs) في إعدادات فترة التكوين (Genesis) أيضا. يجب أن يكون الحد الأدنى لأول فترين (epochs) أكبر من أو يساوي أقصى عمق للتراجع (rollback) كما هو مُحدد في [Tower BFTBFT](../implemented-proposals/tower-bft.md).

## خوارزمية جدول توليد القائد (Leader Schedule Generation Algorithm)

يتم إنشاء الجدول الزمني للقائد (Leader schedule) بإستخدام قِيَ برمجية (seed) مُحَدَّدَة مسبقا. فيما يلي هكذا تتم العملية:

1. إستخدم دوريا إرتفاع العلامة (tick) الخاصة بالـ PoH \(عَدَّاد زيادة رتيب\) لزرع خوارزمية قيمة برمجية (seed) شبه عشوائية ومُستقرة.
2. عند هذا الإرتفاع (height)، قُم بتجربة البنك لجميع حِساب إثبات الحِصَّة أو التَّحْصِيص (staked accounts) ذات الهُوِيَّات القيادية التي صوتت ضمن عدد من العلامات (ticks) المُصنّعة في المجموعة (cluster). العينة تُسمى مجموعة نشطة _active set_.
3. فرز المجموعة النشطة (active set) حسب وزن الحِصَّة (stake weight).
4. إستخدم القيم البرمجية (seed) العشوائية لإختيار العُقَد (nodes) المُرجحة بالحِصَّة (stake-weighted) لإنشاء ترتيب حسب حجم حِصَّة.
5. هذا الطلب يصبح صالحا بعد عدد من الticks التي تم تصنيعها في المجموعة أو cluster.

## جدولة ناقلات الهجوم (Schedule Attack Vectors)

### القيمة البرمجية (seed)

القيمة البرمجية (seed) التي يتم إختيارها يُمكن التنبؤ بها ولكنها غير مُتحيزة. لا يوجد هجوم طاحن للتأثير على نتائجه.

### المجموعة النشطة (Active Set)

يستطيع القائد (leader) أن يأخذ موقف مُتحيز ضد المجموعة النشطة (active set) عن طريق فرض الرقابة على أصوات المُدقّقين (validators). هناك طريقتان مُمكنتان للقادة (leaders) لفرض الرقابة على المجموعة النشطة (active set):

- تجاهل الأصوات من المُدقّقين (validators)
- رفض التصويت على الكتل (blocks) مع أصوات من المُدقّقين (validators)

للحد من إحتمال فرض الرقابة، يتم حساب المجموعة النشطة (active set) في حدود جدول القائد المُعَوِّض (leader schedule offset) من خلال مُدة أخذ عينات المجموعة النشطة أو _active set sampling duration_. مُدة أخذ عينات المجموعة النشطة (active set) طويلة بما فيه الكفاية بحيث تكون الأصوات قد تم جمعها بواسطة قادة (leaders) مُتعددين.

### إثبات الحِصَّة أو التَّحْصِيص (Staking)

يُمكن للقادة فرض رقابة على مُعاملات إثبات الحِصَّة أو التَّحْصِيص الجديدة أو رفض التحقق من صحة الكتل (blocks) مع الحِصَص (stakes) الجديدة. يُشبه هذا الهجوم الرقابة على أصوات المُدقّقين (validators).

### فقدان مفتاح التشغيل للمُدقّقين (validators)

من المُتَوَقَّع أن يستخدم القادة (Leaders) والمُدقّقون (validators) مفاتيح مُؤقتة (ephemeral keys) للعمل، ويأذن أصحاب الحِصَّة (stake) للمُدقّقين (validators) بالعمل مع حِصَّتهم (stake) عن طريق التفويض (Delegation).

ينبغي أن تكون المجموعة (cluster) قادرة على التعافي من فقدان جميع المفاتيح المؤقتة (ephemeral keys) التي يستخدمها القادة (leaders) والمُدقّقون (validators)، ويُمكن أن يحدث ذلك من خلال ضعف البرمجيات المُشتركة التي تتقاسمها جميع العُقَد (nodes). ينبغي أن يكون بمقدور أصحاب الحِصَّة (Stake owners) التصويت مُباشرة بالتوقيع المُشترك على صوت المُدقّق (validator) حتى وإن كانت الحِصَّة (stake) مُفوضة سلفا إلى مُدقّق (validator) آخر.

## إلحاق المُدخلات (Appending Entries)

مُدة عمر الجدول الزمني للقائد (leader schedule) تُسمى الفترة _epoch_. تنقسم الفترة (epoch) إلى فُتحات _slots_، حيث كل فُتحة (slot) لها مُدة `T` العلامة (tick) الخاصة بالـ PoH.

يقوم القائد (leader) بنقل المُدخلات (entries) خلال الفُتحة (Slot) الخاصة به. بعد وضع الticks `T` ، يتحول جميع المُدقّقين (validators) إلى القائد (leader) المُبَرمَج التالي. يجب أن يتجاهل المُدقّقون (Validators) المُدخلات (entries) المُرسلة خارج فُتحة (slot) القائد (leader).

يجب أن يُراقب القائد (leader) التالي جميع العلامات `T` لكي يبني مُدخلاته (entries) الخاصة به. إذا لم يتم مُراقبة المُدخالات، لا يُمكن الإتصال بالقائد \(leader is down\) أو المُدخالات غير صالحة، القائد خبيث أو ذو أخطاء عديدة \(leader is buggy or malicious\)، يجب على القائد التالي أن ينتج علامات (ticks) لملء فُتحة القائد السابق. لاحظ أنه ينبغي للقائد التالي أن يتقدم بطلبات التصليح بالتوازي، يقوم بتأجيل إرسال العلامات (ticks) إلى أن يتأكد من فشل بقية المُدقّقين أيضا في مُراقبة مُدخالات القائد السابق. إذا كان أحد القادة (leader) يبني بشكل خاطئ على العلامات (ticks) الخاصة به، فيجب على القائد (leader) الذي يليه أنيُيعوض جميع تلك العلامات (ticks).
