---
title: توربين إنتشار الكتل (Turbine Block Propogation)
---

تستخدم مجموعة Solana آلية نشر كتل مُتَعَدِّدَة الطبقات (multi-layer block propagation mechanism) تُسَمَّى توربين _Turbine_ لبث قِطَع (shreds) الصفقات لجميع العُقَد (nodes) مع الحد الأدنى من الرسائل المُكرّرة. تقسم المجموعة (cluster) نفسها إلى مجموعات صغيرة من العُقَد (nodes)، تُسَمَّى أحياء _neighborhoods_. كل عُقدة (node) مسؤولة عن مُشاركة أي بيانات تتلقاها مع العُقَد (nodes) الأخرى في حيها (neighborhood)، بالإضافة إلى نشر البيانات على مجموعة صغيرة من العُقَد (nodes) في أحياء (neighborhoods) أخرى. بهذه الطريقة يجب على كل عُقدة (node) أن تتصل بعدد صغير فقط من العُقد (nodes).

خلال الفُتحة (slot) الخاصة بها، تقوم العُقدة القائد (leader node) بتوزيع القِطَع (shreds) بين عُقَد التدقيق (validator nodes) في الحي (neighborhood) الأول \(layer 0\). يُشارك كل مُدقّق (validator) بياناته داخل حيه (neighborhood)، ولكنه يُعيد أيضا نقل القِطَع (shreds) إلى عُقدة (node) واحدة في بعض الأحياء (neighborhoods) في الطبقة التالية \(layer 1\). كل عُقد (nodes) الطبقة 1 تشارك بياناتها مع أقرانهم في الأحياء (neighborhood)، وإعادة الإرسال إلى العُقد (nodes) في الطبقة التالية، وما إلى ذلك، حتى تتلقى جميع العُقَد (nodes) في المجموعة جميع القِطَع (shreds).

## تعيين الجوار - الإختيار المُرَجَّح (Neighborhood Assignment - Weighted Selection)

لكي يعمل إنتشار مستوى البيانات، يجب أن تتفق المجموعة (cluster) بأكملها على كيفية تقسيم الكتلة إلى أحياء (neighborhoods). لتحقيق ذلك، يتم فرز جميع عُقد المُدقّقين (validator nodes) المعترف بهم \("أقران TVU \) حسب الحِصَّة (stake) وتخزينها في قائمة. ثم يتم فهرسة هذه القائمة بطرق مختلفة لمعرفة حدود الحي (neighborhood) وإعادة نقل الأقران. على سبيل المثال، سيقوم القائد (leader) ببساطة بإختيار العُقد (nodes) الأولى لتكوين الطبقة 0. ستكون هذه تلقائيا لأصحاب أعلى حِصَّة (highest stake holders)، مما يسمح لأكثر الأصوات تأثيرا ووزنا بالعودة إلى القائد (leader) أولا. تستخدم عُقد الطبقة 0 والطبقة السفلية نفس المنطق للعثور على جيرانهم وأقرانهم من الطبقة التالية.

للحد من إمكانية إنتقال ناقلات الهجوم (attack vectors)، يتم نقل كل قِطَعة (shred) منها عبر شجرة (tree) عشوائية من الأحياء (neighborhoods). كل عُقدة (node) تستخدم نفس مجموعة العُقد (nodes) التي تمثل المجموعة (cluster). يتم توليد شجرة عشوائية من المجموعة لكل قطعة بإستخدام بذرة (seed) مُشتقِّة من مُعرف القائد (leader)، الفُتحة (slot) وفهرس القِطَع (shred index).

## طبقة وبنية الحي (Layer and Neighborhood Structure)

يقوم القائد (leader) الحالي ببثاته الأولية على حد أقصى `DATA_PLANE_FANOUT` العُقد (nodes). إذا كانت هذه الطبقة 0 أصغر من عدد العُقد (nodes) في المجموعة (cluster)، فإن آلية تبديل مستوى البيانات (data plane fanout mechanism) تضيف الطبقات أدناه. الطبقات اللاحقة تتبع هذه القيود لتحديد سعة الطبقة (layer-capacity): كل حي (neighborhood) يحتوي على `DATA_PLANE_FANOUT` عُقد (nodes). الطبقة 0 تبدأ مع عدد 1 حي (neighborhood) مع عُقد التبديل (fanout nodes). يزداد عدد العُقد (nodes) في كل طبقة إضافية حسب عامل الإستيعات (factor of fanout).

كما ذكر أعلاه، يجب على كل عُقدة (node) في طبقة فقط أن تبث قِطَعها (shreds) إلى جيرانها وإلى عُقدة (node) واحدة بالضبط في أحياء (neighborhoods) الطبقة المُوالية، بدلا من كل أقران وحدة TVU في المجموعة (cluster). طريقة جيدة للتفكير في هذا هو، الطبقة 0 تبدأ بعدد 1 حي (neighborhood) بعُقد توزيع (fanout nodes)، وتضيف الطبقة 1 أحياء توزيع (fanout neighborhoods)، كل منها يحتوي على عُقد توزيع (fanout nodes)، وستحتوي الطبقة 2 على توزيع _ عدد العُقَد (nodes) في الطبقة 1 `fanout _ number of nodes in layer 1` وهلم جرا.

بهذه الطريقة يجب على كل عُقدة (node) الإتصال فقط بحد أقصى `2 * DATA_PLANE_FANOUT - 1` عُقدة (nodes).

يُوضح الرسم البياني التالي كيف يُرسل القائد (Leader) قِطَعه (shreds) مع توزيع (fanout) عدد 2 إلى الحي (neighborhood) عدد 0 في الطبقة 0 وكيف تتبادل العُقد (nodes) في الحي (neighborhood) عدد 0 بياناتها مع بعضها البعض.

![يُرسل القائد (leader) القِطَع (shreds) إلى الحي (neighborhood) عدد 0 في الطبقة 0](/img/data-plane-seeding.svg)

الرسم البياني التالي يُوضح كيف أن الحي (neighborhood) عدد 0 يخدم الأحياء (neighborhoods) عدد 1 و 2.

![الحي (neighborhood) عدد 0 يُوزع إلى الحي (neighborhood) عدد 1 و 2](/img/data-plane-fanout.svg)

أخيرا، يظهر الرسم البياني التالي مجموعة (cluster) من الطبقتين مع توزيع (fanout) من 2.

![مجموعة (cluster) من الطبقتين مع توزيع (fanout) من 2](/img/data-plane.svg)

### قيم الإعدادات (Configuration Values)

`DATA_PLANE_FANOUT` - يحدد حجم الطبقة 0. الطبقات اللاحقة تنمو بعامل `DATA_PLANE_FANOUT`. عدد العُقد (nodes) في الحي (neighborhood) مساوٍ لقيمة التوزيع (fanout). ستمتلئ سعة الأحياء (neighborhoods) قبل إضافة أحياء جديدة، على سبيل المثال، إذا لم يكن الحي (neighborhood) ممتلئا، يجب أن يكون _must_ هو الأخير.

يتم حاليا تعيين الإعدادات عند إطلاق المجموعة (cluster). قد يتم في المُستقبل إستضافة هذه المُعلمات (parameters) على الشبكة (on-chain)، مما يسمح بإدخال تعديلات في أي وقت عندما تتغير أحجام المجموعات (cluster).

## حساب مُعدل الFEC المطلوب (Calculating the required FEC rate)

يعتمد التوربين (Turbine) على إعادة إرسال الحزم بين المُدقّقين (validators). بسبب إعادة الإرسال، يتم مضاعفة فقدان أي حزمة شبكة واسعة، وإحتمال فشل الحزمة في الوصول إلى وجهتها يزيد مع كل قفزة (hop). ينبغي أن يأخذ مُعدل FEC في الإعتبار فقدان الحزمة على نطاق الشبكة وعمق الإنتشار.

المجموعة المُمَزَّقَة (shred group) هي مجموعة من حزم البيانات وحزم التشفير التي يُمكن إستخدامها لإعادة بناء بعضها البعض. كل مجموعة مُمَزَّقَة (shred group) لديها فرصة للفشل، إستنادا إلى إحتمال تجاوز عدد الحِزم الفاشلة مُعدل الFEC. إذا فشل المُدقّق (validator) في إعادة بناء المجموعة المُمَزَّقَة، فلا يُمكن إعادة بناء الكتلة (block)، ويتعين على المُدقّق (validator) الإعتماد على الإصلاح لإصلاح الكتل (blocks).

يمكن حساب إحتمال فشل المجموعة المُمَزَّقَة (shred group) بإستخدام التوزيع الثنائي (binomial distribution). إذا كان مُعدل FEC هو `16: 4` ، فإن حجم المجموعة هو 20، ويجب أن تفشل 4 قِطَع (shreds) على الأقل حتى تفشل المجموعة. وهو ما يساوي مجموع إحتمال فشل 4 مسارات أو أكثر من أصل 20.

إحتمالية نجاح الكتلة (block) في التوربين (turbine):

- إحتمال فشل الحزمة: `P = 1 - (1 - network_packet_loss_rate)^2`
- مُعدل FEC: `K:M`
- عدد التجارب: `N = K + M`
- مُعدل فشل المجموعة المُمَزَّقَة: `S = SUM of i=0 -> M for binomial(prob_failure = P, trials = N, failures = i)`
- القِطَع (shreds) لكل كتلة: `G`
- مُعدل نجاح الكتلة: `B = (1 - S) ^ (G / N)`
- التوزيع الثنائي (Binomial distribution) بالضبط لـ `i` يُنتُج مع إحتمال P في التجارب N يتم تعريفها على أنها `(N choose i) * P^i * (1 - P)^(N-i)`

على سبيل المثال:

- مُعدل فقدان حِزمة الشبكة (Network packet loss) هو 15%.
- تُولد شبكة ذات إنتاجية 50 ألف مُعاملة في الثانية الواحدة (50k tps) عدد 6400 قِطَعة في الثانية الواحدة.
- يزيد مُعدل الـ FEC إجمالي القِطَع (shreds) لكل كتلة (block) حسب مُعدل الـ FEC.

بمُعدل FEC: `K:M`

- `G = 8000`
- `P = 1 - 0.85 * 0.85 = 1 - 0.7225 = 0.2775`
- `S = SUM of i=0 -> 4 for binomial(prob_failure = 0.2775, trials = 20, failures = i) = 0.689414`
- `B = (1 - 0.689) ^ (8000 / 20) = 10^-203`

بمُعدل FEC `16:16`

- `G = 12800`
- `S = SUM of i=0 -> 32 for binomial(prob_failure = 0.2775, trials = 64, failures = i) = 0.002132`
- `B = (1 - 0.002132) ^ (12800 / 32) = 0.42583`

بمُعدل FEC `32:32`

- `G = 12800`
- `S = SUM of i=0 -> 32 for binomial(prob_failure = 0.2775, trials = 64, failures = i) = 0.000048`
- `B = (1 - 0.000048) ^ (12800 / 64) = 0.99045`

## الأحياء (Neighborhoods)

الرسم البياني التالي يُوضح كيف يتفاعل حيان (two neighborhoods) في طبقات مُختلفة. لشل حي (neighborhood) ما، هناك ما يكفي من العُقد (nodes) \(رموز المحو +1\) من الحي (neighborhood) أعلاه بحاجة إلى الفشل. بما أن كل حي يتلقى القِطَع (shreds) من عُقَد (nodes) مُتعددة في حي (neighborhood) في الطبقة العليا، كنا بحاجة إلى فشل كبير في الشبكة في الطبقات العليا لنحصل على بيانات منقوصة.

![الأعمال الداخلية في حي ما (neighborhood)](/img/data-plane-neighborhood.svg)
