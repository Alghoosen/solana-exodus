---
title: 읽기 전용 계정
---

이 디자인은 \[런타임\] (../ validator / runtime.md)에서 읽기 전용 및 쓰기 가능한 계정의 처리를 다룹니다. 동일한 계정을 수정하는 여러 트랜잭션은 항상 동일한 순서로 재생되도록 순차적으로 처리되어야합니다. 그렇지 않으면 원장에 비결 정성을 도입 할 수 있습니다. 그러나 일부 트랜잭션은 특정 계정의 데이터를 수정하지 않고 읽기만하면됩니다. 동일한 계정 만 읽는 여러 트랜잭션을 병렬로 처리 할 수 ​​있습니다. 재생 순서는 중요하지 않으므로 성능상의 이점을 제공합니다.

읽기 전용 계정을 식별하기 위해 트랜잭션 MessageHeader 구조에는`num_readonly_signed_accounts` 및`num_readonly_unsigned_accounts`가 포함됩니다. 명령어`program_ids`는 계정 벡터에 읽기 전용, 서명되지 않은 계정으로 포함됩니다. 실행 가능한 계정은 명령어 처리 중에 마찬가지로 수정할 수 없기 때문입니다.

## 런타임 처리

런타임 트랜잭션 처리 규칙을 약간 업데이트해야합니다. 프로그램은 여전히 ​​소유하지 않은 계정을 쓰거나 사용할 수 없습니다. 그러나 새로운 런타임 규칙은 읽기 전용 계정을 소유 한 프로그램에서도 수정할 수 없도록합니다.

읽기 전용 계정에는 다음 속성이 있습니다.

- Read-only access to all account fields, including lamports (cannot be credited or debited), and account data

-램프 포트 (입금 또는 출금 불가) 및 계정 데이터를 포함한 모든 계정 필드에 대한 읽기 전용 액세스

## 계정 잠금 최적화

계정 모듈은 쓰기 가능한 계정에서 읽기 전용 계정을 분리하는 런타임에서 현재 잠긴 계정을 추적합니다. 기본 계정 잠금은 계정에 "쓰기 가능"지정을 제공하며 한 번에 하나의 처리 스레드에서만 액세스 할 수 있습니다. 읽기 전용 계정은 별도의 메커니즘에 의해 잠기므로 병렬 읽기가 가능합니다.

아직 구현되지는 않았지만 읽기 전용 계정은 메모리에 캐시되고 트랜잭션을 실행하는 모든 스레드간에 공유 될 수 있습니다. 이상적인 디자인은 읽기 전용 계정이 런타임을 통해 이동하는 트랜잭션에 의해 참조되는 동안이 캐시를 보유하고 마지막 트랜잭션이 런타임을 종료 할 때 캐시를 해제하는 것입니다.

읽기 전용 계정은 참조로 프로세서에 전달되어 추가 사본을 절약 할 수도 있습니다.
