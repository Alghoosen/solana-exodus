---
title: 스냅 샷 확인
---

## 문제

유효성 검사기가 스냅 샷에서 부팅 할 때 계정 집합이 나머지 네트워크에서 빠르게 인식하는 것과 일치하는지 확인할 수있는 방법이 필요합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 잠재적 인 공격자는 유효성 검사기에게 잘못된 상태를 제공 한 다음 거부 될 트랜잭션을 수락하도록 유도 할 수 있습니다.

## 해결책

현재 은행 해시는 이전 은행 해시 값과 결합 된 슬롯에있는 계좌의 델타 상태를 해싱하여 파생됩니다. 문제는 해시 목록이 체인에 의해 처리되는 슬롯 수의 순서대로 증가하고 성공적으로 전송하고 확인하는 데 부담이된다는 것입니다.

또 다른 순진한 방법은 계정 상태의 머클 트리를 만드는 것입니다. 이것은 각 계정 업데이트로 머클 트리가 시스템에있는 모든 라이브 계정의 전체 계정 상태에서 다시 계산되어야한다는 단점이 있습니다.

스냅 샷을 확인하기 위해 다음을 수행합니다.

0이 아닌 lamport 계정의 계정 저장소에서 다음 데이터를 해시합니다.

- 계정 소유자 -계정 데이터 -계정 pubkey -계좌 잔고 잔고 -계정이 저장된 포크
- Account data
- Account pubkey
- Account lamports balance
- Fork the account is stored on

이 결과 해시 값을 해시 값을 이미지 값으로 확장하는 확장 함수에 대한 입력으로 사용합니다. 이 함수는 처음 32 바이트가 해시 값이고 다음 440-32 바이트가 해시를 시드로 사용하여 Chacha RNG에서 생성되는 440 바이트 데이터 블록을 생성합니다.

그러면 계정 이미지가 xor와 결합됩니다. 이전 계정 값은 상태로 xoring되고 새 계정 값도 상태로 xoring됩니다.

투표 및 sysvar 해시 값은 결과 전체 이미지 값의 해시와 함께 발생합니다.

유효성 검사기 부팅시 스냅 샷에서로드 할 때 계정이 설정된 해시 값을 확인합니다. 그런 다음 SPV를 사용하여 주어진 해시 값에 투표 한 네트워크의 백분율을 표시합니다.

결과 값은 모든 현재 계정 상태를 함께 xoring 한 결과인지 밸리데이터에 의해 검증 될 수 있습니다.

제로 램프 포트 계정은 해시 값에 영향을주지 않지만 유효성 검사기 은행에서 계정이 실제로 있어야 할 때 존재하지 않는다는 것을 읽을 수 있기 때문에 생성 전과 확인 중에 스냅 샷은 제로 램프 포트 계정을 제거해야합니다.

xor 상태에 대한 공격이 값에 영향을 줄 수 있습니다.

따라서 440 바이트 이미지 크기는이 백서에서 가져온 것이므로 0 \ (또는 다른 주어진 비트 패턴 \)과의 xor 충돌을 피할 수 있습니다. \ \[\[https://link.springer.com/content/pdf/10.1007%2F3-540 -45708-9_19.pdf\\] (https://link.springer.com/content/pdf/10.1007%2F3-540-45708-9_19.pdf) \]

이 경우 수학은 128 비트 보안을 제공합니다.

```text
O (k * 2 ^ (n / (1 + lg (k)))
k = 2 ^ 40 계정
n = 440
2 ^ (40) * 2 ^ (448 * 8/41) ~ = O (2 ^ (128))
```
