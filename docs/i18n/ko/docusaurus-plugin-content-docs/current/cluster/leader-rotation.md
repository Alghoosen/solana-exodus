---
title: 리더 로테이션
---

주어진 순간에 클러스터는 원장 항목을 생성하기 위해 오직 하나의 밸리데이터만 필요합니다. 한번에 하나의 리더만 보유함으로써 모든 밸리데이터는 원장의 동일한 사본을 재생성 할 수 있습니다. 그러나 한번에 단 한 명의 리더로서 오는 단점은 악의적인 리더가 투표와 거래를 검열할 수 있다는 것입니다. 검열은 네트워크 드롭 패킷 수준에서 구별될 수 없기에 단순히 클러스터가 단일 노드에 리더 역할을 무기한 부여할 순 없습니다. 대신 클러스터는 어떤 노드가 선두를 차지하는지 순환하여 악의적인 리더의 영향을 최소화합니다.

각 밸리데이터는 아래에 설명된 동일한 알고리즘을 사용하여 예비 리더를 선택합니다. 밸리데이터가 서명 된 새 원장 항목을 받으면 예상 리더가 항목을 생성했음을 확인할 수 있습니다. 각 리더에게 슬롯이 할당 된 슬롯의 순서를 _리더 스케쥴_이라고합니다.

## 리더 스케쥴 순환

밸리데이터는 _슬롯 리더_가 서명하지 않은 블록은 거부합니다. 모든 슬롯 리더의 신원 목록을 _리더 스케쥴_이라고합니다. 리더 스케쥴은 로컬 및 주기적으로 재산출됩니다. 스케쥴은 _에폭_이라고하는 기간 동안 슬롯 리더를 할당합니다. 스케쥴은 할당된 슬롯보다 훨씬 앞서 계산되어야하므로 스케쥴을 계산하는 데 사용하는 원장 상태가 완료됩니다. 이 기간을 _리더 스케쥴 오프셋_이라고합니다. 솔라나는 오프셋을 다음 에폭까지 슬롯 기간으로 설정합니다. 즉, 에폭의 리더 일정은 이전 에폭 시작 상태의 원장에서 계산됩니다. 한 에폭의 오프셋은 상당히 임의적이며 모든 밸리데이터가 다음 스케쥴이 생성되기 전에 원장 상태를 완료 할만큼 충분히 길다고 가정합니다. 클러스터는 스테이킹 변경과 리더 스케쥴 업데이트 사이의 시간을 줄이기 위해 오프셋을 단축하도록 선택할 수 있습니다.

에폭보다 오래 지속되는 파티션없이 작동하는 경우, 루트 포크가 에폭 경계를 넘을 때만 스케줄을 생성하면됩니다. 일정은 다음 에폭을 위한 것이므로 루트 포크에 커밋된 새로운 스테이킹은 다음 에폭까지 활성화되지 않습니다. 리더 스케쥴을 생성하는 데 사용되는 블록은 에폭 경계를 통과하는 첫번째 블록입니다.

에폭을 보다 오래 지속되는 파티션이 없으면 클러스터는 다음과 같이 작동합니다.

1. 밸리데이터는 투표할 때 자체 루트 포크를 지속적으로 업데이트합니다.
2. 밸리데이터는 슬롯 높이가 에폭 경계를 넘을 때마다 리더 스케쥴을 업데이트합니다.

예제

에폭 기간은 100개의 슬롯으로 구성되어 있습니다. 루트 포크는 슬롯 높이 99에서 계산된 포크에서 슬롯 높이 102에서 계산된 포크로 업데이트됩니다. 높이가 100, 101인 슬롯이있는 포크는 실패된 것이기 때문에 건너 뛰었습니다. 새 리더 일정은 슬롯 높이 102에서 포크를 사용하여 계산됩니다. 에폭은 200 슬롯까지이며 이후 업데이트 됩니다.

클러스터에 투표하는 모든 밸리데이터가 루트가 102를 통과 할 때 100과 101을 건너 뛰었으므로 불일치가 존재할 수 없습니다. 투표 패턴에 관계없이 모든 밸리데이터는 102 또는 102의 하위 루트에 커밋됩니다.

### 에폭 크기 파티션을 사용한 리더 스케쥴 순환.

리더 스케쥴 오프셋의 기간은 클러스터가 올바른 리더 일정에 대해 일관되지 않은 관점을 가질 가능성과 직접적인 관계가 있습니다.

다음 시나리오를 생각해 볼 수 있습니다:

각각 절반의 블록을 생성하는 두 개의 파티션이 있습니다. 어느 쪽도 결정적인 압도적 다수 포크에 도달하지 못했습니다. 둘 다 실제로 루트에 커밋하지 않고 에폭 100과 200에 엇갈리므로 새로운 리더 스케쥴에 대한 클러스터 전체 커밋이 발생합니다.

이 불안정한 시나리오에서는 유효한 리더 스케쥴은 여러개가 존재합니다.

- 모든 포크에서 리더 스케쥴이 이전 에폭의 직계 상위로부터 생성됩니다.
- 리더 스케쥴은 업데이트 될 때까지 하위 포크에 대한 다음 세대가 시작될 때 까지 유효합니다.

각 파티션의 일정은 파티션이 한 세대 이상 지속 된 후에 전환됩니다. 이러한 이유로, 에폭 기간은 슬롯 시간과 포크가 루트에 커밋 될 것으로 예상되는 길이보다 훨씬 더 넓게 선택되어야합니다.

충분한 시간 동안 클러스터를 관찰 한 후 중앙 분할 기간 및 표준 편차를 기반으로 리더 스케줄 오프셋을 선택할 수 있습니다. 예를 들어 중간 분할 기간에 6개의 표준 편차를 더한 것보다 더 긴 오프셋은 클러스터에서 일관되지 않은 원장 일정의 가능성을 1백만 분의 1로 줄일 수 있습니다.

## 제네시스의 리더 일정 생성

제네시스 구성은 첫 번째 에폭의 첫 번째 리더를 선언합니다. 리더 스케쥴은 다음 에폭의 슬롯 0에서도 생성되기 때문에 해당 리더는 처음 에폭 스케쥴에 예약됩니다. 처음 두 에폭의 길이는 제네시스 구성에서도 지정할 수 있습니다. 첫 번째 에폭의 최소 길이는 [타워 BFT](../implemented-proposals/tower-bft.md)에 정의된 최대 롤백 깊이보다 크거나 같아야 합니다.

## 리더 스케쥴 생성 알고리즘

리더 스케쥴은 미리 정의된 시드를 사용하여 생성됩니다. 과정은 다음과 같습니다:

1. 주기적으로 역사증명 틱 높이 \(일정하게 증가하는 카운터\) 를 사용하여 안정적인 의사 랜덤 알고리즘을 시드합니다.
2. 해당 높이에서 클러스터 구성 틱 수 내에서 투표 한 리더 ID가있는 모든 스테이킹 계정에 대해 샘플링합니다. 이 샘플을 _활성 세트_라고합니다.
3. 스테이킹 가중치에 따라 활성 세트를 정렬합니다.
4. 랜덤 시드를 사용하여 스테이킹 가중치가 적용된 노드를 선택하여 지분 가중치 순서를 만듭니다.
5. 이 순서는 클러스터에서 구성된 틱 만큼의 수 후에 유효합니다.

## 스케쥴 공격 벡터

### Seed

선택된 시드는 예측 가능하지만 편향성이 없습니다. 결과에 영향을 미치는 그라인딩 공격은 존재하지 않습니다.

### Active Set

리더는 밸리데이터 투표를 검열하여 활성 세트를 편향시킬 수 있습니다. 리더가 활성 세트를 검열하는 데엔 두 가지 방법이 있습니다.

- 밸리데이터의 투표 무시
- 블록에 대한 밸리데이터의 투표 거부

검열 가능성을 줄이기 위해 활성 세트는 _활성 세트 샘플링 기간_동안 리더 일정 오프셋 경계에서 계산됩니다. 활성 세트 샘플링 기간은 여러 리더가 투표를 수집할 만큼 충분히 지속됩니다.

### 스테이킹

리더는 새로운 스테이킹 거래를 검열하거나 새로운 스테이킹의 블록 검증을 거부 할 수 있습니다. 이 공격은 밸리데이터 투표 검열과 유사합니다.

### 밸리데이터 운영키 손실

리더와 밸리데이터는 운영을 위해 임시키를 사용해야하며 스테이킹 소유자는 밸리데이터 위임을 통해 자신의 스테이킹을 활용할 수 있도록 권한을 부여합니다.

클러스터는 모든 노드가 공유하는 공통 소프트웨어 취약성을 통해 발생할 수있는 리더 및 밸리데이터의 모든 임시 키의 손실로부터 복구할 수 있어야 합니다. 스테이킹 소유자는 현재 스테이킹이 밸리데이터에게 위임 되더라도 밸리데이터 투표에 공동 서명하여 직접 투표 할 수 있어야 합니다.

## 항목 추가

리더 일정의 수명을 _에폭_이라고합니다. 에폭은 _슬롯_으로 분할되며 각 슬롯의 지속 시간은 `T` 역사증명 틱입니다.

리더는 슬롯 지속기간 동안 항목을 전송합니다. `T` 틱 후에 모든 밸리데이터는 다음 예정된 리더로 전환합니다. 밸리데이터는 리더의 할당된 슬롯 외부로 전송 된 항목을 무시해야합니다.

모든 `T` 틱은 다음 리더가 자체 항목을 작성하기 위해 주목되어야 합니다. 항목이 관찰되지 않거나 \(리더가 다운 되거나\) 또는 항목이 유효하지 않은 경우 \(리더가 버그, 또는 악의적으로 변하거나\), 다음 리더는 이전 리더의 슬롯을 채우기 위해 틱을 생성해야합니다. 다음 리더는 회복 요청을 병렬로 수행해야하며 다른 밸리데이터도 이전 리더의 항목을 관찰하지 못했음이 확실시 될 때 까지 틱 전송을 연기해야합니다. 리더가 자신의 틱으로 잘못 빌드하는 경우, 뒤 따르는 리더가 모든 틱을 대체해야합니다.
