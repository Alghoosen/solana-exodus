---
title: 터빈 블록 전파
---

솔라나 클러스터는 최소화된 중복 메시지 트랜잭션 슈레드 전파를 위해 *터빈*이라 불리는 다중 레이어 블록 전파 메커니즘을 활용합니다. 클러스터는 *네이버후드*라 불리는 소규모 노드 그룹으로 나눠집니다. 각 노드는 네이버후드에 있는 여타 노드들로부터 오는 모든 데이터를 공유할 의무를 지니며, 다른 네이버후드에 위치한 소규모 노드 세트에게도 데이터를 전파해야 합니다. 이렇게 함으로서 각 노드는 소수의 노드들과 의사소통만 하면 되는 것입니다.

슬롯 도중에, 리더 노드는 첫번째 네이버후드 \(layer 0\) 에 위치한 밸리데이터 노드들 간에 슈레드를 분배합니다. 각 밸리데이터는 네이버후드 내에서 데이터를 공유하지만, 다음 레이어 \(layer 1\) 에 위치한 네이버후드의 노드에게도 슈레드를 재전송 합니다. 레이어-1 노드들은 데이터를 각자의 네이버후드 일원들과 공유하고, 클러스터에 존재하는 노드 전체가 슈레드를 받을때까지 이를 다음 레이어의 노드에게 재전송합니다.

## 네이버후드 할당 - 가중치 선별

데이터 플레인이 펼쳐지기 위해선 클러스터 전체가 어떻게 네이버후드로 나뉘어 질 지 동의해야 합니다. 이를 달성하기 위해 인지되는 모든 밸리데이터 노드\(the TVU peers\) 들은 지분에 따라 분류되어 리스트에 저장됩니다. 해당 리스트는 이후 네이버후드의 경계와 재전송 피어를 설정할 수 있도록 다양한 방식으로 인덱스 됩니다. 예를 들어, 레이어 0의 경우 간단하게 리더가 최초의 노드들을 선택할 수 있습니다. 이럴 때 지분을 지닌 스테이크홀더들이 자동적으로 선택되며, 가장 높은 투표 비중을 지닌 표가 리더로 먼저 나올수 있게 합니다. 레이어 0과 그 이하 레이어 노드들은 이와 같은 논리를 사용하여 자신들의 네이버후드와 다음 레이어 피어를 결정할 수 있습니다.

공격 벡터 가능성을 줄이기 위해 각 슈레드는 네이버후드의 무작위 트리를 타고 전파됩니다. 각 노드는 클러스터를 구성하는 동일한 노드 세트를 활용합니다. 무작위 트리는 리더 id와 슈레드 인덱스 에서 파생되는 시드를 사용하는 슈레드 세트로부터 생성됩니다.

## 레이어 및 네이버후드 구조

현 리더는 가장 큰 `DATA_PLANE_FANOUT`을 가진 노드들을 향해 최초 전파를 실행합니다. 만일 해당 레이어 0가 클러스터 상 노드 수보다 적다면, 데이터 플레인 팬아웃 메커니즘은 하위 레이어를 추가합니다. 이후 레이어들은 레이어 수용력 평가에 있어 위의 제한을 따릅니다: 각 네이버후드는 `DATA_PLANE_FANOUT` 노드들을 지닙니다. 레이어 0은 팬아웃 노드들을 지닌 1 네이버후드로부터 시작됩니다. 추가적인 레이어 내 노드 수는 팬아웃을 배수로 하는 만큼 증가합니다.

위에 언급되었듯이, 클러스터 내 모든 TVU가 아닌, 레이어 상 각 노드는 본인 네이버후드와 다음 레이어의 어느 네이버후드의 노드 하나에게만 슈레드를 전달하면 됩니다. 이를 이해할 수 있는 좋은 방법으로, 레이어 0은 팬아웃 노드를 지닌 1개의 네이버후드와 시작되고, 레이어 1은 팬아웃 노드들을 지닌 팬아웃 네이버후드들을 추가하며, 레이어 2는 레이어 1</code>의 `fanout \* 노드의 수만큼을 가지며 이것이 반복됩니다.</p>

<p spaces-before="0">이런 방식으로 각 노드는 최대 <code>2 * DATA_PLANE_FANOUT - 1` 만큼의 노드와 소통하면 됩니다.

다음 다이어그램은 리더가 2개의 팬아웃으로 레이어 0의 네이버후드 0에 어떻게 슈레드를 전송하는지, 그리고 네이버후드 0에 있는 노드들이 데이터를 어떻게 서로 공유하는지 보여줍니다.

![리더는 레이어 0의 네이버후드 0에 슈레드를 전송합니다](/img/data-plane-seeding.svg)

다음 다이어그램은 어떻게 네이버후드 0이 네이버후드 1과 2에 어떻게 팬아웃 하는지를 보여줍니다.

![네이버후드 0은 네이버후드 1과 2에 팬아웃 합니다](/img/data-plane-fanout.svg)

마지막으로, 다음 다이어그램은 2 팬아웃을 지닌 2개의 레이어 클러스터를 보여줍니다.

![2의 팬아웃을 지닌 2 레이어 클러스터](/img/data-plane.svg)

### 설정값

`DATA_PLANE_FANOUT` - 레이어 0의 규모를 정합니다. 이후 레이어들은 `DATA_PLANE_FANOUT`의 배수만큼 늘어납니다. 네이버후드 내 노드의 수는 팬아웃 값과 같습니다. 네이버후드는 수용력이 다할 때 까지 지속해서 신규 노드를 더합니다. 예를 들어 만일 네이버후드가 꽉 차지 않았다면, 해당 노드가 _반드시_ 마지막이 됩니다.

현재 클러스터가 출시되면 설정이 맞춰지게 됩니다. 미래엔 이러한 패리미터들이 온체인에 호스팅되어 클러스터 사이즈 변화에 맞춰 실시간으로 변경이 가능해 질 것입니다.

## 필요 FEC율 산출

터빈은 밸리데이터 간 패킷 재전송에 의지합니다. 재전송으로 인해 네트워크 차원에서 이뤄지는 패킷 소실은 축적되며, 각 재전송 때마다 패킷의 목적지 도달 확률은 줄어들게 됩니다. FEC율은 네트워크 차원의 패킷 소실과 전파 깊이를 감안해야 합니다.

슈레드 그룹은 서로간 재구성 해줄 수 있는 데이터 세트와 코딩 패킷을 뜻합니다. 각 슈레드 그룹은 FEC율을 넘어서는 패킷 장애 확률을 기반으로 한 장애 확률이 있습니다. 밸리데이터가 슈레드 그룹 재구성에 실패하면, 블록 또한 재구성할 수 없으며, 밸리데이터는 블록이 수리되기만을 기대야 합니다.

슈레드 그룹 장애 확률은 이항 분포를 통해 산출될 수 있습니다. 만일 FEC율이 `16:4`이라면, 그룹 사이즈는 20이며 그룹 장에에 있어 최소 4개의 슈레드 장애가 발생해야 합니다. 이는 20 중 4 이상의 장애확률의 총합과 같습니다.

터빈 상에서 블록 성공 확률:

- 패킷 장애 확률: `P = 1 - (1 - network_packet_loss_rate)^2`
- FEC율: `K:M`
- 시도 횟수: `N = K + M`
- 슈레드 그룹 장애율: `S = SUM of i=0 -> M 은 이항 분포(prob_failure = P, trials = N, failures = i)`
- 블록 당 슈레드: `G`
- 블록 성공률: `B = (1 - S) ^ (G / N)`
- N회의 시도 상 확률 P에서 `i`에 대한 정확한 이항 분포는 `(N choose i) * P^i * (1 - P)^(N-i)`로 표현됩니다.

예시:

- 네트워크 패킷 소실율은 15%
- 50k tps 네트워크는 초당 6400개의 슈레드를 생성
- FEC율은 FEC 비율에 따른 블록 당 슈레드 수를 상승

FEC율: `16:4`

- `G = 8000`
- `P = 1 - 0.85 * 0.85 = 1 - 0.7225 = 0.2775`
- `S = i의 총합=0 -> 이항 분포 4 (prob_failure = 0.2775, trials = 20, failures = i) = 0.689414`
- `B = (1 - 0.689) ^ (8000 / 20) = 10^-203`

FEC율 `16:16`

- `G = 12800`
- `S = i의 총합 =0 -> 이항 분포 32 (prob_failure = 0.2775, trials = 64, failures = i) = 0.002132`
- `B = (1 - 0.002132) ^ (12800 / 32) = 0.42583`

FEC율: `32:32`

- `G = 12800`
- `S = i의 총합 =0 -> 이항 분포 32 (prob_failure = 0.2775, trials = 64, failures = i) = 0.000048`
- `B = (1 - 0.000048) ^ (12800 / 64) = 0.99045`

## 네이버후드

다음 다이어그램은 어떻게 서로 다른 레이어에 위치한 네이버후드들이 상호작요 하는지 보여줍니다. 네이버후드 장애 발생을 위해선, 상위 네이버후드에서 충분한 수의 노드들에 \(erasure codes +1\) 장애가 발생해야 합니다. 각 네이버후드는 상위 레이어 네이버후드 노드들 다수로부터 슈레드를 받기 때문에, 불완전한 데이터 발생을 위해선 상위 레이어에서 대형 네트워크 장애가 발생해야만 합니다.

![네이버후드 내부 작업](/img/data-plane-neighborhood.svg)
