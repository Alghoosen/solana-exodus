---
title: 동기화
---

빠르고 안정적인 동기화는 솔라나가 높은 처리량을 달성 할 수있는 가장 큰 이유입니다. 전통적인 블록체인은 블록이라고하는 대규모 트랜잭션 청크에서 동기화됩니다. 블록에서 동기화하면 "블록 시간"이라는 기간이 경과 할 때까지 트랜잭션을 처리할 수 ​​없습니다. 작업 증명 합의에서 이러한 블록 시간은 여러 밸리데이터가 동시에 새로운 유효한 블록을 생성할 확률을 최소화하기 위해 매우 커야합니다\(~10분\). 지분 증명 합의에는 그러한 제약이 없지만 신뢰할 수 있는 타임스탬프가 없으면 밸리데이터가 들어오는 블록의 순서를 결정할 수 없습니다. 일반적인 해결 방법은 각 블록에 [wallclock timestamp](https://en.bitcoin.it/wiki/Block_timestamp)를 태그하는 것입니다. 클록 드리프트와 네트워크 지연 시간의 차이로 인해 타임 스탬프는 1 ~ 2 시간 이내에서만 정확합니다. 이 문제를 해결하기 위해 이러한 시스템은 각 블록의 중간 타임스탬프가 항상 증가하고 있다는 합리적인 확신을 제공하기 위해 블록 시간을 늘립니다.

솔라나는 _Proof of History_ 또는 *역사증명*라고 부르는 매우 다른 접근 방식을 취합니다. 리더 노드 "타임스탬프"는 마지막 증명 이후 일정 시간이 경과한 암호화 증명을 차단합니다. 증명으로 해시된 모든 데이터는 증명이 생성되기 전에 가장 확실하게 발생한 것입니다. 그런 다음 노드는 해당 증명을 확인할 수 있는 밸리데이터 노드와 새 블록을 공유합니다. 블록은 어떤 순서로든 밸리데이터에게 도착할 수 있으며 심지어 몇 년 후에 재생 될 수도 있습니다. 이러한 안정적인 동기화 보장을 통해 솔라나는 블록을 *entries*라는 작은 트랜잭션 배치로 나눌 수 있습니다. 항목은 블록 합의 개념에 앞서 실시간으로 밸리데이터에게 스트리밍됩니다.

솔라나는 기술적으로 *block*을 보내지 않지만 이 용어를 사용하여 밸리데이터가 *confirmation*을 달성하기 위해 투표하는 항목의 순서를 나타냅니다. 이런식으로 솔라나의 확정 시간은 블록 기반 시스템을 비교할 수 있습니다. 현재 구현은 블록 시간을 800ms로 설정되었습니다.

내부에서 일어나는 일은 리더 노드가 유효한 트랜잭션 세트를 항목으로 일괄처리 할 수 있는 것처럼 항목이 밸리데이터에게 빠르게 스트리밍된다는 것입니다. 밸리데이터는 유효성에 대해 투표하기 훨씬 전에 해당 항목을 처리합니다. 트랜잭션을 낙관적으로 처리하면 마지막 항목이 수신된 시간과 노드가 투표할 수 있는 시간 사이에 지연이 없습니다. 합의가 **달성되지 않은**경우 노드는 단순히 상태를 롤백합니다. 이러한 낙천적인 처리 기법은 1981년에 소개되었으며 [Optimistic Concurrency Control](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.65.4735)라고 불립니다. 이는 클러스터가 전체 원장을 나타내는 해시에서 일부 *block height*까지 투표하는 블록체인 아키텍처에 적용 할 수 있습니다. 솔라나에서는 마지막 항목의 역사증명 해시를 사용하여 이를 간단하게 구현합니다.

## VDF와의 관계

역사증명 기법은 2017 년 11월 솔라나가 블록체인에 사용하기 위해 최초로 시작했습니다. 이듬해 6월 스탠포드에서 [verifiable delay function](https://eprint.iacr.org/2018/601.pdf) 또는 *VDF*이라는 유사한 기법을 발표했습니다.

VDF의 바람직한 특성은 검증 시간이 매우 빠르다는 것입니다. 지연 함수를 확인하는 솔라나의 접근 방식은 이를 생성하는 데 걸린 시간에 비례합니다. 4000코어 GPU로 분할하면 솔라나의 요구에 충분히 빠르지만 위에 인용 된 논문의 저자에게 물어 보면 ([실제로](https://github.com/solana-labs/solana/issues/388)\) 솔라나의 접근 방식은 알고리즘 적으로 느리고 VDF라고 부르면 안될 것입니다. 우리는 VDF라는 용어가 특정 성능적 특성을 가진 부분 집합이 아니라 검증 가능한 지연 함수의 범주를 나타내야 한다고 주장합니다. 문제가 해결될 때 까지 솔라나는 애플리케이션 별 VDF에 역사증명아라는 용어를 계속 사용할 것입니다.

역사증명과 VDF의 또 다른 차이점은 VDF는 추적 기간에만 사용된다는 것입니다. 반면에 역사증명의 해시 체인에는 애플리케이션이 관찰한 모든 데이터의 해시가 포함됩니다. 이는 양날의 검입니다. 한편, 데이터는 "역사를 증명"합니다. 데이터는 그 이후에 해시되기 전에 가장 확실하게 존재했기 때문입니다. 다른 한편으로는 애플리케이션이 데이터가 _언제_ 해시되었는지 바꿈으로서 해시 체인을 조작할 수 있다는 의미이기도 하기 때문입니다. 따라서 역사증명 체인은 임의성의 좋은 소스로 사용되지 않지만 해당 데이터가없는 VDF는 그럴 수 있습니다. 솔라나의 [리더 순환 알고리즘](synchronization.md#leader-rotation)을 예로 들자면, 이는 해당 높이의 해시가 아닌 VDF의 *height*에서 파생됩니다.

## 합의 메커니즘과의 관계

역사증명은 합의 메커니즘이 아니지만 솔라나의 지분 증명 합의 성능을 개선하는 데 사용됩니다. 또한 데이터 플레인 프로토콜의 성능을 개선하는 데 사용됩니다.

## 역사증명에 대한 추가 정보

- [물시계 비유](https://medium.com/solana-labs/proof-of-history-explained-by-a-water-clock-e682183417b8)
- [역사증명 개요](https://medium.com/solana-labs/proof-of-history-a-clock-for-blockchain-cf47a61a9274)
