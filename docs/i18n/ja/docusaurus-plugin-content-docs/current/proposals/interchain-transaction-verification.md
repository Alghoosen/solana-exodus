---
title: チェーン間トランザクション認証
---

## 問題

インターチェーンアプリケーションは、デジタルアセットのエコシステムにおいて目新しいものではありません。 実際、小規模な中央集権型の取引所でさえ、ユーザー数や取引量の点で、シングルチェーンアプリケーションのすべてを圧倒しています。 しかし、それらの基本的な運営は、ユーザーが一方的に彼らを信頼することを必要とするメカニズムを中心に行われており、通常、事故による損失からの救済や保護はほとんどありません。 このため、デジタルアセットのエコシステムは、相互運用性ソリューションが一般的なネットワークラインに沿って分断されることになります。

- 完全に実装するには技術的に複雑です
- 不安定なネットワークスケールのインセンティブ構造を作成します
- ステーキングホルダー間の一貫したハイレベルな協力が必要です。

## 提案された解決策

Simple Payment Verification \(SPV\) は、主要なブロックチェーンネットワークのライトクライアントが使用するさまざまな手法の総称で、チェーン自体を完全に保存・維持することなくネットワークの状態を検証するためのものです。　 多くの場合、ハッシュツリーを用いて、ブロックのヘッダーにあるルートハッシュやそれに相当するハッシュと比較することで、特定のブロックに特定のトランザクションが存在することを証明することになります。 これにより、ライトクライアントやウォレットは、ネットワークノードに対する信頼を最小限に抑えながら、チェーン上のイベントについて確率的なレベルの確実性を得ることができます。

従来、これらの証明を集めて検証するプロセスは、ノードやウォレット、その他のクライアントによってチェーン外で行われていましたが、チェーン間の状態を検証するメカニズムとしても期待されています。 ただし、ブロックチェーン固有のアーカイブプロパティを活用しながら、"SPV"をスマートコントラクトとしてチェーン上で検証する機能を動かすことで、ブロックチェーンに固有の証明を行うことができます。 任意のタイプの信頼できるオラクルや複雑な多段階コンセンサスメカニズムの関与なしに、他のネットワーク上のトランザクションをプログラム的に検出して検証するシステムを構築することができます。 このコンセプトは、"SPV"の仕組みを持つあらゆるネットワークに広く一般化されており、他のスマートコントラクトプラットフォーム上で双方向に運用することも可能で、担保やハッシュロック、信頼できる仲介者に頼ることなく、安価で高速なチェーン間の価値移転の可能性を広げます。

SPVによる相互運用ソリューションは、主要なブロックチェーンに共通する、確立された安定したメカニズムを利用することで、組織化された多段階のアプローチよりも劇的にシンプルなものになります。 その一環として、広く合意されたクロスチェーン通信規格や、それを策定する大規模な複数の関係者による組織の必要性を排除し、共通の抽象化フォーマットを介して呼び出し側のコントラクトが容易に利用できる、個別のコントラクトベースのサービスのセットを採用しています。 これにより、多様化し、成長を続けるプラットフォーム・エコシステムの中で、幅広いアプリケーションとコントラクトの相互運用を可能にする基盤が整います。

## 専門用語

SPV Program -インターチェーンSPVシステムのクライアント向けインターフェースで、参加者の役割を管理します。 SPV Engine - SPVプログラムのサブセットで、トランザクションの証明を検証します。 Client - SPVプログラムの呼び出し元で、通常は別のSolana契約。 Prover - トランザクションの証明を生成し、SPVプログラムに提出する当事者。 Ransaction Proof -プローバが作成するもので、"メルクルプルーフ"、"トランザクション"、"ブロックヘッダー"の参照を含みます。 Merkle Proof -特定のブロックにトランザクションが存在することを検証する基本的なSPVプルーフ。 Block Header - 特定のブロックの基本パラメータと相対的な位置を表します。 Proof Request -クライアントがプルーバーによるTransaction\(s\) の検証を依頼すること。 Header Store - プルーフ内のブロックヘッダーの範囲を保存、参照するためのデータ構造。 Client Request - プルーフリクエスト作成のきっかけとなる、クライアントからSPVプログラムへのトランザクション。 Sub-account - 他のコントラクトアカウントが所有する、独自のプライベートキーを持たないSolanaアカウントのこと。

## サービス

SPVプログラムは、Solanaネットワーク上に配置されたコントラクトとして実行され、SPV証明のための一種の公開市場を維持します。当事者は証明の要求だけでなく、要求に応じて検証のための証明自体も提出することができます。 SPVプログラムのインスタンスは、接続されている外部ネットワークごとに少なくとも1つ、潜在的にはネットワークごとに複数のインスタンスが存在し、常に複数のインスタンスがアクティブになります。 SPVプログラムのインスタンスは、ハイレベルAPIと機能セットにおいて比較的一貫していますが、通貨プラットフォーム\(Bitcoin, Litecoin\) とスマートコントラクトプラットフォームの間では、単なる取引以外のネットワーク状態の変化を検証する可能性があるため、多少の違いがあります。 SPVプログラムは、ネットワークに関わらず、SPVエンジンと呼ばれる内部コンポーネントに依存しており、高レベルのクライアント向け機能やAPIが構築されている実際のSPV証明のステートレスな検証を行います。 SPVエンジンは、ネットワーク固有の実装を必要としますが、その実装を行い、それを標準のSPVプログラムにドロップして展開することを選択したチームは、より大きなチェーン間エコシステムを容易に拡張することができます。

プルーフリクエストの目的上、要求者はプログラムクライアントと呼ばれ、ほとんどの場合、他のSolana契約者となります。 クライアントは、特定の取引に関する要求を提出するか、または入力、出力、および金額を含む取引のパラメータのいずれかに適用可能な、より広範なフィルタを含めるかを選択できます。 例えば、クライアントは、一定時間後に、アドレスAからアドレスBに金額Xのトランザクションを送信するリクエストを送信することができます。 この構造は、アトミック・スワップの場合の特定の意図された支払いの確認や、ローンの担保資産の移動の検出など、様々な用途に使用することができます。

クライアントリクエストの提出後、その検証が成功した場合には、SPVプログラムによってリクエストの進捗状況を追跡するためのプルーフリクエストアカウントが作成されます。 明者は、このアカウントを使用して、検証のために提出した証明を記入する予定のリクエストを指定します。この時点で、SPVプログラムはそれらの証明を検証し、成功した場合はリクエストアカウントのアカウントデータに保存します。 クライアントは、リクエストアカウントのアカウントデータを照会することで、リクエストのステータスを監視し、証明書と一緒に該当する取引を確認することができます。 Solanaでサポートされる将来のバージョンでは、このプロセスは、説明されているようなポーリングスタイルのプロセスを必要とするのではなく、コントラクトがイベントを発行することで簡素化されます。

## 実装方法

Solana Inter-chain SPVメカニズムは、以下のコンポーネントと参加者で構成されています。

### SPV エンジン

Solanaに配置されたコントラクトで、呼び出し元のためにSPV証明をステートレスに検証します。 検証のための引数を受け取ります。

- プログラムに関連付けられたブロックチェーンの正しい形式でのSPVプルーフ
- 該当するブロックヘッダへの参照\(s\) を参照して、その証明との比較を行います
- 検証に必要なトランザクションのパラメータ

  問題の証明が正常に検証されると、SPVプログラムは証明を保存します。

  によって保存されるリクエストアカウントに対する検証のうち、呼び出し元は

  必要に応じて取り扱うことができます。 SPV プログラムも公開しています

  ヘッダの表現と検証に使用されるユーティリティや構造は

  チェーン単位で取引やハッシュなどを行います

### SPVプログラム

Solana上に配置されたコントラクトで、クライアントとプロバの間のやりとりを調整・仲介し、リクエスト、ヘッダー、プルーフなどの検証を管理します。 クライアントのコントラクトがインターチェーンにアクセスする際の主要なアクセスポイントとなります。 SPVメカニズム。 以下のようなコア機能を備えています。

- Submit Proof Request - クライアントが特定の証明または証明セットのリクエストを行うことができます
- Cancel Proof Request - クライアントが保留中のリクエストを無効にすることができます
- Fill Proof Request - 証明書リクエストに対応する証明書を提出するために、"Provers"が使用します。

  SPVプログラムは、公開されている有効な証明書のリストを維持しています

  Proversの利益のためにそのアカウントデータを要求します, 誰がそれを監視し、

  提出された証明書でターゲット要求への参照を同封します。

### プルーフリクエスト

クライアントがSPVエンジンに送信するメッセージで、特定の取引または一連の取引の証明を要求することを示します。 証明依頼は、ハッシュで特定の取引を手動で指定することも、複数の取引または取引のクラスにマッチするフィルタを送信することもできます。 例えば、"アドレスxxxからアドレスyyyまでのすべての取引"に一致するフィルタは、債務の支払いやチェーン間スワップの決済を検出するために使用できます。 同様に、"アドレスxxxからの任意の取引"に一致するフィルターは、貸し出し契約や合成トークンの鋳造契約が担保の変更を監視して対応するために使用することができます。 証明要求は手数料とともに送信され、その要求に一致する証明が検証されると、SPVエンジンコントラクトから適切な証明者に支払われます。

### リクエストブック

プローバが要求を満たしたり、クライアントがキャンセルしたりできる、有効でオープンなプルーフ要求の公開リスト。 取引所のオーダーブックによく似ているが、リストは2つに分かれているのではなく、1つのタイプになっています。 SPVプログラムのアカウントデータに格納されています。

### 証明

ある取引が当該ブロックチェーンに存在することを証明するもの。 証明には、実際のmerkle証明と、有効なシーケンシャルブロックヘッダのチェーンへの参照\(s\) の両方が含まれます。 証明者は、SPVプログラムのリクエストブックにホストされている公開された証明リクエストの仕様に従って、証明を構築し、提出します。 検証の際には、関連するProof Requestのアカウントデータに保存され、クライアントはそのリクエストの状態を監視するために使用することができます。

### クライアント

トランザクション証明のリクエストの発信者。 クライアントは、アプリケーションの一部としての他の契約や、"ローン"、"スワップ"、"エスクロー"などの特定の金融商品であることがほとんどです。 クライアントは、任意の検証プロセスサイクルにおいて、最初に"ClientRequest"を提出します。この"ClientRequest"は、パラメータおよび手数料を伝達し、検証が成功した場合には、SPVプログラムによってプルーフリクエストアカウントが作成されます。 クライアントは、有効なプルーフリクエストを参照するキャンセルリクエストを提出して、プルーフ提出のためにそれを無効とすることもできます。

### プローバー

プルーフリクエストを満たす証明の提出者。 証明者は、未処理のプルーフリクエストについてSPVプログラムのリクエストブックを監視し、一致するプルーフを生成して、検証のためにSPVプログラムに提出します。 証明が受理されると、当該の証明要求に関連する手数料が証明者に支払われます。 証明者は通常、ビットコインノードへのアクセス権を持つ"Solana Blockstreamer"ノードとして動作し、証明の作成やブロックヘッダーへのアクセスのために使用します。

### ヘッダストア

ヘッダストアのアカウントを参照して、提出された証明に含める目的でブロックヘッダを維持するために使用されるアカウントベースのデータ構造。 ヘッダーチェーンの検証はSPVプログラムの証明検証メカニズムのコンポーネントであるため、ヘッダストアは独立したエンティティが維持することができます。 証明依頼によって証明者に支払われる手数料は、"Merkle"証明自体の提出者と、提出された証明で参照されているヘッダストアとの間で分配されます。現在、すでに割り当てられているアカウントデータの容量を増やすことができないため、ユースケースでは、リバランスなしに無限に増やすことができるデータ構造が必要となります。 現在、すでに割り当てられているアカウントデータの容量を増やすことができないため、ユースケースでは、リバランスなしに無限に増やすことができるデータ構造が必要となります。 サブアカウントは、SPVプログラムが所有するアカウントで、独自の秘密キーを持たず、アカウントデータにブロックヘッダーを割り当てることでストレージとして使用されます。 ヘッダストアシステムの実装には、複数のアプローチが考えられます。

パブリックアドレスでインデックス化されたプログラムのサブアカウントにヘッダを格納します。

- 各サブアカウントは1つのヘッダを保持し、ブロックハッシュと一致する公開キーを持ちます。
- 1回の検証で、確認作業と同数のアカウントデータの検索が必要となります。
- 確認作業の回数は、取引データの上限によって制限されます(15～20回)
- 個々のヘッダをネットワーク全体で重複させません。

ヘッダを格納する複数のサブアカウントのリンクされたリスト。

- ストレージアカウントのシーケンシャルインデックスを維持し、ストレージアカウントごとに多くのヘッダを格納します
- &gt;99.9%以上の確認において、アカウントデータの検索は最大2回(最も多い場合は1回)となります。
- コンパクトなシーケンシャルデータのアドレスフォーマットにより、"任意の数の確認"と"高速ルックアップ"が可能です。
- ネットワーク上でのヘッダの重複を防ぐことができます。
