---
title: 最適化の確認
---

## プリミティブ

`vote(X, S)` - 投票には"参照"スロットとして`X`が追加される。X はこのフォークの**最新**の先祖で、このバリデータが切り替え証明付きで投票したものです。 バリデータが連続した投票を行い、それらがすべて子孫である限り、 同じ`X`を使用すべきです。 バリデータが前のスロットの子孫ではないスロット`s`に投票した場合、`X`は新しいスロット`s`に設定されます。 すべての投票は、`vote(X, S)`という形式になります。ここで、`S`は、投票されたスロット`(s, s.lockout)`のソートされたリストです。

Given a vote `vote(X, S)`, let `S.last == vote.last` be the last slot in `S`.

ここで、いくつかの"Optimistic Slashing"のスラッシング条件を定義します。 これらの直感は以下の通りです。

- `直感的`には あるバリデータが `vote(X, S) `を投稿した場合、同じバリデータがこのフォークと"重なる"別のフォークに投票してはなりません。 より具体的には、このバリデーターは、`vote(X', S')`の範囲`[X, S.last]`と`[X', S'.last]`の範囲`X != X'`とが重なっている場合には、以下のように別の票を投じるべきではありませんでした。

```text
                                  +-------+
                                  |       |
                        +---------+       +--------+
                        |         |       |        |
                        |         +-------+        |
                        |                          |
                        |                          |
                        |                          |
                    +---+---+                      |
                    |       |                      |
                X   |       |                      |
                    |       |                      |
                    +---+---+                      |
                        |                          |
                        |                      +---+---+
                        |                      |       |
                        |                      |       |  X'
                        |                      |       |
                        |                      +---+---+
                        |                          |
                        |                          |
                        |                          |
                        |                          |
                        |                      +---+---+
                        |                      |       |
                        |                      |       |  S'.last
                        |                      |       |
                        |                      +-------+
                        |
                    +---+---+
                    |       |
                 s  |       |
                    |       |
                    +---+---+
                        |
                        |
                        |
                        |
                    +---+---+
                    |       |
             S.last |       |
                    |       |
                    +-------+
```

(スラッシングできる票の例 vote(X', S') と vote(X, S))

上の図では、`S.last`への投票は`S'.last`への投票の後に送られることに注意してください(ロックアウトのため高い方の投票が後に送られます)。 したがって、投票の順序は次のようになるはずです。`X ... S'.last ... S.last`. つまり、`S'.last`の投票の後、バリデータはあるスロット`s > S'.last > X`でもう一方のフォークに戻ったはずです。 したがって、`S.last`への投票では、`X`ではなく、`S`を"基準"点として用いるべきでした。なぜなら、それはフォークの最後の"スイッチ"だったからです。

これを強制するために、我々は"Optimistic Slashing"というスラッシング条件を定義します。 同じバリデータによる 2 つの異なる投票`vote(X, S)`と`vote(X', S')`があった場合、その投票は以下を満たさなければなりません。

- `X <= S.last`, `X' <= S'.last`
- All `s` in `S` are ancestors/descendants of one another, all `s'` in `S'` are ancsestors/descendants of one another,
-
- `X == X'` は、 `S` が `S'` または `S'` が `S の親` であることを意味します。
- `X' > X` implies `X' > S.last` and `S'.last > S.last` and for all `s` in `S`, `s + lockout(s) < X'`
- `X > X'` implies `X > S'.last` and `S.last > S'.last` and for all `s` in `S'`, `s + lockout(s) < X`

(最後の 2 つのルールは、範囲が重ならないことを意味しています)。それ以外の場合、バリデータはスラッシュされます。

`Range(vote)` - 投票`v = vote(X, S)`が与えられたとき、`Range(v)`をスロット`[X, S.last]`の範囲と定義します。

`SP(old_vote, new_vote)` - バリデータの最新の投票である`old_vote`の"切替証明"です。 このような証明は、バリデータが"参照"スロットを切り替える際に必要となります(上記の投票の項を参照)。 切替証明には`old_vote`への参照が含まれているので、 `old_vote`の"範囲"を記録することができます(この範囲内で競合する他の切替をスラッシュ可能にするため)。 このようなスイッチは、ロックアウトを尊重しなければなりません。

切替証明は、ネットワークの`>1/3`以上がスロット`old_vote.last`でロックアウトされていることを示しています。

証明は要素`(validator_id, validator_vote(X, S))`のリストで、ここでは

1. すべてのバリデーター ID の賭け金の合計＞`> 1/3`

2. 各`(validator_id, validator_vote(X, S))`に対して、`S`にあるスロット`s`が存在し、以下のようになります:_ a.`s`は`validator_vote.last`と`old_vote.last`と`new_vote.last`の両方の共通の祖先ではありません。 _ b. ` s`は`validator_vote.last`の子孫ではありません。 \* c. `s + s.lockout() >= old_vote.last` (バリデータが`old_vote.last`のスロットで`s`にロックアウトされたままであることを意味します。)

有効なスイッチングプルーフのないスイッチングフォークはスラッシュ可能です。

## 定義:

"Optimistic confirmation" -A ブロックは`B` が、ステーキングの `>2/3` が `v` の票で投票した場合、"optimistic confirmation" を達成したと言われます。ここで、そのような`v`ごとの`Range(v)`は、`B.slot`を含みます。

最終決定 -A ブロックは、 少なくとも 1 人の正しいバリデータが` "B"` または `"B `の子孫"を root 化した場合、ブロック `B` は最終決定されたと言います。

差し戻し -A ブロックは、`B`の親でも子でもない別のブロック `B'` が確定した場合、 ブロック`B`は差し戻されたと言います。

## 保証：

楽観的な確認に達したブロック`B`は、少なくとも 1 つのバリデータがスラッシングされない限り、元に戻されることはありません。

## 証明:

矛盾しないように、あるブロック`B`が、ある`n`に対してあるスロット`B＋n`で`楽観的な確定`を達成したと仮定します。

- `B`の親でも子でもない別のブロック`B'`が確定しました。
- どのバリデータもスラッシュ条件に違反していません。

`optimistic confirmation`の定義によれば、これは`> 2/3`のバリデータが、 `Vote(X, S)`の形式で`X <=B <=v.last`という投票`v`をそれぞれ示したことを意味します。 この一連のバリデータを `Optimistic Validators`と呼びます。

さて、`Optimistic Validators`のバリデータ`v`が与えられ、`v`が行った 2 つの投票、`Vote(X, S)`と`Vote(X', S')`が与えられ、`X <= B <= S. last`であり、`X' <= B <= S'.last`である場合、`X == X'`でなければ "Optimistic Slashing "条件に違反します。(各投票の "範囲 "が`B`で重なってしまいます。)

Thus define the `Optimistic Votes` to be the set of votes made by `Optimistic Validators`, where for each optimistic validator `v`, the vote made by `v` included in the set is the `maximal` vote `Vote(X, S)` with the greatest `S.last` out of any votes made by `v` that satisfy `X <= B <= S.last`. 上記から、`v`が行うそのようなすべての投票に対する`X`が一意であることがわかっているので、そのような一意の`最大`の投票があることがわかります。

### Lemma 1:

`Claim:` `Optimistic Validators`セットのバリデータ`V`が行った投票`Vote(X, S)`が与えられ、`S`にスロット`s`への投票が含まれている場合、以下のようになります。

- `s + s.lockout > B`,
- `s` は `B` の祖先または子孫ではありません

そして `X > B`.

```text
                                  +-------+
                                  |       |
                        +---------+       +--------+
                        |         |       |        |
                        |         +-------+        |
                        |                          |
                        |                          |
                        |                          |
                        |                      +---+---+
                        |                      |       |
                        |                      |       |  X'
                        |                      |       |
                        |                      +---+---+
                        |                          |
                        |                          |
                        |                      +---+---+
                        |                      |       |
                        |                      |       |  B (Optimistically Confirmed)
                        |                      |       |
                        |                      +---+---+
                        |                          |
                        |                          |
                        |                          |
                        |                      +---+---+
                        |                      |       |
                        |                      |       |  S'.last
                        |                      |       |
                        |                      +-------+
                        |
                    +---+---+
                    |       |
                 X  |       |
                    |       |
                    +---+---+
                        |
                        |
                        |
                        |
                        |
                        |
                    +---+---+
                    |       |
            S.last  |       |
                    |       |
                    +---+---+
                        |
                        |
                        |
                        |
                    +---+---+
                    |       |
      s + s.lockout |       |
                    +-------+
```

`Proof`:矛盾しないように、"Optimistic Validators "セットのバリデータ`V`が、 `Vote(X, S)`のような投票を行ったと仮定します。 `S`は`B`の祖先でも子孫でもないスロット`s`への投票を含んでおり、 `s + s. lockout > B`であるが、`X <= B`です。

`Vote(X', S')`をバリデータ`V`が行った`Optimistic Votes`セットの投票とします。 そのセット(すべての票が楽観的に`B`を確定)の定義により、`X' <=B <=S'.last`となります(上図参照)。

これは、上で`X <= B`と仮定されているので、`X <= S'.last`となり、スラッシュのルールにより、`X == X'`または`X < X'`のいずれかとなります(そうしないと、`(X', S'.last)`の範囲と重なってしまいます)。

`ケース X == X'`:

`s` を考えてみましょう。 `s != X`を知っているのは、`s`が`B`の祖先でも子孫でもないと仮定されているからであり、`X`は`B`の祖先であるからです。 `S'.last`は`B`の子孫であるため、`s`も`S'.last`の祖先でも子孫でもないということになります。 すると、`S.last`は`s`の子孫であるため、`S'.last`も`S.last`の祖先でも子孫でもないことになります。 これは `X != X'`"楽観的なスラッシュ" ルールを意味します。

`ケース X < X'`:

直観的には、これは `Vote(X, S)` が "before" `Vote(X', S')` を意味します。

上記の仮定から、 `s + s.lockout > B > X'`. `s`は`X'`の祖先ではないので、このバリデータが最初に`X'`に`Vote(X', S'')`という形式の投票で切り替え票を提出しようとすると、ロックアウトに違反することになります。

これらのケースのどれも有効ではないので、仮定は無効でなければなりません そしてクレームは証明されています。

### Lemma 2:

`B'`は、"楽観的に"確認されたブロック`B`とは別のフォークでファイナライズされたブロックだったことを思い出してください。

`Claim`。`Optimistic Votes`セット内の任意の投票`Vote(X, S)`について、`B' > X`が真でなければなりません。

```text
                                +-------+
                                |       |
                       +--------+       +---------+
                       |        |       |         |
                       |        +-------+         |
                       |                          |
                       |                          |
                       |                          |
                       |                      +---+---+
                       |                      |       |
                       |                      |       |  X
                       |                      |       |
                       |                      +---+---+
                       |                          |
                       |                          |
                       |                      +---+---+
                       |                      |       |
                       |                      |       |  B (Optimistically Confirmed)
                       |                      |       |
                       |                      +---+---+
                       |                          |
                       |                          |
                       |                          |
                       |                      +---+---+
                       |                      |       |
                       |                      |       |  S.last
                       |                      |       |
                       |                      +-------+
                       |
                   +---+---+
                   |       |
    B'(Finalized)  |       |
                   |       |
                   +-------+
```

`Proof`: Let `Vote(X, S)` be a vote in the `Optimistic Votes` set. そうすると、定義上、"optimistcally confirmed"のブロック`B`があれば、`X <= B <= S.last`となります。

なぜなら、`X`は`B`の親であり、`B'`は`B`の親でも先祖でもないからです。 とすると

- `B' != X`
- `B'` は `X` の親ではありません

ここで、`B'` < `X`の場合を考えてみましょう。

`ケース B' < X`: 私たちはこれがロックアウトの違反であることを示しています。 上記から、 `B'` が `X` の親ではないことがわかります。 すると、`B'`がルート化され、`B'`が`X`の親ではないので、バリデーターは`B'`の子孫ではない上位のスロット`X`に投票することができなかったはずです。

### 安全性の証明:

ここで、`Optimistic Validators` の中で、少なくとも 1 つのバリデータを表示することを目指しています。

まず、`B'`が根付いているためには、`B'`に投票した`> 2/3`のステーキングか、`B'`の子孫がいなければならないことに注意してください。 `Optimistic Validator`のセットにも、`> 2/3`のステーキングされたバリデータが含まれていることを考えると、`> 1/3`のステーキングされたバリデータが含まれていることになります。

- Root `B'` または `B'` の子孫です
- また、`Vote(X, S)`の形式で`X <= B <= v.last`という投票`v`を提出しました。

`Delinquent` を上記の基準を満たすバリデータのセットにします。

定義によれば、`B'`をルート化するためには、`Delinquent`の各バリデータ`V`は、それぞれ`Vote(X_v, S_v)`という形式の何らかの"切り替え票"を行っていなければなりません。

- `S_v.last > B'`
- `S_v.last` は `B'`の子孫なので、 `B` の子孫ではありません。
- `S_v.last`は`B`の子孫ではないので、`X_v`は`B`の子孫でも先祖でもありません。

定義により、この不良バリデーター`V`は、`Vote(X, S)`を`楽観的投票`でも何らかの投票を行いましたが、ここではそのセットの定義により(楽観的に確認された`B`)、`S.last >= B >= X`がわかっています。

`Lemma 2`により、`B' > X`を知っており、上から`S_v.last > B'`なので、`S_v.last > X`となります。 `X_v != X`(上から`B`の子孫でも先祖でもない)なので、そのときのスラッシュルールによって、`X_v > S.last`がわかります。 以上のことから、`S.last> >= B >>= X` なので、このような"票の入れ替え"はすべて、`X_v> > B `となります。

ここで、これらの"入れ替え票"を時間的に並べると、`V`を`Optimistic Validators`の中で、最初にこのような"入れ替え票"`Vote(X', S')`を提出したバリデータとします。ここで、`X' > B`とします。 このようなバリデータが存在することを知っているのは 滞納しているバリデータはすべてそのような票を提出しているはずであり、 滞納しているバリデータは`Optimistic Validators`のサブセットであることが上からわかったからです。。

`Vote(X, S)`をバリデータ`V`による`"楽観的投票"`での唯一の投票(`S.last`を最大化する)とします。

`Vote(X, S)`が与えられたとき、`X' >> B> >= X`なので、`X' >> X`となり、"Optimistic Slashing "ルールにより、`X' >> S.last`となります。

このような`X'`への"切り替え投票"を行うためには、切り替え証明`SP(Vote(X, S), Vote(X', S'))`で、このバリデータの最新の投票`S.last`でステーキングの`>1/3`以上がロックアウトされていることを示さなければなりません。 この`>1/3`と、`Optimistic Voters`セットのバリデータのセットが`> 2/3`の賭けであることから、`Optimistic Voters`セットから少なくとも 1 人の楽観的なバリデーター`W`が投票を提出していなければならないことを意味します(切替証明の定義を思い出してください)。 `Vote(X_w, S_w)`という、スロット`X'`に対するバリデータ`V`の切替証明に含まれていたもので、`S_w`には次のようなスロット`s`が含まれています。

- `s` は `S.last` と `X'` の共通の祖先にはなりません
- `s` は `S.last` の子孫ではありません。
- `' + s'.lockout > S.last`

`B` は `S.last`の祖先であるため、以下のようになります。

- `s` は `B` と `X'` の共通の祖先ではありません
- `' + s'.lockout > B`

これは `V`のスイッチング証拠に含まれていました。

さて、`W`は`楽観的投票者`のメンバでもあるので、上記の`Lemma 1`により、`W`による投票があると、`Vote(X_w, S_w)`、ここで`S_w`はスロット`s`への投票を含み、`s + s. lockout > B`であり、`s`が`B`の祖先ではない場合、`X_w > B`となります。

Because validator `V` included vote `Vote(X_w, S_w)` in its proof of switching for slot `X'`, then his implies validator `V'` submitted vote `Vote(X_w, S_w)` **before** validator `V` submitted its switching vote for slot `X'`, `Vote(X', S')`.

しかし、`Vote(X', S')`は`楽観的投票者`の集合の中で、`X'> > B`かつ`X'`が`B`の子孫ではないバリデータが最初に行う投票としたので、これは矛盾しています。
