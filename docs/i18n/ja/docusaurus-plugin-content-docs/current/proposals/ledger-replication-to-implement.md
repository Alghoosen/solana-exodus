---
title: Ledger Replication
---

注：この台帳複製ソリューションは部分的に実装されましたが完成していません。 この部分的な実装は、使われていないコードのセキュリティリスクを防ぐために、"https://github.com/solana-labs/solana/pull/9992" によって削除されました。 この設計書の最初の部分は、台帳レプリケーションのかつて実装された部分を反映しています。 この[ドキュメントの第 2 部](#ledger-replication-not-implemented)では、実装されなかったソリューションの部分を説明します。

## Proof of of Replication

1Gbps のネットワークをフル稼働させた場合、solana は年間"4 ペタバイト"のデータを生成します。 全データを保存しなければならないバリデーターにネットワークが集中するのを防ぐために、このプロトコルでは、マイニングノードがデータの一部を保存する容量を提供する方法を提案しています。

"Proof of Replication"の基本的な考え方は、"CBC 暗号"を用いて公開対称キーでデータセットを暗号化し、暗号化されたデータセットをハッシュ化することです。 この単純な方法の主な問題点は、不誠実なストレージノードが暗号化をストリーミングし、ハッシュ化されたデータを削除できることです。 単純な解決策は、署名入りの PoH 値に基づいてハッシュを定期的に再生成することです。 これにより、証明の生成時にすべてのデータが存在することが保証されます。また、検証者は、すべての ID のすべての証明を検証するために、暗号化されたデータの全体を存在させる必要があります。 つまり、検証に必要な容量は` number_of_proofs * data_size` となります。

## PoH による最適化

この方法の改善点は、暗号化されたセグメントを、暗号化にかかる時間よりも早くランダムにサンプリングし、そのサンプルのハッシュを PoH 台帳に記録することです。 このようにして、セグメントは"PoRep"ごとにまったく同じ順序で維持され、検証はデータをストリーミングして 1 つのバッチですべての証明を検証することができます。 この方法では、複数の証明をそれぞれの CUDA コアで同時に検証することができます。 検証に必要な総容量は、`1_ledger_segment + 2_cbc_blocks * number_of_identities`で、コア数は`number_of_identities`に等しいです。 ここでは、64 バイトのチャチャ CBC ブロックサイズを使用しています。

## ネットワーク

"PoRep"を検証するバリデータは、トランザクションを検証するバリデータと同じです。 もしアーカイバが、あるバリデータが偽の PoRep を検証したことを証明できれば、そのバリデータはそのストレージエポックの報酬を受け取ることができません。

アーカイバは特殊な*ライトクライアント*です。 アーカイバーは台帳の一部(セグメントとして知られている)をダウンロードして保存し、台帳を保存する PoReps を提供します。 PoRep が確認されるごとに、アーカイバーはマイニングプールから sol の報酬を得ます。

## 制約事項

以下の制約があります:

- 検証には、CBC ブロックの生成が必要です。 そのためには、同一のデータセットに対して、Id ごとに 2 の

  ブロックのスペースが必要となり、同じデータセットの場合、1 つの ID につき 1 つの CUDA コアが必要となります。 つまり、

  一度に多くの ID をバッチ処理し、それらの ID の証明を同じデータセットで同時に検証する必要があります。

  同時に検証する必要があります。

- 検証者は、保存されている証明のセットをランダムにサンプリングして、自分が処理できるセットにします。

  そして、その中から選ばれた証明を作成した人だけが

  報酬を得ることができます。 検証者は、ハードウェア構成が変わるたびにベンチマークを実行して

  変わるたびにベンチマークを実行し、ストレージ証明をどの程度の割合で検証できるかを判断することができる。

## 検証とレプリケーションプロトコル

### 定数

1. SLOTS_PER_SEGMENT: 台帳データのセグメントに含まれるスロットの数 その

   アーカイバのストレージの単位。

2. NUM_KEY_ROTATION_SEGMENTS: アーカイバの後のセグメント数は

   は、暗号化キーを再生成し、保存する新しいデータセットを選択します。

3. NUM_STORAGE_PROOFS: ストレージプルーフの必要数は

   報酬を得ることができました。

4. RATIO_OF_FAKE_PROOFS: ストレージの偽の証明と本物の証明の比率は

   報酬を得るために、マイニングプルーフが必要です。

5. NUM_STORAGE_SAMPLES: ストレージマイニングに証明に必要なサンプル数

   。

6. NUM_CHACHA_ROUNDS: 暗号化された状態をを生成するために行われた暗号化ラウンドの数

   。

7. NUM_SLOTS_PER_TURN: PoRep ゲームの 1 つのストレージエポックまたは

   "ターン"を定義するスロットの数。

### バリデータの動作

1. Validator はネットワークに参加し、

   ストレージのエポック/ターン境界ごとにアーカイバのアカウントを探し始めます。

2. 毎ターン、バリデーターは境界で PoH 値に署名し、

   その署名を使ってターン境界で見つかった各ストレージアカウントから検証する証明をランダムに選びます。

   この署名済みの値はバリデータのストレージアカウントにも送信され、

   後日アーカイバが相互検証のために使用することになります。

3. すべての `NUM_SLOTS_PER_TURN` スロットは、バリデータが PoH 値を宣伝します。 この値は、

   "RPC インターフェース"を介してアーカイバにも提供されます。

4. 与えられたターン N の場合、N+3 \(a gap of 2 turn/epoch\) まで、すべてのバリデーションはロックアウトされます。

   この時点で、そのターン中に行われたすべてのバリデーションがリワード回収の対象となります。

5. 誤った検証は、その間のターンでマークされます。

### アーカイバの動作

1. アーカイバーはライトクライアントであり、すべての台帳データをダウンロードするわけではないので、

   情報は他のバリデータやアーカイバーに頼らなければなりません。

   任意のバリデータが悪意を持って不正確な情報を与えるかもしれないし、 そうでないかもしれません。

   しかし、アーカイバに無駄な作業をさせること以外に、

   明らかな攻撃のベクトルはありません。 多くの操作については、

   アーカイバがどの程度偏執的であるかによって いくつかの選択肢があります。以下に示します。

   - \(a\) アーカイバーはバリデータを問い合わせることができます
   - \(b\) アーカイバーは複数のバリデータを問い合わせることができます
   - \(c\) アーカイバーは他のアーカイバーに問い合わせることができます
   - \(d\) アーカイバは、完全なトランザクションストリームをサブスクライブして、

     情報を生成することができます。\(スロットが最近のものであれば\)

   - \(e\) アーカイバは、省略されたトランザクションストリームを購読して、

     自分自身で情報を生成することができます(スロットが最新であることが前提です)。

2. アーカイバは、そのスロットで最後のターンに対応する PoH ハッシュを取得します。
3. アーカイバは、PoH ハッシュに自分のキーペアで署名します。 この署名は、

   複製するセグメントを選ぶための種であり、暗号化キーでもあります。 その

   アーカイバは署名とスロットを照合し、

   複製するセグメントを決定します。

4. アーカイバーはピアのバリデータやアーカイバーに依頼して

   台帳を再構築します。 6.5 を参照してください。

5. その後、アーカイバはそのセグメントを"Chacha アルゴリズム"を用いて

   "CBC モード"で`"NUM_CHACHA_ROUNDS"`の暗号化を行います。

6. アーカイバは、署名された最新の PoH の値をシードとして、

   "chach rng"を初期化します。

7. アーカイバは、エントリーサイズの範囲で`NUM_STORAGE_SAMPLES`

   のサンプルを生成し、

   各オフセット値で暗号化セグメントを sha256 で 32 バイト分サンプリングします。 状態のサンプリングは、暗号化されたセグメントの生成よりも

   速いはずです。

8. アーカイバは、サンプリング操作終了時の"Sha の状態"、

   "シード"、"使用したサンプルを含む PoRep 証明トランザクション"を現在のリーダに送信し、

   それが台帳に記録されます。

9. あるターンの間に、アーカイバは同じセグメントに対して多くのプルーフを提出しなければならず、

   `RATIO_OF_FAKE_PROOFS`に基づいて、それらのプルーフのいくつかはフェイクでなければなりません。

10. "PoRep ゲーム"が次のターンに入ると、アーカイバーは、前のターンでどの証明が偽装されたのか、仮面をつけて取引をしなければなりません。

    トランザクションに、前のターンでどの証明が偽装されたかのマスクを提出します。 この

    取引によって、アーカイバとバリデータの双方の報酬が決まります。

11. 最後にターン N の場合、PoRep ゲームがターン N ＋ 3 に入ると

    ターン N のアーカイバの証明は報酬にカウントされます。

### PoRep ゲーム

複製の証明ゲームには、4 つの主要なステージがあります。 それぞれの"ターン"において、複数の"PoRep ゲーム"が進行することができるますが、それぞれが異なるステージにあります。

"PoRep ゲーム"の 4 つのステージは以下の通りです。

1. 証明書の提出段階
   - Archiverse：この段階でできるだけ多くの証明を提出します。
   - Validators: No-op
2. 検証段階
   - Archivers: No-op
   - Validators: アーカイバーを選択し、前のターンから証明を確認してください。
3. 証明チャレンジステージ
   - Archiverse: 正当化されたプルーフ・マスクを提出してください。\(偽証のために提出された 2 ターン前に提出されました\)
   - Validators: No-op
4. ボーナス回収段階
   - Archivers: 3 ターン前のボーナスを受け取ってください
   - Validators: 3 ターン前の報酬を受け取ってください。

PoRep ゲームの各ターンにおいて、Validator と Archiver の両方が各ステージを評価します。 各ステージは、ストレージプログラム上で別々のトランザクションとして実行します。

### ある台帳のブロックを誰が持っているかを調べます。

1. 検証者は、PoRep ゲームのターンを監視し、ターンの境界にある"Root Bank"を見て、

   証拠がないかどうかを確認します。

2. バリデータは、台帳のセグメントとそれに対応するアーカイバの公開キーのマップを管理しています。

   バリデータがアーカイバの証明を処理すると、そのセグメントのマップが更新されます。

   バリデータは、このマップにアクセスするための RPC インターフェイスを提供しています。 この API を使うことで、

   クライアントはアーカイバのネットワークアドレス\(cluster_info テーブルを介して関連付ける\) にセグメントをマッピングすることができます。

   その後、クライアントはアーカイバに修復要求を送り、セグメントを取り出すことができます。

3. バリデーターは N ターンごとにこのリストを無効にする必要があります。

## シビルアタック

任意のランダムシードに対して、ターン境界での PoH ハッシュから得られる署名を全員が使用するようにします。 全員が同じカウントを使用するため、すべての参加者が同じ PoH ハッシュに署名することになります。 署名はそれぞれ暗号的にキーペアに結び付けられ、リーダーが結果として得られる値を 1 つ以上の ID で粉砕することができないようになっています。

暗号化 ID よりもクライアント ID の方が多いため、複数のクライアントに対する報酬を分割し、同じデータブロックを取得するために多くのクライアントを生成する"Sybil 攻撃"を防止する必要があります。 "BFT"を維持するためには、1 人の人間が台帳の 1 つの塊のすべての複製を保存しないようにする必要があります。

これに対する私たちの解決策は、クライアントが同じ ID を使い続けることを強制することです。 第 1 ラウンドで多くのクライアントの ID に対して同じブロックを取得した場合、同じクライアントの ID に対して第 2 ラウンドを行うと、署名の再分配が必要となり、PoRep の ID とブロックを取得することになります。 したがって、アーカイバが報酬を得るためには、最初のブロックを無料で保存する必要があり、ネットワークは新規のクライアント ID よりも長期間使用されたクライアント ID に報酬を与えることができます。

## バリデータアタック

- バリデータが偽の証明を承認した場合、アーカイバはハッシュの初期状態を示すことで

  簡単に偽の証明を排除することができます。

- バリデーターが本物の証明を偽物とマークした場合、どちらが正しいかを区別するための

  チェーン上の計算はできません。 報酬は、悪質な行為者やアーカイバが報酬を受け取れないようにするために、

  複数のバリデータの結果に頼らなければならないでしょう。

- 検証者は、自分自身のために証明の結果を盗みます。 証明は

  アーカイバからの署名を元にしています。

  バリデータは暗号キーの生成に使われた秘密キーを知らないので

  証明の生成者になることはできないのです。

## 報奨金

偽の証明は、生成するのは簡単だが、検証するのは難しいです。 このため、アーカイバが生成する PoRep 証明取引では、検証者が必要とする計算コストを表すために、通常の取引よりも高い手数料が必要となる場合があります。

また、ストレージマイニングで報酬を得るためには、ある程度の割合の偽の証明が必要となります。

## ノート

- PoH を使うことで PoRep の検証コストを削減し、

  実際にグローバルなデータセットに対して大量の証明を検証することが可能になります。

- 全員が同じ PoH ハッシュに署名し、その署名をシードとして使用することで、

  研磨をなくすことができます。

- バリデータとアーカイバのゲームは、ランダムなブロック、ランダムな暗号化 ID、ランダムな

  データサンプルをめぐるものです。 ランダム化の目的は、

  共謀したグループがデータや検証で重複することを防ぐことにあります。

- アーカイバのクライアントは、偽物であることを証明できる偽の証明書を提出することで

  怠惰なバリデータを釣り上げます。

- 同じブロックを保存しようとする"Sybil クライアント"の ID から守るために、

  クライアントは報酬を受け取る前に複数のラウンドで保存するようにしています。

- また、検証者は提出された保存証明を検証することで、

  台帳を保存するインセンティブとして報酬を得るべきです。 証者は、そのスライスの元帳を保存する場合にのみ

  証明を検証することができます。

# "Ledger Replication"は実装されていません

まだ実装されていないレプリケーション動作。

## ストレージ エポック

保存エポックは、アーカイバが保存するために生成される台帳が"100GB ～ 1TB"程度になるスロット数にします。 アーカイバは、あるフォークがロールバックされない可能性が高くなったときに台帳の保管を開始します。

## バリデータの動作

1. "NUM_KEY_ROTATION_TICKS"ごとに、アーカイバから受け取ったサンプルの

   検証も行います。 この時点で PoH ハッシュに署名し、

   その署名を入力として以下のアルゴリズムを使用します。

   - 署名の最初のバイトの下位 5 ビットで、

     署名の別の開始バイトへのインデックスを作成します。

   - 次に検証者は、

     証明の"Sha 状態ベクトル"の下位バイトから始まるバイトが、

     署名の byte\(s\) と完全に一致するストレージ証明のセットを見ます。

   - 証明のセットがバリデータの処理能力よりも大きい場合は、

     署名の 2 バイトを照合するようになります。

   - バリデータは、動作可能なセットが見つかるまで

     一致するバイト数を増やし続けます。

   - その後、有効な証明と偽の証明のマスクを作成し、

     リーダに送信します。 これがストレージプルーフの確認トランザクションです。

2. "NUM_SECONDS_STORAGE_LOCKOUT"秒のロックアウト期間の後、

   検証者はストレージ証明請求トランザクションを提出します。

   このトランザクションは、証明に対するチャレンジが見られなかった場合に、

   証明の当事者である検証者とアーカイバにストレージ報酬を分配します。

## アーカイバの動作

1. その後、アーカイバは別のオフセットセットを生成し、

   間違った"Sha 状態"を持つ偽の証明を提出します。 この証明は、

   ハッシュ結果のシードを提供することで、偽物であることを証明できます。

   - 偽の証明は、PoH 値の署名のアーカイバハッシュで

     構成されるべきです。 そうすれば、アーカイバが偽の証明を明らかにしたときに、

     それをチェーン上で検証することができます。

2. アーカイバは台帳を監視し、偽の証明が統合されているのを見つけたら

   チャレンジトランザクションを作成し、現在のリーダに提出します。 この

   トランザクションは、バリデータが偽のストレージプルーフを誤って検証したことを証明します。

   アーカイバには報酬が与えられ、バリデータの賭け金残高は削減または

   凍結されます。

## 収納証明契約論理

アーカイバとバリデータはそれぞれ自分のストレージアカウントを持ちます。 検証者のアカウントは、投票アカウントと同様に、ゴシップ ID とは別のものになります。 これらは 2 つのプログラムとして実装されるべきです。1 つは"バリデータをキー署名者として扱うもの"で、もう 1 つは"アーカイバ用のもの"です。 そうすれば、プログラムが他のアカウントを参照する際に、 プログラム ID をチェックして、参照しているのがバリデータやアーカイバの アカウントであることを確認することができます。

### SubmitMiningProof

```text
SubmitMiningProof {
    slot: u64,
    sha_state: Hash,
    signature: Signature,
};
keys = [archiver_keypair]
```

アーカイバは、保存されている台帳データをあるハッシュ値でマイニングした後、これらを作成します。 "sha_state"はアーカイバがハッシュ関数を使って暗号化された台帳セグメントをサンプリングした結果です。 署名は、現在の保存エポックの PoH 値に署名した際に作成された署名です。 現在の保存エポックの証明リストは、アカウントの状態で保存され、エポックが経過したときに、前のエポックの証明リストに移されるべきです。 所定の保存エポックにおいて、所定のアーカイバは 1 つのセグメントに対してのみプルーフを提出すべきです。

プログラムは、有効なストレージマイニングスロットのリストを持っている必要があります。 このリストは、ネットワークのかなりの部分が高いロックアウト値で投票したスロット（たぶん 32 票）を追跡することで維持されるべきです。 "SLOTS_PER_SEGMENT"の数だけ、このリストに追加されます。 プログラムは、スロットがこのセットに入っているかどうかをチェックする必要があります。 このセットは、"AdvertiseStorageRecentBlockHash"を受信し、そのバンク/タワーの BFT 状態と照合することで維持できます。

プログラムは、"署名"、"トランザクション提出者の公開キー"、および"前回のストレージエポック PoH 値のメッセージ"に対して署名検証チェックを行う必要があります。

### 校正検証

```text
ProofValidation {
   proof_mask: Vec<ProofStatus>,
}
keys = [validator_keypair, archiver_keypair(s) (unsigned)]
```

バリデータはこのトランザクションを送信して、指定したセグメントのプルーフのセットが有効か無効か、またはバリデータが見ていない場合はスキップされたことを示します。 プログラムロジックがこれらのアカウントにアクセスし、プルーフが前のエポックで生成されていることを確認できるように、確認したアーカイバのキーペアをキーで参照する必要があります。 ストレージ証明のサンプリングは、"バリデータのサンプリングの動作"で概説した論理に従って、バリデータが正しい証明をスキップすることを確認する必要があります。

"proof_mask"の長さは、参照するアーカイバアカウントのストレージプルーフセットと照合し、当該アーカイバアカウント\(s\), の状態で、前回のストレージエポックで提出されたプルーフの数と一致する必要があります。

### ClaimStorageReward

```text
ClaimStorageReward {
}
keys = [validator_keypair, validator/archiver_keypairs (unsigned)]
```

アーカイバーおよびバリデータは、"SubmitStorageProof"、"ProofValidation"、および"ChallengeProofValidations"が、プルーフが提出されて検証され、それらのプルーフを参照する"ChallengeProofValidations"がない状態のプログラムの状態から、本トランザクションを使用して、支払われたトークンを取得します。 バリデータでは、関連するエポックにおいて証明書を検証したアーカイバのキーペアを参照します。 アーカイバの場合は、検証を行い報酬を得たいと考えているバリデータのキーペアを参照すべきです。

### ChallengeProofValidation

```text
ChallengeProofValidation {
    proof_index: u64,
    hash_seed_value: Vec<u8>,
}
keys = [archiver_keypair, validator_keypair]
```

このトランザクションは、証明を検証する作業を行わない怠惰なバリデータを捕まえるためのものです。 アーカイバは、あるバリデータが偽の"SubmitMiningProof"トランザクションを承認したのを見たときに、このトランザクションを送信します。 アーカイバはチェーン全体を見ないライトクライアントであるため、"RPC コール"を介して、前のストレージエポックにおける特定のセグメントのすべての"ProofValidation"を取得するなどして、"バリデータ"または"バリデータのセット"にこの情報を問い合わせる必要があるでしょう。 プログラムはバリデータアカウントの状態を見て、前回の保存エポックで"ProofValidation"が提出されたことを確認し、"hash_seed_value"をハッシュ化して、そのハッシュが"SubmitMiningProof"トランザクションと一致し、バリデータがそれを有効とマークしたことを確認します。 もしそうであれば、その状態で持っているチャレンジのリストにそのチャレンジを保存します。

### AdvertiseStorageRecentBlockhash

```text
AdvertiseStorageRecentBlockhash {
    hash: Hash,
    slot: u64,
}
```

バリデータとアーカイバは、新しい保管エポックが経過し、現在の証明である保管証明が前のエポックのものになったことを示すためにこれを提出します。 他のトランザクションは、参照しているエポックが現在のチェーンの状態に応じて正確であることを確認する必要があります。
