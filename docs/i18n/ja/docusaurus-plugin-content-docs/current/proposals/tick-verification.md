---
title: ティック認証
---

この設計では、スロット内のティックの基準と検証を行います。 また、これらの条件を満たさない送信をシステムがどのように処理するかを含む、エラー処理とスラッシュ条件についても説明しています。

# スロット構造

各スロットには、`"ticks_per_slot"`で予想される数のティックが含まれている必要があります。 スロット内の最後のシュレッドには、最後のティックの全体のみが含まれていなければなりません。 また、リーダはこの最後のティックを含むシュレッドに`" LAST_SHRED_IN_SLOT" `フラグを付けなければなりません。 ティックとティックの間には、`"hashes_per_tick"`の数のハッシュがなければなりません。

# 不正な送信の処理

悪意のある送信`T`は、2 つの方法で処理されます。

1. リーダーが、重複送信のスラッシュルールに違反することなく、同じスロットに不正な送信`T`と代替の送信`T'`を生成できる場合(例えば、`T'`が`T`のサブセットである場合) クラスタは両方の送信がライブである可能性を処理しなければなりません。

これは、クラスタが`T'`について合意に達している可能性があるため、悪意のある送信`T`を死んだものとしてマークできないことを意味します。 このようなケースでは、この悪い行為を罰するためにスラッシュ証明が必要となります。

2. そうでなければ、そのスロットは死んでいてプレイできないとマークするだけです。 実現可能性に応じて、スラッシュプルーフが必要になることもあります。

# シュレッドを受け取るブロックストア

ブロックストアが新しいシュレッド`s`を受け取るとき、2 つのケースがあります。

1. `s`が`"LAST_SHRED_IN_SLOT"`とマークされている場合、そのスロットのブロックストアに`s'.index> > s.index`のシュレッド`s'が`存在するかどうかを確認します。存在する場合は、`s`と`s'`を合わせてスラッシュ証明を構成します。

2. ブロックストアは、`"LAST_SHRED_IN_SLOT"`としてマークされたインデックス`i`のシュレッド`s'`をすでに受け取っており、 `s.index> > i`であれば、`s`と`s'`を合わせてスラッシュプルーフを構成します。 この場合、ブロックストアは`s`も挿入しません。

3. 同じインデックスの重複したシュレッドは無視されます。 同じインデックスの重複したシュレッドは無視される。同じインデックスで重複していないシュレッドはスラッシュ可能な条件となります。 この場合の詳細は`"リーダ重複ブロックのスラッシュ"`の項で説明します。

# ティックの再生と検証

1. リプレイステージは、ブロックストアからのエントリを再生し、スロットごとに見たティックの数を記録し、ティックとティックの間に `"hashes_per_tick"` 数のハッシュがあることを確認します。 この最後のシュレッドからのティックが再生された後、リプレイステージはティックの合計数をチェックします。

失敗例 1：ハッシュ数が` "!= hashes_per_tick"` となる 2 つの連続したティックがあった場合、このスロットをデッドとします。

失敗例 2：スロットの 1 回あたりのティック数が`"ticks_per_slot"`に達した場合、スロットをデッドとします。

失敗例 3：ティック数が`"ticks_per_slot"`に達しても、`"LAST_SHRED_IN_SLOT"`を見ていない場合、このスロットを死んだことにします。

2. "ReplayStage"は、最後のシュレッドとしてマークされたシュレッドに到達すると、この最後のシュレッドがティックであるかどうかをチェックします。

失敗シナリオ：`"LAST_SHRED_IN_SLOT"`フラグの付いた署名付きシュレッドがティックにデシリアライズできない(デシリアライズに失敗するか、エントリーにデシリアライズされる) 場合、このスロットをデッドとマークします。
