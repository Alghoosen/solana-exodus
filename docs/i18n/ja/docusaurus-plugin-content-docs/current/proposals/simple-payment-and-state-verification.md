---
title: 簡単な支払いと状態認証
---

低リソースのクライアントが Solana クラスタに参加できるようにすることは、しばしば有用です。 この参加が経済的なものであれ、契約の実行であれ、クライアントの活動がネットワークに受け入れられたかどうかの検証は、一般的に高くつきます。 この提案は、そのようなクライアントが、最小限のリソース消費と第三者の信頼で、自分の行動が台帳の状態にコミットされたことを確認するためのメカニズムを示しています。

## ナイーブなアプローチ

バリデータは、最近確認されたトランザクションのサインを短期間保存し、二度と処理されないようにしています。 バリデータは、トランザクションが最近処理された場合、クライアントがクラスタのクエリに使用できる"JSON RPC エンドポイント"を提供します。 バリデータは"PubSub 通知"も提供しています。これは、ある署名がバリデータによって観測されたときにクライアントが登録して通知を受けるというものです。 これら 2 つの仕組みにより、クライアントは支払いを検証することができるますが、 それは証明ではなく、バリデータを完全に信頼することに依存します。

ここでは、"Merkle 証明"を使用してバリデータの応答を台帳に固定することで、 この信頼を最小限にする方法を説明します。これにより、クライアントは自分が選んだ十分な数のバリデータがトランザクションを確認したことを自分で確認できるようになります。 複数のバリデータの証明を必要とすると、他のネットワーク参加者を危険にさらすことが 技術的にも経済的にも困難になるため、バリデータへの信頼をさらに低下させることになります。

## ライトクライアント

"ライトクライアント"とは、自らはバリデータを運用していないクラスタ参加者のことです。 このライトクライアントは、リモートのバリデータを信頼する以上のセキュリティレベルを提供しますが、ライトクライアントが台帳の検証に多くのリソースを費やす必要はありません。

バリデータは、ライトクライアントにトランザクションの署名を直接提供するのではなく、対象となるトランザクションから、そのブロックを含む全トランザクションの"Merkle Tree"のルートまでの"Merkle 証明"を生成します。 この"Merkle Root"は台帳のエントリに保存され、バリデータによる投票を経て、コンセンサスの正統性を得ることができます。 ライトクライアントに追加されるセキュリティレベルは、ライトクライアントがクラスタの利害関係者とみなすバリデータの初期の正準集合に依存します。 このセットが変更されると、ライトクライアントは既知のバリデータの内部セットを[レシート](simple-payment-and-state-verification.md#receipts)で更新することができます。 これは、委任されたステーキングの数が多い場合には困難になるかもしれません。

バリデータ自身も、パフォーマンス上の理由から軽いクライアント API を使いたいと思うかもしれません。 たとえば、バリデータの初回起動時に、バリデータはクラスタが提供する 状態のチェックポイントを使用し、それをレシートで検証することができます。

## レシート

レシートとは、ある取引がブロックに含まれていること、そのブロックがクライアントの希望するバリデータのセットによって投票されたこと、その投票が望ましい確認深度に達したことを示す最小限の証明です。

### トランザクション包含の証拠

トランザクションの包含証明は、トランザクションから"Entry-Merkle"を経て"Block-Merkle"に至る"Merkle Path"を含むデータ構造であり、この"Merkle Path"は必要なバリデータ投票のセットを持つ"Bank-Hash"に含まれます。 "Bank-hash"から派生した検証者投票を含む PoH エントリーのチェーンが確認の証明となります。

#### Transaction Merkle

"Entry-Merkle"は、あるエントリーのすべてのトランザクションを含む"Merkle Root"で、署名でソートされています。 エントリ内の各トランザクションはすでにここに記載されています: "https://github.com/solana-labs/solana/blob/b6bfed64cb159ee67bb6bdbaefc7f833bbed3563/ledger/src/entry.rs#L205" つまり、ある取引`T`がエントリ`E`に含まれていたことを示すことができるのです。

"Block-Merkle"とは、ブロック内で連続するすべての"Entry-Merkles"の"Merkle Root"です。

![Block Merkle Diagram](/img/spv-block-merkle.svg)

2 つの"Merkle 証明"を合わせると、トランザクション`T`がバンクハッシュ`B`のブロックに含まれていることがわかります。

"Accounts-Hash"は、現在のスロットで変更された各アカウントの状態ハッシュを連結したハッシュです。

ブロックに対して状態のレシートが作成されるため、レシートにはトランザクションの状態が必要です。 同一の状態に対する 2 つのトランザクションがブロック内に現れる可能性があるため、台帳にコミットされたトランザクションが意図した状態の変更に成功したか失敗したかを、状態だけから推測する方法はありません。 完全なステータスコードをエンコードする必要はなく、トランザクションの成功を示す単一のステータスビットをエンコードすればよいのかもしれません。

現在、"Block-Merkle"は実装されていないため、`E`がバンクハッシュ`B`のブロック内のエントリであることを検証するには、ブロック内のすべてのエントリのハッシュを提供する必要があります。 理想的には、この"Block-Merkle"が実装されていることが望ましいのですが、それ以外の方法では非常に非効率的です。

#### ブロックヘッダ

トランザクション包含証明を検証するために、ライトクライアントはネットワーク内のフォークのトポロジーを推論できる必要があります。

具体的には、ライトクライアントは、ブロック`A`と`B`の 2 つのバンクハッシュが与えられたときに、`A`が`B`の祖先であるかどうかを判断できるように、入力されるブロックヘッダを追跡する必要があります(以下の"`楽観的確認証明"`のセクションでその理由を説明します) ヘッダの内容は、バンクハッシュを計算するのに必要なフィールドです。

バンクハッシュは、前述の"`Transaction Merkle"`のセクションで説明した" Block-Merkle"と"Accounts-Hash"を連結したハッシュです。

![Bank Hash Diagram](/img/spv-bank-hash.svg)

コード内:

https://github.com/solana-labs/solana/blob/b6bfed64cb159ee67bb6bdbaefc7f833bbed3563/runtime/src/bank.rs#L3468-L3473

```
        let mut hash = hashv(&[
            // bank hash of the parent block
            self.parent_hash.as_ref(),
            // hash of all the modifed accounts
            accounts_delta_hash.hash.as_ref(),
            // Number of signatures processed in this block
            &signature_count_buf,
            // Last PoH hash in this block
            self.last_blockhash().as_ref(),
        ]);
```

バリデータのリプレイロジックに沿って既存のストリーミングロジックを実装するのに適した場所です: https://github.com/solana-labs/solana/blob/b6bfed64cb159ee67bb6bdbaefc7f833bbed3563/core/src/replay_stage.rs#L1092-L1096

#### Optimistic Confirmation Proof

現在、楽観的な確認は、ゴシップとリプレイパイプラインの投票を監視するリスナーを介して検出されます。https://github.com/solana-labs/solana/blob/b6bfed64cb159ee67bb6bdbaefc7f833bbed3563/core/src/cluster_info_vote_listener.rs#L604-L614。

各投票は、認証者が投票したブロックのバンクハッシュを含む署名付き取引です。つまり、上記の`"Transaction Merkle"`セクションの`B`です。 ネットワークのある閾値`T`がブロックに投票した時点で、そのブロックは最適に確認されたとみなされます。 この`T`人のバリデータによる投票は、バンクハッシュ`B`のブロックが最適に確認されたことを示すのに必要です。

しかし、いくつかのメタデータを除いて、署名された投票自体は現在どこにも保存されていませんので、必要に応じて取得することはできません。 これらの投票はおそらく"Rocksdb"データベースに保存され、投票のスロット、投票のバンクハッシュ、投票を担当する"vote account pubkey"を表すキー`(Slot, Hash, Pubkey)`でインデックス化される必要があります。

既存の署名サブスクライブロジックを拡張することで、トランザクションメルクルプルーフと楽観的確認プルーフを合わせて RPC 経由でサブスクライバーに提供することができます。 楽観的な確認が検出された場合、"SingleGossip"確認レベルをサブスクライブしているクライアントには既に通知されており、上記の 2 つの証明も返すべきであることを示すフラグを提供することができます。

楽観的に`B`を確認することは、`B`のすべての祖先ブロックも楽観的に確認されることを意味し、すべてのブロックが楽観的に確認されるわけではないことに注意することが重要です。

```

B -> B'

```

したがって、ある取引がブロック`B`にあった場合、証明書に記載されている取引のメルクルはブロック`B`のものになりますが、 ある取引がブロック`B`にあった場合、証明書の中の取引のマークルはブロック`B`のものになりますが、証明書の中で提示される投票はブロック`B'`のものになります。 クライアントは`B`が`B'`の祖先であることを確認する必要がありますが、上述の`"ブロックヘッダ"`セクションのヘッダが重要である理由はここにあります。

#### Proof of Stake Distribution

上記のトランザクション・マークルと楽観的確認の証明が提示されると、クライアントはトランザクション`T`がバンクハッシュ`B`を持つブロックで楽観的に確認されたことを検証することができます。 最後に欠けているのは、上記の楽観的な証明における投票が、"楽観的な確認"の安全性の保証を維持するために必要な、有効な`T`割合の出資を実際に構成していることを、どのようにして確認するかということです。

この方法の 1 つは、エポック毎にステークセットが変更されたときに、すべてのステーキングをシステムアカウントに書き込み、バリデータにそのシステムアカウントをサブスクライブさせることです。 フルノードは、あるブロック`B`でシステムアカウントの状態が更新されたことを証明するメルクルを提供し、そのブロック`B`が楽観的に確認された/根付いたことを示すことができます。

### Account State Verification

アカウントの状態(残高やその他のデータ) は、**_TBD Instruction_**を持つトランザクションをクラスタに送信することで検証できます。 その後、クライアントは[Transaction Inclusion Proof](#transaction-inclusion-proof)を使用して、アカウントが期待される状態に達したことにクラスタが同意するかどうかを検証できます。

### バリデーター投票

リーダーは、ステーキング荷重ごとのバリデータ投票を 1 つのエントリにまとめてください。 これにより、レシート作成に必要なエントリ数を減らすことができます。

### エントリのチェーン

レシートには、"ペイメント"または"ステート"の"Merkle Path"ルートから、連続する検証票のリストへの PoH リンクがあります。

それは次のようなものを含んでいます。

- Transaction -&gt; Entry-Merkle -&gt; Block-Merkle -&gt; Bank-Hash

そして、PoH エントリのベクトル。

- 検証票エントリ
- ティック数
- ライトエントリ

```text
/// This Entry definition skips over the transactions and only contains the
/// hash of the transactions used to modify PoH.
LightEntry {
    /// The number of hashes since the previous Entry ID.
    pub num_hashes: u64,
    /// The SHA-256 hash `num_hashes` after the previous Entry ID.
    hash: Hash,
    /// The Merkle Root of the transactions encoded into the Entry.
    entry_hash: Hash,
}
```

ライトエントリは"Entries"から再構成され、完全なトランザクションセットではなく、PoH ハッシュに混入されたエントリ"Merkle Root"を表示するだけです。

クライアントは開始時の投票状態を必要としません。 [フォーク選択](../implemented-proposals/tower-bft.md)アルゴリズムは、トランザクションの後に現れる投票のみがトランザクションの最終性を提供するように定義されており、最終性は開始状態に依存しません。

### 検証

超過半数セットのバリデータを知っているライトクライアントは、"Merkle Path"を辿って PoH チェーンに到達することでレシートを検証することができます。 "Block-Merkle"は"Merkle Root"であり、エントリに含まれる投票に表示されます。 ライトクライアントは、連続した投票の[フォーク選択](../implemented-proposals/tower-bft.md)をシミュレートし、希望するロックアウト閾値で受領が確認されたことを検証できます。

### Synthetic State

合成された状態は、銀行が生成した状態と一緒に"Bank-Hash"に計算されなければなりません。

例えば、以下のようになります。

- エポック社のバリデーターアカウントとそのステーキングやウェイト。
- 計算された手数料率

これらの値は"Bank-Hash"にエントリされるべきです。 これらの値は既知のアカウントの下に置かれるべきであり、したがってハッシュの連結にインデックスを持つべきです。
