---
title: Embedding the Move Language
---

## 問題

Solana では、開発者が C や Rust などの汎用プログラミング言語でオンチェーンプログラムを書くことができますが、それらのプログラムには Solana 特有の仕組みが含まれています。 例えば、`"process_instruction(KeyedAccounts)"`関数を持つ Rust モジュールの作成を開発者に依頼するチェーンは他にありません。 実用的な場合はいつでも、Solana はアプリケーション開発者に、よりポータブルなオプションを提供すべきです。

つい最近まで、人気のあるブロックチェーンでは、Solana の超並列[ランタイム](../validator/runtime.md)の価値を公開できる言語を提供していませんでした。 例えば"Solidity コントラクト"は、共有データへの参照をコントラクトコードから分離していないため、決定論的な動作を確保するためにはシリアルで実行する必要があります。 実際には、最も積極的に最適化された"EVM ベースのブロックチェーン"でも、ピーク時には 1,200TPS 程度となり、Solana の能力のごく一部に過ぎないことがわかります。 一方、Libra プロジェクトでは、並列実行に適した"Move"というオンチェーンプログラミング言語を設計しました。 Move プログラムは、Solana のランタイムと同様に、すべての共有状態をアカウントに依存しています。

Solana のランタイムと Libra の"Move VM"の設計上の最大の違いは、モジュール間の安全な呼び出しを管理する方法です。 Solana はオペレーティングシステムのアプローチを取り、Libra はドメイン固有言語のアプローチを取りました。 ランタイムでは、モジュールがランタイムにトラップバックして、呼び出し元のモジュールが呼び出し先の所有するデータに書き込まれていないことを確認しなければなりません。 同様に、呼び出し側が完了すると、呼び出し側が呼び出し側のデータに書き込んでいないことを確認するために、再びランタイムにトラップバックする必要があります。 一方、Move には高度な型システムが搭載されており、これらのチェックを"bytecode verifier"で実行することができます。 Move のバイトコードは検証できるので、検証のコストは、モジュールがオンチェーンでロードされるときに一度だけ支払われます。 一方、ランタイムでは、モジュール間でトランザクションが交差するたびにコストが発生します。 この違いは、"Python"のような動的に型付けされた言語と、"Java"のような静的に型付けされた言語の違いに似ています。 Solana のランタイムでは、アプリケーションを汎用のプログラミング言語で書くことができますが、それにはプログラム間をジャンプする際のランタイムチェックというコストがかかります。

この提案は、Move VM を以下のように埋め込む方法を定義しようとするものです。

- "Move 内"でのモジュール間の呼び出しは、ランタイムのプログラム間のランタイムチェックは必要ありません。

  プログラム間のランタイムチェック

- Move プログラムは他の Solana プログラムの機能を利用でき、その逆も可能です。

  逆もまた然りです。

- Solana のランタイムの並列性は、Move と非 Move のバッチにさらされます。

  トランザクション

## 提案された解決策

### ソラナローダとしての Move VM

Move VM は、`"MOVE_PROGRAM_ID"`という識別子で Solana ローダーとして組み込まれ、Move モジュールが VM を`所有者`として`実行可能`とマークされるようにします。 これにより、モジュールはモジュールの依存関係をロードすることができ、また、Move スクリプトの並列実行も可能になります。

Move モジュールが所有するすべてのデータアカウントは、そのオーナーをローダである`"MOVE_PROGRAM_ID"`に設定しなければなりません。 Move モジュールは、Solana プログラムがアカウントデータをカプセル化するのと同じように、アカウントデータをカプセル化するので、Move モジュールのオーナーはアカウントデータに埋め込まれなければなりません。 ランタイムは Move VM への書き込みアクセスを許可し、Move はモジュールのアカウントへのアクセスを許可します。

### Solana プログラムとの相互作用

非 Move プログラムで命令を呼び出すためには、Solana は Move VM を`"process_instruction()"`システムコールで拡張する必要があります。 これは`"process_instruction() Rust BPF"`プログラムと同じように動作します。
