---
title: 安全な投票署名
---

## 安全な投票署名

この設計では、プロセスをより安全にするための追加の投票署名動作について説明します。

現在、Solanaでは、各投票がスラッシュ条件に違反していないかどうかを評価する投票署名サービスを実装しています。 このサービスは、ハードウェアプラットフォームの能力に応じて、さまざまなバリエーションを持つ可能性があります。 具体的には、/(SGXのような\) "Secure Enclave"と組み合わせて使用することができます。 エンクレーブは非対称キーを生成し、ユーザーが投票トランザクションに署名するための\(信頼されていない\) APIを公開し、投票署名用の秘密キーを保護されたメモリに保持することができます。

以下のセクションでは、このアーキテクチャがどのように機能するかを説明します。

### メッセージ フロー

1. ノードは起動時にエンクレイブを初期化します

   - エンクレイブは非対称鍵を生成し，その公開キーを

     ノードに返します。

   - キーペアは一過性のものです。 ノードの起動時に新しいキーペアが生成されます。 新しい

     キーペアは、ランタイムに決定される基準に基づいて生成されることも

     あります。

   - エンクレーブは認証レポートをノードに返します。

2. ノードはエンクレーブの認証を行います。\(例：Intel's IAS APIsの使用\)

   - ノードは、セキュアエンクレイブがTPM上で実行されていること、

     および信頼できる当事者によって署名されていることを確認します。

3. ノードのステーキングホルダーは、そのステーキングを使用するためのエフェメラルキーの許可を与えます。

   このプロセスは決定されます。

4. ノードの信頼されていない非エンクレイブソフトウェアは、そのインターフェースを使って信頼されたエンクレイブソフトウェアを呼び出し、

   トランザクションやその他のデータに署名します。

   - 票の署名の場合、ノードはPoHを検証する必要があります。 PoH

     の検証は、署名の不可欠な部分です。 エンクレーブには、

     投票の署名を行う前にチェックする検証可能なデータが提示されます。

   - 信頼されていない空間で検証可能なデータを生成するプロセスを決定する必要があります。

### PoH認証

1. ノードが"en"のエントリ`X`に投票するとき、ロックアウト期間`N`があり、

   その間は`X`を履歴に含まないフォークには投票できません。

2. ノードが`X`の派生版`（X+y）`に投票するたびに、

   `X`のロックアウト期間は`F`\(i.e. the duration node cannot vote on

   \つまり、ノードが`X`を含まないフォークに投票できない期間が増加するということです\)。

   - `X+y`のロックアウト期間は、ノードが再度投票するまで`N`のままです。

3. ロックアウト期間の増加には上限があります。(例: factor `F` に制限されます。

   最大32個まで適用されます\)。

4. 署名エンクレーブは、このポリシーに違反した投票に署名してはなりません。 これは

   以下を意味します。

   - エンクレーブは`"N"`、`"F"`、`"ファクターキャップ"`で初期化されます。
   - エンクレーブは、そのノードが以前に投票したエントリーIDの`ファクターキャップ`数

     を記憶します。

   - 署名要求には新しい投票のエントリIDが含まれます。
   - エンクレーブは新しい投票のエントリIDが正しいフォークにあることを検証します。

     \(following the rules \#1 and \#2 above\)

### 祖先の確認

これは、確実ではないものの、投票フォークを検証するための別の方法です。 1. バリデータはクラスタ2内のノードのアクティブセットを保持します。 バリデータは直近の投票期間3におけるアクティブセットからの投票を観察します。 各ノードが4に投票した際の "ancestor/last_tick" を保存します。 新しい投票要求を "voting-signing" サービスに送信します。

- アクティブセットに含まれるノードの過去の投票と、

  それに対応する祖先の投票が含まれます。

  1. 署名者は、前回の投票にバリデータからの投票が含まれていて、

     かつ投票の祖先がノードの過半数と一致するかどうかをチェックします。

- チェックが成功した場合、新しい投票に署名します。
- チェックに失敗した場合は"アサート"\(ある種の警報を発します\) を行います。

前提として、バリデータは最大で一度だけ偽装されて不正なデータに投票される可能性があります。 もし誰かがバリデータを乗っ取り、不正なデータへの投票要求を送信した場合、その投票はPoHに含まれません\(クラスタによって拒否されるため\)。 次にバリデータが投票依頼を出したとき、署名サービスはバリデータの最後の投票がなくなっていることを検知するでしょう\(as part of

## \（上記の5つのうちの1つとして\)。

### フォークの決定

エンクレーブはPoHを処理できないため、提出されたバリデータの投票の フォーク履歴を直接知ることはできません。 各エンクレーブは、現在_有効な公開キー群_で開始されるべきです。 バリデータは自分の現在の投票と、前回の投票の際に観測した有効な公開キーセット\(自分自身を含む\) の投票を提出します。 こうすることで、エンクレーブはバリデータの前回の投票に付随する票を推測することができ、 投票されているフォークを推測することができます。 バリデータが最初に提出した投票は、参照すべき "前回 "のスロットを持たないので、 これは不可能です。 これを考慮して、最初の投票の高さにある有効なセット内の票と自分の投票を含んだ2回目の投票が提出されるまで、短い投票凍結を適用すべきです。

### エンクレーブの構成

ステーキングクライアントは、非アクティブなフォークへの投票を防ぐように設定できるべきです。 この機構は、クライアントの既知のアクティブセット` N_active` と、閾値投票数` N_vote` と閾値深度` N_depth` を用いて、提出されたフォークへの投票を継続するかどうかを決定するべきです。 この設定は、クライアントが`N_depth`で`N_vote`以上の投票を観測した場合にのみフォークに投票するというルールの形をとるべきです。 実際には、これはクライアントが提出されたフォークの経済的最終性の確率を、追加の投票によってフォークが生きていないことが判明した場合に望ましくない時間のロックアウトが発生するような深さで観測したことを確認するためのものです。

### チャレンジ

1. 信頼されていない空間で検証可能なデータを生成し、飛び地でPoHの検証

   を行います。

2. エフェメラルキーにステーキングを付与するためのインフラが必要です。
