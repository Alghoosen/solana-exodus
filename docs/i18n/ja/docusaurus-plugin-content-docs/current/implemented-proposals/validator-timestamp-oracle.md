---
title: Validator Timestamp Oracle
---

Solanaの第三者ユーザーは、ブロックが生成された実世界の時間を知りたいと思うことがあります。これは一般的に、外部監査人や法執行機関のコンプライアンス要件を満たすためです。 この提案は、Solanaクラスタがこのようなニーズを満たすためのバリデータのタイムスタンプオラクルについて説明するものです。

提案の概要は以下の通りです。

- 各バリデータは一定の間隔で、チェーン上の既知のスロットの観測時刻を記録します(スロットVoteに追加されたTimestampを介して)
- クライアントは`getBlockTime` RPCメソッドを使って、ルート化されたブロックのブロックタイムを要求することができます。 クライアントが"ブロックN"のタイムスタンプを要求すると次のようになります。

  1. バリデータは、台帳に記録されているタイムスタンプ付きの"Vote命令"のうち、そのスロットを参照しているものをすべて観察し、ステーキング加重平均のタイムスタンプを決定することで、"ブロックN"の前の最近のタイムスタンプ付きスロットの"クラスタ"タイムスタンプを決定します。

  2. この最近の平均タイムスタンプは、クラスタの確立されたスロット期間を使用して"ブロックN"のタイムスタンプを計算するために使用されます。

要件:

- 将来的に台帳を再生する検証者は、生成時からのすべてのブロックについて同じ時間を算出しなければなりません。
- 推定されたブロックタイムは、現実世界(オラクル) のデータに変換されるまで、1時間程度以上の誤差があってはなりません。
- ブロックタイムは1つの中央のオラクルが管理するのではなく、すべてのバリデータからの入力を利用した関数に基づくのが理想的です。
- 各バリデータはタイムスタンプのオラクルを保持しなければなりません。

同じ実装で、まだルート化されていないブロックのタイムスタンプ推定値を提供することができます。 しかし、タイムスタンプが付与された最新のスロットはまだルート化されていない可能性があるため、このタイムスタンプは不安定になります(要件1が満たされない可能性があります) 初期の実装では、ルート化されたブロックを対象としていますが、もし最近のブロックのタイムスタンプの使用例があれば、将来的に"RPC apis"を追加することは容易でしょう。

## 記録時間

特定のスロットに投票する際、各バリデータは一定時間ごとにタイムスタンプを"Vote命令"の送信内容に含めて、観測した時間を記録します。 このタイムスタンプに対応するスロットは、Voteベクトル(`Vote::slots.iter().max()`)の中で最も新しいスロットです。 これは通常の"Vote"と同様に"バリデータのIDキーペア"で署名されます。 この報告を可能にするためには、"Vote"構造体を拡張して、タイムスタンプフィールドは`timestamp: Option<UnixTimestamp>`となります。これは、ほとんどの投票で`None`に設定されます。

"https://github.com/solana-labs/solana/pull/10630の時点で"、バリデータは投票ごとに タイムスタンプを送信します。 これにより、"ブロックタイムキャッシングサービス"の実装が可能となり、ノードはブロックがルート化された直後に推定タイムスタンプを計算し、その値をブロックストアにキャッシュすることができます。 上記1) の要件を満たしながら、"永続的なデータ"と"迅速なクエリ"を提供します。

### アカウントに投票

バリデータの投票アカウントは、VoteStateに最新のスロットタイムスタンプを保持します。

### 投票プログラム

オンチェーンのVote プログラムは、バリデータからの指示で送信されたタイムスタンプを処理するために拡張する必要があります。 このプロセスでは、現在のprocess_voteの機能(正しいVoteアカウントの読み込みや、トランザクションの署名者が想定される検証者であることの確認など) に加えて、タイムスタンプと対応するスロットを現在保存されている値と比較して、両者が単調に増加していることを確認し、新しいスロットとタイムスタンプをアカウントに保存する必要があります。

## ステーキング荷重平均タイムスタンプの計算

特定のブロックの推定タイムスタンプを計算するには、バリデータが最も最近のタイムスタンプスロットを識別する必要があります。

```text
let timestamp_slot = floor(current_slot / timestamp_interval);
```

次にバリデータは、`Blockstore::get_slot_entries()`を使って、台帳からそのスロットを参照している "Vote WithTimestamp" トランザクションをすべて収集する必要があります。 これらのトランザクションはリーダに到達して処理されるまでに 時間がかかっている可能性があるので、妥当なタイムスタンプのセットを得るために、 バリデータは "timestamp_slot" の後のいくつかの完了したブロックをスキャンする必要があります。 スロットの正確な数は調整する必要があります。スロット数が多ければ、クラスタの参加率が高まり、タイムスタンプのデータポイント数が増えます。スロット数が少なければ、タイムスタンプのフィルタリングにかかる時間が短くなります。

このトランザクションのコレクションから、バリデータはステーキング加重平均タイムスタンプを計算し、`staking_utils:::staked_nodes_at_epoch()` からエポックステーキングを相互参照します。

台帳を再生するバリデータは、同じ数のスロットからタイムスタンプトランザクションを処理することによって、同じステーキング加重平均タイムスタンプを生成する必要があります。

## 特定ブロックの推定時間の計算

既知のスロットの平均タイムスタンプが計算されると、後続の"ブロック N"の推定タイムスタンプを計算することは些細なことです:

```text
let block_n_timestamp = meat_timestamp + (block_n_slot_offset * slot_duration);
```

ここで、`block_n_slot_offset`は、"ブロックNのスロット"と"timestamp_slot"の差であり、`slot_duration`は、各Bankに格納されているクラスタの`slots_per_year`から得られます。
