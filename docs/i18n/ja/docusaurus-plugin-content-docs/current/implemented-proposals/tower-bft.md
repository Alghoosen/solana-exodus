---
title: Tower BFT
---

このデザインは、Solana の _Tower BFT_ アルゴリズムを説明します。 以下の問題に対処します。

- フォークの中にはクラスタの超過半数に受け入れられないものもあり、投票者はそのようなフォークへの投票から回復する必要があります。
- 多くのフォークは異なる投票者によって投票可能であり、各投票者は異なる投票可能なフォークのセットを見ることになるかもしれません。 選択されたフォークは最終的にはそのクラスタに収束するはずです。
- 報酬型投票にはリスクが伴います。 投票者はどの程度のリスクを負うかを設定できるようにすべきです。
- ロールバックの [コスト](tower-bft.md#cost-of-rollback) は計算可能である必要があります。 これは、測定可能な形の一貫性に依存しているクライアントにとって重要です。 一貫性を崩すためのコストは計算可能である必要があり、古い投票では超線形的に増加します。
- ASIC の速度はノードごとに異なり、攻撃者はクラスタの残りの部分よりもはるかに高速な"Proof of History ASICS"を採用することができます。 コンセンサスは、履歴証明 ASIC の速度のばらつきを利用した攻撃に対抗する必要があります。

簡潔にするために、このデザインでは、利害関係を持つ一人の投票者がクラスター内の個々のバリデータとして配置されていると仮定しています。

## 時間

Solana クラスターは、[Proof of History](../cluster/synchronization.md)と呼ばれる検証可能な遅延関数によって時間のソースを生成します。

"Proof of History"は、すべてのアクティブなリーダーの決定論的なラウンドロビンのスケジュールを作成するために使用されます。 ある時点でフォークを提案できるリーダーは、台帳から計算される 1 人だけです。 詳細については、 [](../cluster/fork-generation.md) と [leader rotation](../cluster/leader-rotation.md) を参照してください。

## ロックアウト

ロックアウトの目的は、バリデータに特定のフォークへの機会損失のコミットを強いることです。 ロックアウトの単位はスロットであり、これはバリデータがフォークへのコミットを解除するまでに必要な、リアルタイムの強制的な遅延を表しています。

ロックアウトに違反し、ロックアウトの範囲内で分岐フォークに投票したバリデータは罰せられるべきです。 提案されている罰則は、ロックアウト内での非派生フォークへの同時投票がクラスターに証明された場合、バリデータの出資比率を下げるというものです。

## アルゴリズム

このアプローチの基本的な考え方は、"コンセンサス投票"と"ダブルロックアウト"を積み重ねることです。 スタック内の各投票はフォークの確認です。 確認された各フォークは、その上のフォークの祖先です。 各投票には、確認されたフォークを祖先に持たない投票を検証者が提出するまでの、 スロット単位での`ロックアウト`があります。

投票がスタックに追加されると、スタック内の過去の全ての投票のロックアウトは 2 倍になります。\(詳細は [Rollback](tower-bft.md#Rollback)\で述べます)。 新しい票が増えるたびに、バリデータはそれまでの票をどんどんロックアウトしていきます。 32 票で投票を `最大ロックアウト` とみなすことができます。ロックアウトは `1<<32` 以上で行われます\(FIFO\).。 投票のキューイング解除は、報酬を得るためのトリガーとなります。 ロックアウトが解除される前に投票が期限切れになった場合、 その票とその票より上の票は投票スタックから削除されます\(LIFO\)。 バリデータはその時点からスタックの再構築を始める必要があります。

### ロールバック

票がスタックにプッシュされる前に、新しい票よりもロックタイムが短い票に至るまでのすべての票がポップされます。 ロールバック後は、バリデータがロールバック時の票の高さに追いつくまでロックアウトは倍になりません。

例えば、以下の状態で投票スタックを行います。

| 投票 | 投票時間 | ロックアウト | ロック有効期限 |
| ---: | -------: | -----------: | -------------: |
|    4 |        4 |            2 |              6 |
|    3 |        3 |            4 |              7 |
|    2 |        2 |            8 |             10 |
|    1 |        1 |           16 |             17 |

_投票 5_ は 9 時で、結果の状態は

| 投票 | 投票時間 | ロックアウト | ロック有効期限 |
| ---: | -------: | -----------: | -------------: |
|    5 |        9 |            2 |             11 |
|    2 |        2 |            8 |             10 |
|    1 |        1 |           16 |             17 |

_投票 6_ は 10 時です

| 投票 | 投票時間 | ロックアウト | ロック有効期限 |
| ---: | -------: | -----------: | -------------: |
|    6 |       10 |            2 |             12 |
|    5 |        9 |            4 |             13 |
|    2 |        2 |            8 |             10 |
|    1 |        1 |           16 |             17 |

時刻 10 では、新しい票が前の票に追いつきました。 しかし、*投票 2*の有効期限は 10 時なので、11 時の*投票 7*を適用すると、*投票 2*を含む以上の票が弾かれることになります。

| 投票 | 投票時間 | ロックアウト | ロック有効期限 |
| ---: | -------: | -----------: | -------------: |
|    7 |       11 |            2 |             13 |
|    1 |        1 |           16 |             17 |

投票 1 のロックアウトは、スタックに 5 票が含まれるまで 16 から増加しません。

### スラッシングと報酬

バリデータは、クラスタの他のメンバーが選択したフォークをできるだけ頻繁に選択することで報酬を得るべきです。 これは、投票スタックが一杯になって最も古い投票をデキューする必要があるときに報酬を発生させることとよく一致しています。 したがって、"デキュー"に成功するたびに報酬を発生させるべきです。

### ロールバックのコスト

*フォーク A*のロールバックのコストとは、*フォーク A*を祖先に含まない他のフォークを確認するためにバリデータが要するロックアウト時間のコストと定義されます。

The **Economic Finality** of _fork A_ can be calculated as the loss of all the rewards from rollback of _fork A_ and its descendants, plus the opportunity cost of reward due to the exponentially growing lockout of the votes that have confirmed _fork A_.

### しきい値

各バリデータは、そのバリデータがフォークにコミットする前に、クラスタのコミットの閾値を独自に設定することができます。 例えば、投票スタックのインデックス 7 では、ロックアウトは 256 時間単位です。 あるバリデータは、インデックス 7 の投票がクラスタ内で 50%以上のコミットを得られない限り、投票を保留し、投票"0 ～ 7"を失効させることができます。 これにより、各バリデータはフォークにコミットするリスクの大きさを独立して制御することができます。 より高い頻度でフォークにコミットすれば、バリデータはより多くの報酬を得ることができます。

### アルゴリズムパラメータ

次のパラメータを調整する必要があります:

- Dequeue が発生する前のスタック内の投票数\(32\)。
- スタック\(2x\) 内のロックアウトの成長率。
- デフォルトのロックアウトを開始中 \(2\).
- "fork (8\)" にコミットする前の最小クラスタコミットのしきい値。
- しきい値深度\(50%+\) の最小クラスタコミットメントサイズ。

### 自由選択

自由選択は "強制力のないバリデータのアクションです。 各バリデータがコードを修正してアルゴリズムを調整できるので、 プロトコルがこれらのアクションを符号化して強制する方法はありません。 すべての可能な未来に対して自己報酬を最大化するバリデータは、 システムが安定するような行動をとるべきであり、ローカルな欲張り選択は すべての可能な未来に対して欲張りな選択をもたらすべきです。 プロトコルを破壊するような選択を行うバリデータの集合は、サービス拒否に対する賭けの重み付けによって拘束されるべきです。 バリデータには 2 つの選択肢があります。

- バリデータは仮想生成において前のバリデータを凌駕し、同時進行のフォークを提出することができます。
- バリデータは投票を保留して、投票前に複数のフォークを観察することができます。

どちらの場合も、クラスタ内のバリデータは、それぞれのフォークが異なる高さを表しているにもかかわらず、複数のフォークから同時に選択することができます。 どちらの場合も、バリデータの動作が意図的なものかどうかをプロトコルで検出することはできません。

### 同時進行のフォークに対する貪欲な選択

複数のフォークを評価する場合、各バリデータは以下のルールを使用します。

1. フォークは _しきい値_ ルールを満たす必要があります。
2. すべての祖先フォークのクラスタロックアウト時間の合計を最大にするフォークを選びます。
3. クラスタトランザクション手数料が最も高いフォークを選びます。
4. "PoH"の観点から最新のフォークを選んでください。

クラスター取引手数料は、 [ステーキング報酬](staking-rewards.md) のセクションに記載されているように、マイニングプールに入金される手数料です。

## PoH ASIC Resistance

投票とロックアウトは指数関数的に増加しますが、"ASIC"のスピードアップは線形です 高速化した"ASIC"には、2 つの攻撃方法があります。

### ASIC censorship

攻撃者は、これまでのリーダを凌駕するような同時進行のフォークを生成し、検閲を行おうとします。 この攻撃者によって提案されたフォークは、次に利用可能なリーダと同時に利用可能となります。 ノードがこのフォークを選択するには、 _貪欲な選択_ ルールを満たす必要があります。

1. フォークには、祖先フォークの票数が同じである必要があります。
2. フォークは期限切れの投票を引き起こすためにこれまでのところヘッドではありません。
3. フォークには、より多くのクラスタ取引手数料が必要です。

この攻撃は、以前のリーダの料金や個々の取引を検閲することに限定されます。 しかし、クラスタを停止させたり、同時フォークに比べてバリデータセットを減らすことはできません。 料金の検閲は、リーダへのアクセス料金に限られ、バリデータへのアクセス料金は検閲できません。

### ASIC Rollback

攻撃者は、古いブロックから同時実行フォークを生成し、クラスタをロールバックさせようとします。 この攻撃では、同時実行のフォークは、すでに投票されたフォークと競合します。 この攻撃は、ロックアウトの指数関数的な成長によって制限されます。

- "1 票"は"2 スロット"のロックアウトがあります。 同時フォークは少なくとも"2 スロット"先にあり、"1 スロット"で生産されなければなりません。 したがって、"ASIC の 2 倍高速化"が必要です。
- "2 票"は"4 スロット"のロックアウトを持っています。 同時フォークは少なくとも"4 スロット"先にあり、"2 スロット"で生産されなければなりません。 したがって、"ASIC"の 2 倍高速化が必要です。
- "3 票"は"8 スロット"のロックアウトを持っています。 同時フォークは少なくとも"8 スロット先"にあり、"3 スロット"で生産されなければなりません。 したがって、"ASIC 2.6 倍高速化"が必要です。
- "10 票"は"1024 スロット"のロックアウトを持っています。 "1024/10"、または"102.4 倍高速 ASIC"。
- "20 票"は"2^20 スロット"のロックアウトを持っています。 "2^20/20"、または"52,428.8 倍高速 ASIC"。
