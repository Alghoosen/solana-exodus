---
title: リーダ同士の移行
---

このデザインは、各リーダが独自のスロットを生成する際に、リーダ同士が PoH 台帳の生産を移行する方法を示しています。

## チャレンジ

現在のリーダと次のリーダは、現在のスロットの最終ティックを生成するために競争しています。 現在のリーダのエントリーを処理している間に、次のリーダがそのスロットに到着する可能性があります。

理想的なシナリオは、カレントリーダに投票できた直後に、ネクストリーダが自分のスロットを生成することです。 現在のリーダがブロック全体の放送を終える前に、次のリーダが自分の PoH スロットの高さに到着する可能性は非常に高いです。

次のリーダは、最後に完了したブロックに自分のブロックを添付するか、保留中のブロックが確定するのを待つかの判断を迫られます。 次のリーダは、現在のリーダが失敗したことを提案するブロックを生成する可能性がありますが、ネットワークの他の部分ではそのブロックが成功していると観察されています。

現在のリーダには、経済的報酬を得るためにできるだけ早くスロットを開始するというインセンティブがあります。 このインセンティブは、リーダが自分のブロックをネットワークの他の部分から最もコミットされているブロックに添付する必要性とバランスをとる必要があります。

## リーダタイムアウト

リーダが前のスロットのエントリーを積極的に受信している間、リーダは自分のブロックの開始をリアルタイムで放送するのを遅らせることができます。 遅延時間は各リーダがローカルに設定可能で、前のリーダの動作に基づいて動的に設定することができます。 前のリーダのブロックがタイムアウト前にリーダの TVU によって確認された場合、PoH はスロットの開始位置にリセットされ、このリーダは直ちにそのブロックを生成します。

欠点:

- リーダが自分のスロットを遅らせることで、次のリーダが追いつくまでの時間が長くなる可能性があります

  。

ガードと比較してのアップサイド

- ブロック内のすべてのスペースがエントリーに使用されます。
- タイムアウトは固定ではありません。
- タイムアウトはリーダーのローカルなものであるため、巧妙に設定できます。 リーダーのヒューリスティックは、タービンの性能を考慮することができます。
- このデザインでは、更新のために台帳をハードフォークする必要がありません。
- 前のリーダはブロックの最後のエントリを次のリーダに冗長的に送信し、次のリーダは前のブロックの検証なしに、それを信頼してブロックを生成することを投機的に決定することができます。
- リーダは、最後に受信したエントリから最後のティックを推測的に生成することができます。
- リーダは推測的にトランザクションを処理し、どのトランザクションが前のリーダによってエンコードされないのかを推測することができます。 これは検閲攻撃のベクトルでもあります。 現在のリーダは、クライアントから受け取ったトランザクションを保留して、自分のスロットにエンコードすることができます。 処理されたエントリは、素早く PoH に再生されます。

## 代替設計オプション

### スロットの最後にガードのティックを入れる

リーダーは、次のスロットの最初のティックの前の最後の目盛りである*最後から二番目ティック*以降は、そのブロックのエントリーを作成しません。 ネットワークは*最後のティック*で投票するので、*最後から二番目のティック*と*最後のティック*の時間差は、新しいスロットが生成される前の次のリーダと同様に、ネットワーク全体の強制的な遅延となります。 ネットワークは、*最後から二番目のティック*から*最後のティック*を生成することができます。

次のリーダーが*自分の最初のティック*を生成する前に、*最後から二番目のティック*を受け取った場合、そのリーダーは PoH をリセットし、前のリーダーの*最後から二番目のティック*から*最初のティック*を生成します。 ネットワークの他のメンバーも PoH をリセットして、*最後のティック*を投票対象の ID として生成します。

欠点:

- すべての投票、つまり確認は、固定のタイムアウトによって遅延されます。 1 ティック、つまり約 100ms です。
- トランザクションの平均的な確認時間は、少なくとも 50ms は悪化します。
- これは台帳の定義の一部なので、この動作を変更するにはハードフォークが必要です。
- 利用可能なスペースのすべてがエントリーに使われるわけではありません。

リーダタイムアウトに比べての利点

- 次のリーダは前のエントリをすべて受信しているので、PoH に記録することなく取引の処理を開始することができます。
- 前任のリーダは、最後のエントリに含まれる*最後から二番目のティック*を次のリーダに冗長的に送信することができます。 次のリーダーは、*最後のティック*を受信するとすぐに、それを検証する前であっても、*最後から二番目のティック*を投機的に生成することができます。
