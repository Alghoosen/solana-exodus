---
title: 信頼性の高い票の送信
---

バリデータの投票は、ネットワークのコンセンサスと継続的な運用に重要な役割を果たすメッセージである。 したがって、これらのメッセージが確実に配信され、台帳にエンコードされることが重要である。

## チャレンジ

1. リーダローテーションは、ドリフトの大きいクロックであるPoHによって引き起こされます。 そのため、多くのノードは次のリーダがリアルタイムに活動しているかどうかを正しく認識できません。
2. 次のリーダは簡単にフラッディングされる可能性があります。 そのため"DDOS"が発生すると、通常のトランザクションだけでなくコンセンサスメッセージの配信もできなくなります。
3. UDPは信頼性が低く、私たちの非同期プロトコルでは、送信されたメッセージは台帳で観測されるまで再送信される必要があります。 再送信は、多数の検証者がいるリーダーに対して_意図しない雷_のような群れを引き起こす可能性があります。 最悪の場合、洪水は`(num_nodes * num_retransmits)`となります。
4. 投票が送信されたかどうかを台帳で追跡しても、それが確定したブロックに表示されることは保証されません。 現在観測されているブロックが巻き戻される可能性もあります。 バリデータは各投票とフォークの状態を維持する必要があります。

## デザイン

1. 投票をゴシップによるプッシュメッセージとして送信します。 これにより、次の未来のリーダーだけでなく、すべての次のリーダに確実に投票を届けることができます。
2. リーダは"Crdsテーブル"を読んで新しい票を探し、受け取った新しい票を自分が提案するブロックにエンコードします。 これにより、将来のリーダ全員によるロールバックフォークにバリデータの票を含めることができます。
3. 台帳で票を受け取ったバリデータは、プッシュリクエストではなく、単に自分のローカルな"crdsテーブル"に票を追加します。 これはプッシュメッセージのプロトコルを短縮するもので、検証メッセージをネットワーク上で2回再送する必要がありません。
4. 投票のための"CrdsValue"はこのようになります `Votes(Vec<Transaction>)`

各投票トランザクションは、そのデータに `ウォールクロック` を維持する必要があります。 投票のマージ戦略は、ローカルクライアントによって構成された最後のNセットの投票を保持します。 "push/pull"については、ベクターは再帰的に走査され、各トランザクションはそれ自身のローカルな"ウォールクロック"と署名を持つ、個々の"CrdsValue"として扱われます。

ゴシップは、状態を効率的に伝播するように設計されています。 "gossip-push"で送信されたメッセージはバッチ処理され、最小スパニングツリーでネットワークの残りの部分に伝搬されます。 ツリー内の部分的な障害は、ゴシッププルプロトコルによって積極的に修復され、ノード間で転送されるデータ量は最小限に抑えられます。

## このデザインがチャレンジをどのように解決するか

1. バリデータがリーダの "active "な状態を同期する簡単な方法はないので、ゴシップはその状態に関係なく最終的に配信することができます。
2. ゴシップは後続のすべてのリーダにメッセージを配信するので、現在のリーダがフラッディングしても、次のリーダはすでにこれらの投票を受け取っており、エンコードすることができます。
3. "Gossip"は効率的なスパニングツリーを維持し、ブルームフィルターを使って状態を修復することで、ネットワークを介したリクエスト数を最小限に抑えます。そのため、再送のバックオフは必要なく、メッセージはバッチ処理されます。 そのため、再送のバックオフは必要なくメッセージはバッチ処理されます。
4. 投票のために"crds"テーブルを読むリーダは、テーブルに現れた新しい有効な投票をすべてエンコードします。 このリーダのブロックがアンロールされたとしても、次のリーダはバリデータによる追加作業なしに同じ票を追加しようとするでしょう。 このようにして、最終的な配送だけでなく、最終的な台帳へのエンコードも保証されるのです。

## パフォーマンス

1. 最悪の場合、次のリーダーまでの伝搬時間は"Log\(N\) hops"で、ベースはファンアウトに依存します。　 現在のデフォルトのファンアウトが"6"の場合、"20kノード"に対して約"6ホップ"となります。
2. リーダは、ゴシッププッシュによってMTUサイズのシュレッドに集約された20k個の検証票を受け取る必要があります。 これにより、20kネットワークのパケット数を80個のシュレッドに減らすことができます。
3. 各検証票はネットワーク全体に複製されます。 5つ前の投票のキューを維持するために、"Crdsテーブル"は25メガバイトになります。 `(20,000 ノード * 256 バイト * 5)`.

## 2つの実装のロールアウト

現在の"Vote"の実装では、最初は1票だけを送信し、ネットワークを通じて維持することで、ネットワークは確実に動作します。 小さなネットワークでは、ファンアウト"6"で十分です。 小規模なネットワークでは、メモリとプッシュのオーバーヘッドはわずかです。

### Sub 1k validator network

1. "Crds"はバリデータの最新の投票を維持するだけです。
2. 投票は台帳に表示されているかどうかに関わらずプッシュされ、再送信されます。
3. 6のファンアウト
4. 最悪の場合、ノードあたり256kbのメモリオーバーヘッドです。
5. 最悪の場合、すべてのノードに伝搬するのに4ホップかかります。
6. リーダはバリデータの全投票を4つのプッシュメッセージの断片で受け取ることになります。

### Sub 20k network

上記のすべてに加えて、以下のものがあります。

1. "CRDSテーブル"は最新のバリデータ5票のベクトルを保持しています。
2. 投票はウォールクロックをエンコードします。 "CrdsValue::Votes"は、すべてのゴシッププロトコルのトランザクションベクターに再帰するタイプです。
3. ファンアウトを"20"に増やしました。
4. 最悪の場合、ノードあたり25MBのメモリオーバーヘッドです。
5. 最悪の場合、ネットワーク全体に配信するためのホップ数は"4"以下になります。
6. すべてのバリデータメッセージに対してリーダーが受け取るシュレッド数は80です。
