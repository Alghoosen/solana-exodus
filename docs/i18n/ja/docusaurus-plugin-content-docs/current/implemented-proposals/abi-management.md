---
title: Solana ABI管理プロセス
---

本文書は、SolanaのABI管理プロセスを提案するものです。 ABI管理プロセスは、意図しない互換性のないABIの変更を導入しないためのエンジニアリング手法であり、それを支える技術的枠組みです。

# 問題

SolanaのABI(binary interface to the cluster) は、現在のところ実装によって暗黙的に定義されているだけであり、壊れるような変更に気づくには非常に慎重な目が必要です。 そのため、既存のクラスター上で、台帳を再起動せずにソフトウェアをアップグレードすることは極めて困難です。

# 要件と目的

- 意図しないABIの変更は、機械的にCIの失敗として検出できます。
- メインネットに移行する際には、新しい実装でも最古のデータ(genesis以降) を処理できなければなりません。
- この提案の目的は、非常に長い人間主導の監査プロセスではなく、機械的なプロセスを選択することで、ABIを保護しつつ、かなり早い開発を維持することです。
- いったん暗号で署名されたデータブロブは同一でなければならず、オンラインシステムのインバウンド、アウトバウンドにかかわらず、インプレースでのデータフォーマットの更新はできません。 また、私たちが扱うことを目指している膨大な量のトランザクションを考慮すると、過去にさかのぼってインプレースアップデートを行うことは望ましくありません。

# 解決法

定期的に失敗することを前提とした、人間の目による自然なデューディリジェンスの代わりに、ソースコードを変更する際にクラスタを壊さないことをシステム的に保証する必要があります。

そのために、ソースコード中のABI関連のもの(`構造体`sや`列挙型`s) に、新しい`#[frozen_abi]`属性を付ける仕組みを導入します。 この属性は、`ser::Serialize`を介して、そのフィールドの型から得られるハードコードされたダイジェスト値を取ります。 そして、この属性は自動的にユニットテストを生成し、マークされたABI関連のものに対する認可されていない変更を検出しようとします。

しかし、この検出は完全なものではありません。いくらソースコードを静的に分析しても、ABIを破ることは可能なのです。 例えば、`手書き`ではない`ser::Serialize`、基礎となるライブラリの実装の変更(例えば`bincode`)、CPUアーキテクチャの違いなどが挙げられます。 このような可能性のあるABI非互換性の検出は、このABI管理のスコープ外です。

# 定義

ABI項目/タイプ：シリアライズに使用される様々なタイプで、あらゆるシステムコンポーネントのABI全体をまとめて構成します。 例えば、これらのタイプ には、 `struct`s と `列挙`s が含まれます。

ABIアイテムダイジェスト：ABIアイテムのフィールドの型情報から得られる何らかの固定ハッシュ。

# 例

```patch
+#[frozen_abi(digest="eXSMM7b89VY72V...")]
 #[derive(Serialize, Default, Deserialize, Debug, PartialEq, Eq, Clone)]
 pub struct Vote {
     /// A stack of votes starting with the oldest vote
     pub slots: Vec<Slot>,
     /// signature of the bank's state at the last slot
     pub hash: Hash,
 }
```

# 開発者ワークフロー

新しいABIアイテムのダイジェストを知るために、開発者はランダムなダイジェスト値で`frozen_abi`を追加し、ユニットテストを実行して、アサーションテストのエラーメッセージから正しいダイジェストに置き換えることができます。

一般的には、`frozen_abi`を追加し、その変更が安定版リリースチャンネルで公開されたら、そのダイジェストは決して変更されないはずです。 もしそのような変更が必要な場合は、`FooV1`のような新しい`構造体`を定義することを選ぶべきです。 また、ハードフォークのような特殊なリリースフローにも対応しなければなりません。

# 実装上の注意

ユニットテストを自動生成したり、ABI項目からダイジェストを計算したりするために、ある程度のマクロ機構を使用しています。 これは、`serde::Serialize` (`[1]`)と`any::type_name` (`[2]`)を巧みに使用することで可能です。 同様の実装の前例としては、Parity Technologies` [3]`の`インク`が参考になるでしょう。

# 実装の詳細

この実装の目的は、意図しないABIの変更を可能な限り自動的に検出することです。 そのために、構造的なABI情報のダイジェストを、ベストエフォートの精度と安定性で計算しています。

ABIダイジェストチェックが実行されると、`セルド`の直列化機能、procマクロ、ジェネリック特殊化を再利用して、ABI項目のフィールドのABIを再帰的にダイジェストすることで、ABIダイジェストを動的に計算します。 そして、その最終的なダイジェスト値が`frozen_abi`属性で指定されたものと同一であることを`主張します`。

これを実現するために、この型の例のインスタンスを作成し、例を実際にシリアル化するかのように、`serde` がそのフィールドを再帰的にトラバースするためのカスタム `Serializer` インスタンスを作成します。 `派生`しない `Serialize` trait のカスタム実装を考慮しても、実際にどのような種類のデータが `serde` によってシリアル化されるかを真に捉えるためには、このトラバースは `serde` を介して行われなければなりません。

# ABI消化プロセス

この部分は少し複雑です。 相互に依存する3つの部分があります。`AbiExample`、`AbiDigester`、`AbiEnumVisitor`です。

まず、生成されたテストでは、`AbiExample`という trait を持つ消化された型のサンプルインスタンスが作成されます。この trait は、`Serialize` のようにすべての消化された型に対して実装され、`Default` trait のように `Self` を返すべきものです。 通常は、ほとんどの一般的な型に対して、ジェネリックな trait の特殊化によって提供されます。 また、`構造体`（struct）や`列挙型`（enum）に対しても`派生させること`が可能で、必要に応じて手動で記述することもできます。

カスタム`シリアライザー`は`AbiDigester`と呼ばれています。 そして、データをシリアル化するために`serde`から呼び出されると、ABI情報を可能な限り再帰的に収集します。 `ABIダイジェスト`のためのAbiDigesterの内部状態は、データの種類に応じて異なって更新されます。 このロジックは、各`enum`タイプ用の`AbiEnumVisitor`と呼ばれる形質を介して特別にリダイレクトされます。 名前が示すように、他の型のために`AbiEnumVisitor`を実装する必要はありません。

この相互作用を要約すると、`serde`は`AbiDigester`と連携して再帰的なシリアライゼーションの制御フローを処理します。 テストの初期エントリ・ポイントと子の`AbiDigester`は、`AbiExample`を再帰的に使用して、サンプルオブジェクトの階層グラフを作成します。 そして、`AbiDigester`は`AbiEnumVisitor`を使って、構築したサンプルを使って実際のABI情報を照会します。

`AbiExample`では、`デフォルト`だけでは不十分です。 様々なコレクションの`::default() `は空ですが、実際のアイテムで消化したいと考えています。 また、ABIの消化は、`AbiEnumVisitor`だけでは実現できません。 実際に`serde`でデータをトラバースするには、実際の型のインスタンスが必要なので、`AbiExample`が必要です。

一方で、ABI消化も`AbiExample`だけでは実現できません。 `AbiEnumVisitor`が必要なのは、ABIの例として、`enum`の単一のバリアントだけでは、enumのすべてのバリアントをトラバースできないからです。

情報の消化:

- rust's type name
- `serde`'s data type name
- all fields in `struct`
- all variants in `enum`
- `struct`: normal(`struct {...}`) and tuple-style (`struct(...)`)
- `enum`: normal variants and `struct`- and `tuple`- styles.
- attributes: `serde(serialize_with=...)` and `serde(skip)`

消化できない情報:

- `AbiExample`で提供されているサンプルでは触れられていない、任意のカスタムシリアライズコードパス。 (技術的に不可能)
- ジェネリック(具象型のエイリアスには`frozen_abi`を使用してください)。

# 参照

1. [(De)Serialization with type info · Issue #1095 · serde-rs/serde](https://github.com/serde-rs/serde/issues/1095#issuecomment-345483479)
2. [`std::any::type_name` - Rust](https://doc.rust-lang.org/std/any/fn.type_name.html)
3. [Parity's ink to write smart contracts](https://github.com/paritytech/ink)
