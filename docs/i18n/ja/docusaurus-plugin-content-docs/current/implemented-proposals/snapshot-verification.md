---
title: スナップショットの検証
---

## 問題

バリデータがスナップショットから起動する際には、アカウントセットがネットワークの他の部分の表示と一致しているかどうかをすぐに確認する方法が必要です。 潜在的な攻撃者は、バリデータに不正な状態を与え、本来なら拒否されるはずのトランザクションをバリデータに受け入れさせようとする可能性があります。

## 解決策

現在、バンクハッシュは、スロット内のアカウントのデルタ状態をハッシュ化し、それを前回のバンクハッシュ値と組み合わせて算出しています。 この方法の問題点は、ハッシュのリストがチェーンで処理されるスロットの数に比例して大きくなり、送信と検証の両方を成功させるのが大変になることです。

もう一つの素朴な方法は、アカウント状態のメルクルツリーを作成することです。 これには、アカウントが更新されるたびに、システム内のすべてのライブアカウントのアカウント状態全体から、メルクルツリーを再計算しなければならないという欠点があります。

スナップショットを検証するために、次のようにします。

0 ではないランポートアカウントのアカウントストアでは、以下のデータをハッシュ化します。

- アカウント所有者
- アカウントデータ
- アカウント公開キー
- アカウントランポート残高
- アカウントをフォークして保存

この結果のハッシュ値を、画像値に展開する展開関数の入力として使用します。 この関数は、"440 バイト"のデータブロックを作成します。最初の"32 バイト"がハッシュ値で、次の"440-32 バイト"は、ハッシュを種として"Chacha RNG"から生成されます。

その後、アカウント画像は"xor"で結合されます。 前のアカウントの値が状態に"xor"され、新しいアカウントの値も状態に"xor"されます。

"投票"と"sysvar"のハッシュ値は、結果として得られたフルイメージの値のハッシュで発生します。

バリデータの起動時、スナップショットからのロード時に、アカウントセットのハッシュ値を検証します。 次に"SPV"を使って、指定されたハッシュ値に投票したネットワークの割合を表示します。

結果として得られる値は、現在のアカウントの状態をすべてまとめて"xoring"したものであることをバリデータで検証することができます。

スナップショットでは、作成前と検証時にゼロのランポートアカウントを消去する必要があります。ゼロのランポートアカウントはハッシュ値に影響を与えませんが、バリデータである Bank が、実際には存在するはずのアカウントが存在しないと読み取ってしまう可能性があるからです。

"xor"の状態を攻撃することで、その値に影響を与えることができます。

"xor"の状態を攻撃することで、その値に影響を与えることができます。 440 バイトの画像サイズは、この[[https://link.springer.com/content/pdf/10.1007%2F3-540-45708-9_19.pdf\](https://link.springer.com/content/pdf/10.1007%2F3-540-45708-9_19.pdf)]論文から来ており、"0"との"xor collision"を回避しています(他のビットパターンも同様)。

この計算により、128 ビットのセキュリティを実現しています。

```text
O(k * 2^(n/(1+lg(k)))
k=2^40 accounts
n=440
2^(40) * 2^(448 * 8 / 41) ~= O(2^(128))
```
