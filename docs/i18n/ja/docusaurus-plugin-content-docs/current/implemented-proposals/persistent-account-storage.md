---
title: 永続的なアカウントストレージ
---

## 永続的なアカウントストレージ

アカウントのセットは、あるバリデータが処理したすべてのトランザクションの 現在の計算状態を表します。 各バリデータはこのセット全体を管理する必要があります。 ネットワークが提案する各ブロックはこのセットに対する変更を意味し、各ブロックはロールバックポイントとなる可能性があるため、変更は可逆的である必要があります。

"NVME"のようなパーシステントストレージは"DDR"に比べて、20〜40倍も安価です。 パーシステントストレージの問題点は、書き込みと読み出しのパフォーマンスが"DDR"よりもはるかに遅く、データの読み書きに注意を払わなければならないことです。 読み書きともに、複数のストレージドライブに分割して並行してアクセスすることができます。 この設計では、ストレージの同時読み取りと同時書き込みを可能にするデータ構造を提案しています。 書き込みは、AppendVecデータ構造を使用して最適化されています。このデータ構造では1人のライターが追加を行い、同時に多数のリーダがアクセスできるようになっています。 "accounts インデックス"はフォークごとにアカウントが追加された場所へのポインタを維持するため、状態の明示的なチェックポイントを必要としません。

## AppendVec

"AppendVec"は、1つのアペンドオンリーのライターと同時にランダムリードを可能にするデータ構造です。 "AppendVec"の容量を増やしたりサイズを変更したりするには、排他的なアクセスが必要です。 これは、アトミック`オフセット`で実装されており、追加が完了した時点で更新されます。

"AppendVec"の基盤となるメモリは、メモリマップドファイルです。 メモリマップドファイルは高速なランダムアクセスを可能にし、ページングはOSが行います。

## アカウントインデックス

アカウントインデックスは現在フォークされているすべての"アカウント"に対して、単一のインデックスをサポートするように設計されています。

```text
type AppendVecId = usize;

type Fork = u64;

struct AccountMap(Hashmap<Fork, (AppendVecId, u64)>);

type AccountIndex = HashMap<Pubkey, AccountMap>;
```

インデックスはアカウントの公開キーをフォークのマップにマッピングしたもので、"Accountデータ"の位置は"AppendVec"になっています。 特定の"Fork"に対する"Account"のバージョンを取得するには以下のようにしてください。

```text
/// Load the account for the pubkey.
/// This function will load the account from the specified fork, falling back to the fork's parents
/// * fork - a virtual Accounts instance, keyed by Fork.  Accounts keep track of their parents with Forks,
///       the persistent store
/// * pubkey - The Account's public key.
pub fn load_slow(&self, id: Fork, pubkey: &Pubkey) -> Option<&Account>
```

読み取りは、格納されたオフセットで`AppendVecId`のメモリマップされた場所を指すことで満たされます。 コピーがなくても参照を返すことができます。

### ルートフォーク

[タワーBFT](tower-bft.md)は最終的にフォークをルートフォークとして選択し、そのフォークはスカッシュされます。 "squashed/root fork"はロールバックできません。

フォークが潰されると、その親の中でフォークにまだ存在していないすべてのアカウントがインデックスを更新することで、フォークに引き上げられます。 潰されたフォークで残高がゼロになったアカウントは、インデックスの更新によってフォークから削除されます。

アカウントは、スカッシュによって到達できなくなったときに、_ ガベージコレクション_されることがあります。

3つの可能なオプションが存在します。

- ルートフォークの"HashSet"を維持します。 秒ごとに1つ作成される予定です。 ツリー全体は後でガベージコレクションされます。 あるいは、すべてのフォークがアカウントの参照カウントを保持していれば、インデックスの位置が更新されるたびにガベージコレクションを行うことができます。
- 剪定されたフォークをインデックスから削除します。 残っているフォークのうちルートよりも数が少ないものは、ルートとみなすことができます。
- インデックスをスキャンして、古いルートを新しいものに移行します。 新しいルートよりも下位のフォークが残っていれば、後で削除することができます。

## 追加のみの書き込み

アカウントの更新はすべて"Append-only"の更新として発生します。 アカウントの更新ごとに新しいバージョンが、"AppendVec"に格納されます。

既に保存されているアカウントのフォークに "mutable reference"を返すことで、単一のフォーク内での更新を最適化することが可能です。 Bankはすでにアカウントの同時アクセスを追跡しており、特定のアカウントのフォークへの書き込みがそのフォークのアカウントへの読み込みと同時に行われないことを保証しています。 この操作をサポートするために、"AppendVec"はこの関数を実装する必要があります。

```text
fn get_mut(&self, index: u64) -> &mut T;
```

このAPIでは、`インデックス`のメモリ領域への変異可能なアクセスを同時に行うことができます。 そのインデックスへの排他的アクセスを保証するために、"Bank"に依存しています。

## ガベージコレクション

アカウントが更新されると、"AppendVec"の最後に移動します。 容量がなくなると新しい"AppendVec"が作成され、アップデートはそこに保存されます。 最終的にはすべてのアカウントが更新されたので、古い"AppendVec"への参照はなくなり、古い"AppendVec"は削除できます。

このプロセスを早めるために、最近更新されていないアカウントを新しい"AppendVec"の前に移動させることができます。 この形式のガベージコレクションは、インデックスの更新以外のデータ構造に排他的ロックを必要とせずに行うことができます。

ガベージコレクションの初期の実装では、"AppendVec"内のすべてのアカウントが古いバージョンになったら、それを再利用します。 アペンドされたアカウントは更新されず、移動もしません。

## インデックスのリカバリ

各Bankのスレッドはデータがコミットされるまでアカウントのロックを解除できないため、アペンド中はアカウントに排他的にアクセスできます。 しかし、別々のAppendVecファイルの間には書き込みの明示的な順序はありません。 順番を作るためにインデックスは、アトミックな書き込みバージョンカウンタを維持します。 "AppendVec"に追加するたびに、"AppendVec"のアカウントのエントリに、その追加分のインデックスの書き込みバージョン番号が記録されます。

インデックスを回復するには、すべての"AppendVec"ファイルをどのような順番でも読み取ることができ、すべてのフォークの最新の書き込みバージョンをインデックスに保存する必要があります。

## スナップショット

スナップショットを行うためには、"AppendVec"内の基礎となるメモリマップドファイルをディスクにフラッシュする必要があります。 インデックスも同様にディスクに書き出すことができます。

## パフォーマンス

- アペンドのみの書き込みも高速です。 SSDやNVME、そしてOSレベルのカーネルデータ構造のおかげで、PCIやNVMeの帯域幅が許す限り、アペンドを高速に実行することができます \(2,700 MB/s\)。
- "リプレイ"と"バンキング"の各スレッドは、それぞれの"AppendVec"に同時に書き込みを行います。
- 各"AppendVec"は、別の"NVMe"上でホストされる可能性があります。
- 各"リプレイ"と"バンキングのスレッド"は、書き込みをブロックすることなく、すべての"AppendVec"への同時読み取りアクセスが可能です。
- インデックスの書き込みには排他的な書き込みロックが必要です。 "HashMap"の更新におけるシングルスレッドのパフォーマンスは、1秒あたり10m程度です。
- "バンキング"および"リプレイステージ"では、"NVMe"あたり32スレッドを使用する必要があります。 "NVMes"は32人の同時リーダまたはライタで最適な性能を発揮します。
