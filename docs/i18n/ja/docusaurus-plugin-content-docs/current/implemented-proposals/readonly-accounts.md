---
title: 読み取り専用アカウント
---

この設計では、[ランタイム](../validator/runtime.md)における読み取り可能なアカウントと書き込み可能なアカウントの処理について説明します。 同じアカウントを変更する複数のトランザクションは、常に同じ順序で再生されるように連続的に処理されなければなりません。 そうしないと、台帳に非決定性が生じる可能性があるからです。 しかし、トランザクションの中には特定の勘定科目のデータを読み取るだけで変更しないものもあります。 同じアカウントを読むだけの複数のトランザクションは、再生順序が問題にならないため並行して処理することができ、パフォーマンス上のメリットが得られます。

読み取り専用のアカウントを識別するために、トランザクションの MessageHeader 構造体には `num_readonly_signed_accounts` と `num_readonly_unsigned_accounts` が含まれています。 実行可能なアカウントも同様に、命令処理中に変更することができないため、`命令のプログラムID`は、"readonly_unsigned_accounts"としてアカウントベクトルに含まれます。

## ランタイム処理

ランタイムのトランザクション処理ルールを若干更新する必要があります。 プログラムは、自分が所有していないアカウントを書き込んだり使ったりすることはできません。 しかし、新しいランタイムルールで読み取り専用アカウントは、それを所有するプログラムであっても変更できないようになっています。

読み取り専用アカウントには次のような特性があります。

- ランポート(入金・引き落とし不可) を含むすべてのアカウントフィールド、およびアカウントデータへの読み取り専用アクセス

読み取り専用のアカウントをクレジット、デビット、または修正する指示は失敗します。

## アカウントロックの最適化

アカウントモジュールはランタイムで現在ロックされているアカウントを追跡し、読み取り可能なアカウントと書き込み可能なアカウントを分けています。 デフォルトのアカウントロックでは、アカウントに"書き込み可能"という指定がされており、一度に 1 つの処理スレッドからしかアクセスできません。 読み取り専用のアカウントは別のメカニズムでロックされ、並行して読み取ることができます。

まだ実装されていませんが、読み取り専用アカウントをメモリにキャッシュし、トランザクションを実行するすべてのスレッドで共有することができます。 理想的な設計では、読み取り専用アカウントがランタイム内の任意のトランザクションによって参照されている間、このキャッシュを保持し、最後のトランザクションがランタイムを終了したときにキャッシュを解放します。

読み取り専用アカウントは参照としてプロセッサに渡すこともでき、余分なコピーを省くことができます。
