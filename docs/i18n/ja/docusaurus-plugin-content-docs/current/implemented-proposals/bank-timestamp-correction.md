---
title: バンクタイムスタンプ補正
---

各バンクにはタイムスタンプがあり、これはClock sysvarに格納され、時間ベースのステークスアカウントロックアップを評価するために使用されます。 しかし、創世記からこの値は現実ではなく理論的なslots-per-secondに基づいていたため、かなり不正確です。 これはロックアップにとって問題となります。ロックアップの期限が切れる日には、アカウントはロックアップフリーとして登録されないからです (or anytime near) 。

ブロックタイムはすでにBlockstoreや長期ストレージの [validator timestamp oracle](validator-timestamp-oracle.md)を使って推定されています。このデータは、銀行のタイムスタンプをより現実の時間に近づける機会を提供してくれます。

提案の概要は以下の通りです。

- バリデータが提供したタイムスタンプを使って、各バンクのタイムスタンプを修正します。
- バリデータが提供したタイムスタンプの計算を、ステークスウェイト平均ではなく、ステーキング荷重中央値を使用するように更新します。
- タイムスタンプの修正が予想される理論上の推定値から大きく逸脱しないように調整します。

## タイムスタンプ補正

新しいBank毎に、ランタイムはvalidatorのtimestamp-oracleデータを使って現実的なタイムスタンプ推定値を計算します。 Bankのタイムスタンプが前のBankのタイムスタンプ以上であれば、この値に修正されます。 つまり、時間は絶対に逆戻りしてはならないということです。ロックされたアカウントは修正によって解除されるかもしれませんが、一度解除されたアカウントは時間修正によって再びロックされることはありません。

### ステーキング荷重タイムスタンプ中央値の計算

特定のBankの推定タイムスタンプを計算するために、ランタイムはまずアクティブなバリデータセットから最新の投票タイムスタンプを取得する必要があります。 `Bank::vote_accounts()`メソッドは投票アカウントの状態を提供しており、最新のタイムスタンプが直近のエポック内で提供されたすべてのアカウントにフィルタリングすることができます。

各投票タイムスタンプから、エポックのターゲット"ns_per_slot"を使用して、現在のBankの推定値が、Bankスロットとタイムスタンプスロットの間のあらゆるデルタに対して計算されます。 各タイムスタンプの推定値は、その投票アカウントに委任されたステーキングに関連付けられ、すべてのタイムスタンプが集められて、ステークで重み付けされたタイムスタンプ分布が作成されます。

このセットから、ステーキング加重中央値タイムスタンプ（すなわち、ステーキングの50%以上のタイムスタンプを推定し、ステークの50%以下のタイムスタンプを推定するタイムスタンプ）が、潜在的な修正タイムスタンプとして選択されます。

このステーキング加重タイムスタンプ中央値は、ステーキング加重平均値よりも好ましいものです。なぜなら、平均値の計算では、提案されたタイムスタンプにステークを乗算するため、非常に小さなステーキングを持つノードが、非常に大きいまたは非常に小さいタイムスタンプを提案することで、結果のタイムスタンプに大きな影響を与えることができるからです。 例えば、以前の`calculate_stake_weighted_timestamp()`メソッドを使用した場合、0.00003%のstakeを持つノードが`i64::MAX`のタイムスタンプを提案すると、タイムスタンプを97k年前にシフトすることができます!

### バウンディングタイムスタンプ

時間が逆行するのを防ぐだけでなく、修正されたタイムスタンプが理論上の期待される時間から許容できるレベルで逸脱するのを制限することで、悪意のある行為を防ぐことができます。

本提案では、各タイムスタンプがエポック開始時から予想される時間から25％までの乖離を許容することを提案します。

タイムスタンプの偏差を計算するために、各銀行は"Clock sysvar"に`epoch_start_timestamp`を記録する必要がある。 この値は、各エポックの最初のスロットの`Clock::unix_timestamp`に設定されます。

その後、ランタイムはエポック開始からの予想経過時間と、修正されたタイムスタンプに基づく提案経過時間を比較します。 補正された経過時間が期待値の±25%以内であれば、補正されたタイムスタンプが受け入れられます。 そうでない場合は、許容できる偏差値に制限されます。
