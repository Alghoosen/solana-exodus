---
title: ゴシップサービス
---

ゴシップサービスは、コントロールプレーンのノードへのゲートウェイとして機能します。 バリデータは、このサービスを利用して、クラスタ内の他のすべてのノードが情報を利用できるようにします。 このサービスは、ゴシッププロトコルを使用して情報をブロードキャストします。

## ゴシップサービス

ノードは、クラスタを管理するために、自分たちの間で署名されたデータオブジェクトを継続的に共有します。 例えば、連絡先、台帳の高さ、投票などを共有します。

各ノードは、10 分の 1 秒ごとに、"プッシュ"メッセージおよび／または"プル"メッセージを送信します。 プッシュ・メッセージやプル・メッセージは応答を引き出すことができ、プッシュ・メッセージはクラスター内の他のノードに転送されることもあります。

ゴシップは、よく知られた UDP/IP ポートまたはよく知られた範囲のポートで実行されます。 クラスタが起動すると、ノードはゴシップのエンドポイント\(ソケットアドレス)\がどこにあるかをお互いに通知します。

## ゴシップレコード

ゴシップで共有されるレコードは任意ですが、受信するノードにとって意味があるように、必要に応じて署名とバージョン管理が行われます\(with a timestamp\) 。 ノードが同じソースから 2 つのレコードを受信した場合、ノードは自分のコピーを最新のタイムスタンプを持つレコードで更新します。

## ゴシップサービスインターフェース

### プッシュメッセージ

ノードはプッシュメッセージを送信して、共有する情報があることをクラスターに伝えます。 ノードは`PUSH_FANOUT`プッシュピアにプッシュメッセージを送信します。

ノードは、プッシュメッセージを受信すると、そのメッセージを検証します。

1. 重複：メッセージが以前に見られたことがある場合、ノードはそのメッセージを削除し、低いステーキングホルダーのノードから転送された場合は`PushMessagePrune`で応答することがあります。
2. 新しいデータ：メッセージがそのノードにとって新しいものである場合

   - 新しい情報を更新されたバージョンでそのクラスタ情報に格納し

     以前の古い値はすべて消去されます。

   - `push_once `″にメッセージを格納\(重複の検出に使用。

     `PUSH_MSG_TIMEOUT * 5 `ms\後にパージされます。)

   - 自身のプッシュ・ピアにメッセージを再送信します。

3. Expiration: ノードは` PUSH_MSG_TIMEOUT` よりも古いプッシュメッセージを削除します。

### Push Peers, Prune Message

ノードは、アクティブな既知のピアのセットからランダムに自分のプッシュ・ピアを選択します。 ノードは、この選択を比較的長い時間保持します。 "prune"メッセージを受信すると、ノードは prune を送信したプッシュピアをドロップします。 "prune"は、そのノードへのダイレクトプッシュ以外の、より高いステーキング荷重のパスがあることを示しています。

`PUSH_MSG_TIMEOUT/2`ミリ秒ごとに新しいノードを回転させることで、プッシュ・ピアのセットは常に新鮮に保たれます。

### Pull Message

ノードは、新しい情報があるかどうかをクラスターに問い合わせるために、プルメッセージを送信します。 プルメッセージはランダムに 1 つのピアに送信され、すでに持っているものを表すブルームフィルタで構成されます。 プルメッセージを受信したノードは、その値を反復処理して、フィルターを外れてメッセージに収まるものをプルレスポンスとして作成します。

ノードは、現在の値と最近パージされた値を反復して、プルブルームフィルタを構築します。

ノードは、プッシュメッセージで新しいデータを処理するのと同じように、プルレスポンスでアイテムを処理します。

## パージ

ノードは、以前のバージョンの値\(pull や push によって更新されたもの\) や、期限切れの値\(`GOSSIP_PULL_CRDS_TIMEOUT_MS`より古いもの) を`purged_values`\(最近所持していたもの\) に保持しています。 ノードは、`5 * GOSSIP_PULL_CRDS_TIMEOUT_MS`よりも古い`purged_values`をパージします。

## エクリプスアタック

エクリプス攻撃とは、敵対的なエンドポイントを持つノード接続のセットを乗っ取ろうとするものです。

これは次のような点で我々の実装に関連しています。

- プルメッセージは、ネットワークからランダムなノードを選択します。 *プル*に対するエクリプス攻撃では、敵対的なノードのみがプルに選択されるように、攻撃者がランダムな選択に影響を与える必要があります。
- プッシュメッセージは、ノードのアクティブセットを維持し、プッシュメッセージごとにランダムなファンアウトを選択します。 *プッシュ*に対するエクリプス攻撃は、アクティブセットの選択やランダムなファンアウトの選択に影響を与えます。

### 時間とステーキングベースのウエイト

ウェイトは、`最後にピックしてからの時間`と、`ステーキングウェイト`の`自然対数`に基づいて計算されます。

ステーキングウェイトの`ln`を取ることで、すべてのノードが合理的な時間内にネットワークをカバーする機会をより公平に与えることができます。 これにより、ノード間の大きな`ステーキング荷重`の差を正規化することができます。 これにより、`ステーキング荷重`が小さいノードは、`ステーキング荷重`が大きいノードと比較して、ピックされるまでに ln\(`ステーキング`\) の数倍の秒数しか待つ必要がありません。

敵対者がこれらのパラメータに影響を与える方法はありません。

### Pull Message

上述のウェイトに基づいて、プルターゲットとしてのノードが選択されます。

### Push Message

"prune"メッセージは、潜在的な接続から敵対者を取り除くことしかできません。

*pull メッセージ*と同様に、ノードは重みに基づいてアクティブセットに選択されます。

## PlumTree との顕著な違い

ここで説明するアクティブなプッシュプロトコルは [Plum Tree](https://haslab.uminho.pt/sites/default/files/jop/files/lpr07a.pdf) に基づいています。 主な違いは次のとおりです。

- プッシュメッセージには、発信者が署名したウォールクロックが設定されています ウォールクロックが切れると、メッセージは削除されます。 ホップ数の制限は、敵対的な環境では実装が困難です。
- "Lazy Push"が実装されていないのは、敵対者がメッセージのフィンガープリントを偽造するのを防ぐ方法が明らかでないからです。 素朴なアプローチでは、敵対者が入力に基づいてプルの優先順位を決めることができます。
