---
title: ランタイム
---

## ランタイム

ランタイムはトランザクションプロセッサを同時に実行します。 トランザクションは、前面および動的メモリ割り当てが明示的であるデータの依存関係を指定します。 動作する状態からプログラムコードを分離することによって、ランタイムは同時アクセスを振り付けることができます。 読み取り専用アカウントにアクセスするトランザクションは並列に実行され、書き込み可能なアカウントにアクセスするトランザクションはシリアライズされます。 ランタイムは、明確に定義されたインターフェイスを持つエントリポイントを介してプログラムと相互作用します。 アカウントに保存されているデータは、不透明な型、バイトの配列です。 プログラムはその内容を完全に制御しています。

トランザクション構造は、それらのキーに対する公開キーと署名のリストと、アカウントキーに関連付けられた状態で動作する順番のリストを指定します。 トランザクション全体がコミットに失敗した場合, トランザクションがコミットされるには、すべての命令が正常に実行されなければなりません。

#### アカウントの構成

アカウントは、ランポートのバランスとプログラム固有のメモリを維持します。

## トランザクションエンジン

エンジンは公開キーをアカウントにマップし、プログラムのエントリポイントにそれらをルーティングします。

### 実行

トランザクションはバッチ処理され、パイプラインで処理されます。 "TPU"と"TVU"は少し異なる道をたどっています。 TPUのランタイムでは、メモリがコミットされる前にPoHの記録が行われます。

TVUランタイムは、ランタイムがトランザクションを処理する前にPoHの検証を確実に行います。

![Runtime pipeline](/img/runtime.svg)

_実行段階_では、ロードされたアカウントにはデータの依存関係がないため、すべてのプログラムを並行して実行することができます。

ランタイムは次のルールを強制します。

1. _オーナー_プログラムのみが、アカウントの内容を変更することができます。 つまり、割り当てられたデータベクトルはゼロであることが保証されています。
2. すべてのアカウントの合計残高は、トランザクションの実行前と実行後で等しくなります。
3. トランザクションの実行後、読み取り専用のアカウントの残高は、トランザクション実行前の残高と等しくなければなりません。
4. トランザクション内のすべての命令はアトミックに実行されます。 1つでも失敗すると、すべてのアカウントの変更が破棄されます。

プログラムの実行には、プログラムの公開キーを、トランザクションへのポインタと、ロードされたアカウントの配列を取るエントリポイントにマッピングする必要があります。

### SystemProgram Interface

このインターフェースは、ユーザーがエンコードする`Instruction::data`によって最もよく説明されます。

- `CreateAccount` - これにより、ユーザーは割り当てられたデータ配列を持つアカウントを作成し、それをプログラムに割り当てることができます。
- `CreateAccountWithSeed` - `CreateAccount`と同じですが、新しいアカウントのアドレスは以下の通りです。
  - 資金源となるアカウントの公開キー
  - ニーモニック文字列(シード)、および
  - プログラムの公開キー
- `Assign` - 既存のアカウントをプログラムに割り当てることができます。
- `Transfer` - アカウント間でランポートを転送します。

### プログラムの状態セキュリティ

ブロックチェーンが正しく機能するためには、プログラムコードがユーザーの入力に対して弾力的でなければなりません。 このデザインでは、プログラム固有のコードが、割り当てられたアカウントのデータバイト配列の状態を変更できる唯一のコードとなっているのはそのためです。 `Assign `や `CreateAccount `がデータをゼロにしなければならないのも、このためです。 そうしないと、最近割り当てられたアカウントデータとネイティブに生成された状態遷移とをプログラムが区別する方法がありません。ランタイムから、このメモリがネイティブに生成されたものではなく割り当てられたものであることを示すメタデータが追加されなければならないのです。

プログラム間でメッセージをやり取りするためには、受信側のプログラムがメッセージを受け取り、状態をコピーする必要があります。 しかし、実際にはコピーは必要ありませんし、望ましくありません。 受信側のプログラムは、他のアカウントに属する状態をコピーせずに読むことができ、その際、送信側のプログラムの状態を保証することができます。

### ノート

- 動的なメモリの割り当てはありません。 クライアントは`CreateAccount`命令を使用して、他のプログラムに渡す前にメモリを作成する必要があります。 この命令は、プログラム自体への呼び出しで1つのトランザクションに構成することができます。
- `CreateAccount`と`Assign`は、Accountがプログラムに割り当てられたときに、Accountのデータがゼロ初期化されることを保証します。
- ただし、`CreateAccountWithSeedに`よってアカウントが作成された場合は、アカウントのアドレス/パブキーに対応するプライベートキーが存在しません。
- 一度プログラムに割り当てられた Account は再割り当てできません。
- Runtimeは、プログラムのコードが、Accountが割り当てられているAccountデータを変更できる唯一のコードであることを保証します。
- ランタイムは、プログラムが自分に割り当てられたアカウントにあるランポートのみを使用できることを保証します。
- ランタイムは、アカウントに属する残高が、トランザクションの前後でバランスが取れていることを保証します。
- ランタイムは、トランザクションがコミットされたときに命令がすべて正常に実行されることを保証します。

## 今後の仕事

- [Continuations and Signals for long running Transactions](https://github.com/solana-labs/solana/issues/1485)
