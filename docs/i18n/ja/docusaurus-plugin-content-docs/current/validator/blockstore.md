---
title: Blockstore
---

ブロックが最終的に完成すると、そのブロックからジェネシスブロックまでのすべてのブロックが直線的なチェーンを形成し、ブロックチェーンという名称で親しまれています。 しかし、それまでの間、検証者は_フォーク_と呼ばれる潜在的に有効なチェーンをすべて維持しなければなりません。 リーダのローテーションによってフォークが自然に形成されるプロセスについては、[フォーク生成](../cluster/fork-generation.md)で説明します。 ここで説明する_ブロックストア_のデータ構造は、 ブロックが確定するまでの間にバリデータがフォークに対処する方法です。

ブロックストアを使用することで、バリデータはネットワーク上で観測された全てのシュレッドを任意の順番で記録することができます。

シュレッドは、`leader slot`＋`shred index`のタプルがフォーク可能なキースペースに移動されます\(スロット内で) これにより、Solanaプロトコルのスキップリスト構造が完全に格納されることができます。 どのフォークをフォローするかを選択する"a-priori"なしで、どのエントリが持続するか、またはいつ持続するかを選択します。

最近のシュレッダーに対する修復リクエストは、Blockstoreのバックにあるストアが実装しているように、最近のファイルはRAMから、最近ではないシュレッダーはより深いストレージから処理されます。

## Blockstoreの機能

1. 永続性：ブロックストアはノード検証パイプラインの先頭に位置し、

   ネットワーク受信と署名検証のすぐ後ろにあります。 受信したシュレッドがリーダーのスケジュールと一致していれば

   \(つまり、指定されたスロットに対してリーダーが署名していれば

   指定されたスロットのリーダー\) はすぐに保存されます。

2. 修復：修復は、上記のウィンドウ修復と同じですが、

   受信したあらゆるシュレッドを処理することができます。 ブロックストアでは、署名付きのシュレッドを保存することで、

   発行元のチェーンを維持することができます。

3. Forks: ブロックストアはシュレッドのランダムアクセスをサポートしているので、

   バリデータがバリデータのバンクチェックポイントからのロールバックやリプレイをサポートすることができます。

4. 再起動：適切な刈り込み/カリングを行うと共に、スロット0からのエントリーを順番に列挙することで、

   ブロックストアを再生することができます。 ブロックストアの最新のエントリーに対しては、

   再生ステージの論理\(つまり、フォークスターを扱う\)

   を使用する必要があります。

## ブロックストアデザイン

1. ブロックストアのエントリーは、キーとバリューのペアで保存されます。キーは、エントリーのスロットインデックスとシュレッドインデックスを連結したもので、バリューはエントリーのデータです。 シュレッドインデックスは、各スロットごとにゼロベースであることに注意してください\(つまり、それらはスロットに関連するもの)す\）。
2. ブロックストアは、各スロットのメタデータ`をSlotMeta`構造体に保持しています。

   - `slot_index` - このスロットのインデックス
   - `num_blocks` - スロット内のブロック数 \(前のスロットにチェーンするために使用されます\)
   - `consumed` - The highest shred index `n`, such that for all `m < n`, there exists a shred in this slot with shred index equal to `n` \(i.e. the highest consecutive shred index\).
   - `received `- そのスロットで受信した最も高い細断処理インデックス
   - `next_slots` - このスロットが連鎖する可能性のある未来のスロットのリストです。 台帳を再構築する際に、

     可能なフォークポイントを見つけるために使用されます。

   - `last_index` - このスロットの最後のシュレッドとしてフラグが立てられている、シュレッドのインデックスです。 "shred"のこのフラグは、スロットのリーダーがスロットの最後のシュレッドを送信するときに設定されます。
   - `is_rooted` - 0のすべてのブロックが、穴のない完全なシーケンスを形成していれば真。 各スロットの"is_rooted"は、以下のルールで導き出すことができます。 "Slot\(n\)"をインデックス`n`のスロットとし、"slot\(n\).is_full\(\)"は、インデックス`n`のスロットに期待される全ての目盛りがある場合に真となります。 "is_rooted\(n\)"を"slot\(n\).is_rooted is true"とします。 すると

     is_rooted\(0\) is_rooted\(n+1\) iff \(is_rooted\(n\)and slot\(n\).is_full\(\)

3. Chaining - 新しいスロット`x`のシュレッドが届くと、その新しいスロットのブロック数をチェックします\(`num_blocks`\)\(this information is encoded in the shred\). そして、この新しいスロットが"スロット`x - num_blocks"`にチェーンしていることがわかります。
4. サブスクリプション - ブロックストアは、"サブスクリプション"されたスロットのセットを記録します。 つまり、これらのスロットにチェーンしているエントリーは、"ReplayStage"が消費するためにBlockstoreチャンネルに送信されます。 詳細は `Blockstore API` を参照してください。
5. Update notifications - "slot\(n\).is_rooted"が任意の`n`に対してfalseからtrueに反転した場合、ブロックストアはリスナーに通知します。

## Blockstore API

BlockstoreはサブスクリプションベースのAPIを提供しており、ReplayStageはそれを使って興味のあるエントリーを要求します。 エントリは、Blockstoreが公開しているチャネルで送信されます。 これらのサブスクリプションAPIは以下の通りです。 `fn get_slots_since(slot_indexes: &[u64]) -> Vec<SlotMeta>`:リスト `slot_indexes` の任意の要素に接続する新しいスロットを返します。

1. `fn get_slot_entries(slot_index: u64, entry_start_index: usize, max_entries: Option<u64>) -> Vec<Entry>`: `entry_start_index`で始まるスロットのエントリーベクターを返します。`max_entries == Some(max)`の場合は`max`で結果の上限を決めますが、そうでない場合は戻りベクターの長さに上限はありません。

注：これを総合すると、再生ステージはスロットが終了したことを知り、次のエントリを得るために興味のある次のスロットをサブスクライブしなければならないことになります。 これまでは、スロットを連鎖させる負担はブロックストアにかかっていました。

## Bankとのインターフェース

Bankはリプレイステージに公開します。

1. `prev_hash`: 最後に処理されたエントリのハッシュで示される、

   作業中のPoHチェーン。

2. `tick_height`: この銀行が現在検証している PoH チェーンの目盛り

   。

3. `votes`: レコードのスタックで、以下: 1の内容を含みます。 `prev_hash`: この投票の後にPoH 2で連鎖する必要があるもの `tick_height`: この投票が行われた目盛りの高さ 3 `lockout period`: この投票の下に連鎖できるようにするには、

   台帳で連鎖が観察される期間

リプレイ段階では、ブロックストアのAPIを使用して、前回の投票から掛けられる最長のエントリチェーンを探します。 その連鎖が最新の投票に掛からない場合、リプレイステージはその投票までBankをロールバックし、そこから連鎖を再生します。

## 剪定ブロックストア

ブロックストアのエントリが十分に古くなると、すべての可能なフォークを表現することはあまり役に立たなくなり、おそらく再起動時の再生にも問題が生じるでしょう。 ただし、バリデータの投票が最大ロックアウトに達したら、 その投票のためにPoHチェーンにないBlockstoreのコンテンツは、削除、除去することができます。
