---
title: "トランザクション"
---

プログラムの実行は、クラスターに[トランザクション](terminology.md#transaction)が送信されることから始まります。 Solana ランタイムは、トランザクションに含まれる各[命令](terminology.md#instruction)を処理するプログラムを、順番に、かつアトミックに実行します。

## トランザクションの解剖学

このセクションでは、トランザクションのバイナリフォーマットについて説明します。

### トランザクションフォーマット

トランザクションには、署名の[コンパクトな配列](#compact-array-format)と、それに続く[メッセージ](#message-format)が含まれます。 署名配列の各項目は、指定されたメッセージの[デジタル署名](#signature-format)です。 Solana ランタイムはメッセージヘッダー [の最初の](#message-header-format) 8 ビットの数と一致する署名の数を確認します。 また、各署名が、メッセージのアカウント・アドレス配列の同じインデックスにある公開キーに対応するプライベートキーによって署名されていることを検証します。

#### 署名フォーマット

各デジタル署名は ed25519 バイナリ形式であり、64 バイトを消費します。

### メッセージフォーマット

メッセージには、[ヘッダ](#message-header-format)、コンパクトな[アカウントアドレス](#account-addresses-format)の配列、最近の[ブロックハッシュ](#blockhash-format)、コンパクトな[命令](#instruction-format)の配列が含まれています。

#### メッセージヘッダフォーマット

メッセージヘッダは 3 つの符号なし 8 ビットの値を含みます。 最初の値は、含まれるトランザクションに必要な署名の数です。 2 つ目の値は、対応するアカウントアドレスのうち、読み取り専用のものの数です。 メッセージヘッダの 3 番目の値は、署名を必要としない読み取り専用のアカウントアドレスの数です。

#### アカウントアドレスフォーマット

署名を必要とするアドレスは、アカウントアドレス配列の先頭に表示され、書き込みアクセスを要求するアドレスが最初に表示され、その次に読み取り専用のアカウントが表示されます。 署名を必要としないアドレスは、署名を必要とするアドレスの後に続き、やはり読み書き可能なアカウントが先で、読み書き専用のアカウントが後になります。

#### Blockhash Format

ブロックハッシュは、32 バイトの SHA-256 ハッシュを含みます。 これは、クライアントが最後に台帳を確認した日時を示すために使用されます。 バリデータは、ブロックハッシュが古すぎると取引を拒否します。

### 命令フォーマット

1 つの命令には、プログラム ID インデックス、アカウントアドレスインデックスのコンパクトアレイ、不透明な 8 ビットデータのコンパクトアレイが含まれます。 プログラム ID インデックスは、不透明なデータを解釈できるオンチェーンプログラムを特定するために使用されます。 プログラム ID インデックスは、メッセージのアカウント・アドレスの配列にあるアカウント・アドレスへの符号なし 8 ビットのインデックスです。 アカウントアドレスインデックスは、それぞれ同じ配列に対する符号なし 8 ビットのインデックスです。

### コンパクト配列フォーマット

コンパクト配列は、配列長の後に各配列項目が続く形でシリアライズされます。 配列の長さは、compact-u16 と呼ばれる特殊なマルチバイトエンコーディングです。

#### コンパクト配列フォーマット

"compact-u16"は、16 ビットのマルチバイトエンコーディングです。 第 1 バイトは、値の下位 7 ビットをその下位 7 ビットに入れます。 値が 0x7f 以上の場合は、ハイビットがセットされ、値の次の 7 ビットが第 2 バイトの下位 7 ビットに入ります。 値が 0x3fff 以上の場合は、High ビットがセットされ、値の残りの 2 ビットが第 3 バイトの下位 2 ビットに配置されます。

### アカウントアドレスフォーマット

アカウントアドレスは、32 バイトの任意のデータです。 アドレスが デジタル署名を必要とする場合、ランタイムはそれを ed25519 キーペアの公開鍵として解釈します。

## 命令

各[命令は](terminology.md#instruction)、1 つのプログラム、プログラムに渡されるべきトランザクションのアカウントのサブセット、およびプログラムに渡されるデータバイト配列を指定します。 プログラムはデータ配列を解釈し、命令で指定された勘定科目を操作します。 プログラムは正常に返すこともできるし、エラーコードで返すこともできます。 エラーで返された場合は、トランザクション全体が直ちに失敗となります。

プログラムは通常、サポートする命令を構築するためのヘルパー関数を提供します。 例えば、システムプログラムは、 [`SystemInstruction::CreateAccount`](https://github.com/solana-labs/solana/blob/6606590b8132e56dab9e60b3f7d20ba7412a736c/sdk/program/src/system_instruction.rs#L63) 命令を構築するために、以下の Rust ヘルパーを提供します。

```rust
pub fn create_account(
    from_pubkey: &Pubkey,
    to_pubkey: &Pubkey,
    lamports: u64,
    space: u64,
    owner: &Pubkey,
) -> Instruction {
    let account_metas = vec![
        AccountMeta::new(*from_pubkey, true),
        AccountMeta::new(*to_pubkey, true),
    ];
    Instruction::new(
        system_program::id(),
        &SystemInstruction::CreateAccount {
            lamports,
            space,
            owner: *owner,
        },
        account_metas,
    )
}
```

ここで見つけることができます。

https://github.com/solana-labs/solana/blob/6606590b8132e56dab9e60b3f7d20ba7412a736c/sdk/program/src/system_instruction.rs#L220

### Program Id

命令の[プログラム ID](terminology.md#program-id)は、どのプログラムがこの命令を処理するかを指定します。 プログラムのアカウントのオーナーは、プログラムのロードと実行にどのローダーを使用すべきかを指定し、データはランタイムがどのようにプログラムを実行すべきかに関する情報を含んでいます。

[デプロイされた BPF プログラム](developing/deployed-programs/overview.md)の場合、オーナーは BPF ローダーであり、アカウントデータは BPF バイトコードを保持しています。 プログラムアカウントは、デプロイが成功すると、ローダーによって実行可能であると永久にマークされます。 ランタイムは、実行可能でないプログラムを指定するトランザクションを拒否します。

デプロイされたプログラムとは異なり、 [builtins](developing/builtins/programs.md) は、 Solana ランタイムに直接組み込まれているという点で異なる処理を行います。

### アカウント

命令で参照されるアカウントは、オンチェーンの状態を表し、プログラムのインプットとアウトプットの両方の役割を果たします。 口座の詳細については、 [アカウント](accounts.md) セクションをご覧ください。

### 命令データ

各命令には汎用のバイト配列が含まれており、アカウントと一緒にプログラムに渡されます 命令データの内容はプログラム固有のもので、通常、プログラムが実行すべき操作と、その操作に必要なアカウント以上の追加情報を伝えるために使用されます。

プログラムは、命令データのバイト配列にどのように情報をエンコードするかを自由に指定できます。 データをどのようにエンコードするかは、デコードのオーバーヘッドを考慮して決める必要があります。 いくつかの一般的なエンコーディング(Rust の bincode など) は非常に効率が悪いことがわかっています。

[Solana Program Library の Token プログラム](https://github.com/solana-labs/solana-program-library/tree/master/token)は、命令データを効率的にエンコードする方法の一例を示していますが、この方法は固定サイズの型しかサポートしていないことに注意してください。 トークンは、 [Pack](https://github.com/solana-labs/solana/blob/master/sdk/program/src/program_pack.rs) トレイトを使用して、命令データをトークン命令と トークンアカウントの状態の両方にエンコード/デコードします。

## 署名

各トランザクションには、そのトランザクションの指示によって参照されるすべてのアカウント公開鍵が明示的に記載されています。 これらの公開キーのサブセットには、それぞれトランザクション署名が付いています。 これらの署名は、アカウント保持者がトランザクションを承認したことをチェーン上のプログラムに通知します。 一般的に、プログラムはこの認証を利用して、アカウントの引き落としやデータの変更を許可します。 認証がプログラムにどのように伝えられるかについての詳細は [Accounts](accounts.md#signers) を参照してください。

## 最近のブロックハッシュ

トランザクションには、重複を防ぎ、トランザクションに寿命を与えるための最新の[ブロックハッシュ](terminology.md#blockhash)が含まれています。 以前のトランザクションと完全に同一のトランザクションは拒否されるため、新しいブロックハッシュを追加することで、複数のトランザクションが全く同じ動作を繰り返すことができます。 また、トランザクションにはブロックハッシュによって定義される寿命があり、ブロックハッシュが古すぎるトランザクションは拒否されます。
