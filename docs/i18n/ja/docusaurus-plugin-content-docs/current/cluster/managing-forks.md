---
title: フォークの管理
---

台帳は、スロットの境界でフォークすることが許されています。 結果として得られるデータ構造は、*ブロックストア*と呼ばれるツリーを形成します。 バリデータがブロックストアを解釈する際には、チェーン内の各フォークの状態を保持する必要があります。 ここでは各インスタンスを*アクティブなフォーク*と呼ぶことにします。 これらのフォークを評価し、最終的にフォークを選択できるようにするのがバリデータの責任です。

バリデータは、フォークのスロットリーダに投票を行うことでフォークを選択します。 この投票は、*ロックアウト期間*と呼ばれる一定期間、バリデータをコミットします。 ロックアウト期間が終了するまで、バリデータは別のフォークに投票することはできません。 同じフォークで次の投票を行うと、ロックアウト期間の長さは倍になります。 クラスタが設定した投票数 \(現在は 32\)、を超えると、 ロックアウト期間は、*最大ロックアウト*と呼ばれる状態になります。 最大ロックアウト数に達するまで、バリデータはロックアウト期間が終了するのを待ってから別のフォークに投票するという選択肢を持つことができます。 別のフォークに投票する際には、*ロールバック*と呼ばれる操作を行います。これは、状態を共有チェックポイントまで時間を巻き戻してから、 先ほど投票したフォークの先端までジャンプさせるというものです。 フォークがロールバックできる最大の距離を*ロールバックデプス*と呼びます。 ロールバックの深さとは、最大ロックアウトを達成するために必要な投票数のことです。 バリデータが投票するたびに、ロールバック深度を超えたチェックポイントは到達できなくなります。 つまり、バリデータがロールバック深度を超えてロールバックする必要があるシナリオはありません。 したがって、バリデータは到達できないフォークを安全に*刈り取り*、 ロールバックの深さを越えたすべてのチェックポイントをルートチェックポイントに *押し込む*ことができます。

## アクティブなフォーク

アクティブなフォークとは、ロールバックの深さよりも少なくとも 1 つ長い長さを持つチェックポイントのシーケンスのことです。 最短のフォークは、ロールバックの深さよりもちょうど 1 つ長い長さを持ちます。 例えば、以下のようになります。

![フォーク](/img/forks.svg)

以下のシーケンスは、*アクティブなフォーク*です。

- {4, 2, 1}
- {5, 2, 1}
- {6, 3, 1}
- {7, 3, 1}

## 剪定とスカッシング

バリデータは、ツリー上のどのチェックポイントに対しても投票することができます。 上の図では、木の葉を除くすべてのノードです。 投票の後、バリデータはロールバックの深さよりも遠いところからフォークしてきたノードを刈り取り、 できる限りのノードをルートに押し込むことでメモリ使用量を最小限に抑える機会を得ます。

上の例から、ロールバックの深さを"2"とし、"5"への投票と"6"への投票を考えてみましょう。 まず、"5"への投票です。

![剪定後のフォーク](/img/forks-pruned.svg)

新しいルートは"2"で、"2"からの子孫ではないアクティブなフォークはすべて刈り取られます。

あるいは、"6"の投票。

![フォーク](/img/forks-pruned2.svg)

"6"から始まるアクティブなフォークはルートから 2 チェックポイントしか離れていないので、ツリーのルートは"1"のままです。
