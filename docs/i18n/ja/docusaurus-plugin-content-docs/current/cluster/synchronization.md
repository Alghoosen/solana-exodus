---
title: 同期
---

Solana がこのような高いスループットを実現できている最大の理由は、高速で信頼性の高い同期にあります。 従来のブロックチェーンでは、ブロックと呼ばれる大きなトランザクションの塊で同期をとっていました。 ブロックで同期することで、"ブロックタイム"と呼ばれる期間が経過するまでトランザクションは処理されません。 Proof of Work コンセンサスでは、複数の検証者が同時に新しい有効なブロックを生成する確率を最小化するために、このブロックタイム \(最大 10 分\) を非常に大きくする必要があります。 Proof of Stake コンセンサスではそのような制約はありませんが、信頼できるタイムスタンプがなければ検証者はブロックの順番を決めることができません。 一般的な回避策は、各ブロックに[ウォールクロックのタイムスタンプ](https://en.bitcoin.it/wiki/Block_timestamp)を付けることです。 しかし、時計のズレやネットワークの遅延のばらつきがあるため、タイムスタンプの精度は 1 ～ 2 時間程度しかありません。 回避策として、これらのシステムはブロック時間を長くして、各ブロックのタイムスタンプの中央値が常に増加しているという合理的な確実性を提供しています。

Solana は、 _Proof of History_ または _PoH_ と呼ばれる非常に異なるアプローチを採用しています。 リーダノードは、最後の証明から一定時間が経過したことを示す暗号証明をブロックに"タイムスタンプ"します。 証明にハッシュ化されたすべてのデータは、その証明が生成される前に発生したものであることがほとんどです。 その後、ノードは新しいブロックをバリデータ・ノードと共有し、バリデータノードはその証明を検証することができます。 ブロックはバリデータにどのような順番でも到達することができ、数年後に再生されることもあります。 このような信頼性の高い同期保証により、Solana はブロックを _entries_ と呼ばれる小さなトランザクションに分解することができます。 エントリは、ブロックのコンセンサスが得られる前に、リアルタイムでバリデータにストリーミングされます。

Solana は技術的には*ブロック*を送信することはありませんが、*確認*を得るためにバリデータが投票する一連のエントリを表すためにブロックという言葉を使っています。 Solana の確認時間は、ブロックベースのシステムと比較することができます。 現在の実装では、ブロックタイムを 800ms に設定しています。

内部で何が起こっているかというと、リーダーノードが有効なトランザクションのセットをエントリにバッチ処理すると同時に、エントリがバリデータにストリーミングされます。 バリデータはそのエントリを、その有効性について投票するかなり前に処理します。 トランザクションを最適に処理することで、最後のエントリを受信してからノードが投票するまでの間、実質的に遅延はありません。 また、コンセンサスが得られ**なかった**場合には、ノードは単純に状態をロールバックします。 この最適処理技術は 1981 年に導入され、 [Optimistic Concurrency Control](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.65.4735) と呼ばれました。 この技術は、ある*ブロックの高さ*までの完全な元帳を表すハッシュにクラスタが投票するブロックチェーンアーキテクチャに適用できます。 Solana では、最後のエントリの PoH ハッシュを使って実装されます。

## VDF との関係

Proof of History 技術は、2017 年 11 月に Solana によってブロックチェーンで使用するために最初に記述されました。 翌年の 6 月には、同様の手法がスタンフォード大学で発表され、[verifiable delay function](https://eprint.iacr.org/2018/601.pdf)または*VDF*と呼ばれました。

VDF の望ましい特性は、検証時間が非常に速いことです。 遅延関数を検証するための Solana のアプローチは、それを作成するのにかかった時間に比例します。 4000 コアの GPU に分割しても、Solana のニーズに応えるには十分な速さですが、上記で\([ 引用した](https://github.com/solana-labs/solana/issues/388))、論文の著者に聞いてみると、Solana のアプローチはアルゴリズム的に遅く、VDF と呼ぶべきではない、と言うかもしれません。 私たちは、VDF という言葉は、検証可能な遅延関数のカテゴリーを表すものであり、特定の性能特性を持つサブセットを表すものではないと主張しています。 それが解決されるまで、Solana はアプリケーション固有の"VDF"に対して"PoH"という用語を使い続けるでしょう。

"PoH"と"VDF"のもう一つの違いは、"VDF"は継続時間の追跡にのみ使用されることです。 一方、"PoH のハッシュチェーン"には、アプリケーションが観測したあらゆるデータのハッシュが含まれています。 そのデータは諸刃の剣です。 一方では、データは「歴史を証明する」ものであり、ハッシュ以前にデータが存在していたことは間違いありません。 一方では、_データのハッシュ化のタイミングを変えることで_、アプリケーションがハッシュチェーンを操作できることを意味します。 そのため、"PoH チェーン"はランダム性の源としては適していませんが、データのない VDF であれば可能です。 たとえば、Solana の [のリーダ回転アルゴリズム](synchronization.md#leader-rotation)は、VDF _高さ_ からのみ導かれ、その高さのハッシュは得られません。

## コンセンサスメカニズムとの関係

"Proof of History"はコンセンサスのメカニズムではありませんが、Solana の"Proof of Stake" コンセンサスのパフォーマンスを向上させるために使用されます。 また、データプレーンのプロトコルの性能向上にも利用されています。

## 歴史の証明についての詳細

- [water clock analogy](https://medium.com/solana-labs/proof-of-history-explained-by-a-water-clock-e682183417b8)
- [Proof of History overview](https://medium.com/solana-labs/proof-of-history-a-clock-for-blockchain-cf47a61a9274)
