---
title: リーダローテーション
---

クラスタでは、ある瞬間に1人のバリデータだけが台帳のエントリを作成することになっています。 一度に1人のリーダーがいることで、すべての検証者は台帳の同一のコピーを再生することができます。 しかし、一度に1人のリーダしか存在しない場合、悪意のあるリーダが投票やトランザクションを検閲することができるという欠点があります。 打ち切りはネットワークがパケットを廃棄することと区別できないため、クラスターは単純に1つのノードを選出して無期限にリーダの役割を担わせることはできません。 代わりに、クラスタはどのノードが主導権を握るかを交代することで、悪意のあるリーダの影響を最小限に抑えます。

各バリデータは、後述する同じアルゴリズムを用いて、期待されるリーダを選択します。 バリデータが新しい署名済みの台帳エントリを受け取ったとき、そのエントリが予想されるリーダによって作成されたものであることを確信できるのです。 各リーダに割り当てられたスロットの順番を_リーダスケジュール_と呼びます。

## リーダスケジュールローテーション

バリデータは、 _スロット リーダー_ によって署名されていないブロックを拒否します。 すべてのスロットリーダーのアイデンティティのリストを_リーダスケジュール_と呼びます。 リーダのスケジュールは、局所的かつ定期的に再計算されます。 _エポック_と呼ばれる期間中、スロットリーダーを割り当てます。 スケジュールは、スケジュールの計算に使用する台帳の状態が確定するように、割り当てられるスロットのかなり前に計算されなければなりません。 その期間は _リーダスケジュールオフセット_ と呼ばれます。 Solanaは、次の時点までのスロットの長さにオフセットを設定します。 すなわち、エポックのリーダスケジュールは、前の時期の開始時に台帳状態から計算されます。 1 エポックのオフセットはかなり任意であり、すべてのバリデータが次のスケジュールが生成される前に台帳状態を確定するように十分に長いと仮定されます。 クラスタは、ステーキングの変更とリーダのスケジュール更新の間の時間を短縮するためにオフセットを短縮することを選択できます。

エポックよりも長いパーティションがなくても動作しますが、ルートフォークがエポック境界を横切ったときにのみスケジュールを生成する必要があります。 スケジュールは次の時期のためであるので、ルートフォークにコミットされた新しいステーキングは次の時期までアクティブになりません。 リーダスケジュールを生成するために使用されるブロックは、エポック境界を横断する最初のブロックです。

エポックより長く続くパーティションがなければ、クラスターは次のように動作します。

1. バリデータは投票時に独自のルートフォークを継続的に更新します。
2. バリデータは、スロットの高さがエポック境界を越えるたびにリーダスケジュールを更新します。

例:

エポック持続時間は100スロットです。 ルートフォークは"スロットの高さ99"で計算されるフォークから、"スロットの高さ102"で計算されるフォークに更新されます。 高さ100のスロットを持つフォークは、障害のためにスキップされました。 新しいリーダースケジュールは"スロットの高さ102"でフォークを使用して計算されます。 スロット200から再度更新されるまで有効です。

クラスタで投票するすべてのバリデータが、ルートが102を超えたときに100と101をスキップしたため、矛盾は存在できません。 投票パターンに関係なく、すべてのバリデータは、102または102の子孫のルートにコミットされます。

### "Epoch Sized Partitions"によるリーダスケジュールのローテーション。

リーダースケジュールオフセットの期間は、クラスタが正しいリーダースケジュールを一貫性のない見方をしている可能性と直接関係があります。

以下のシナリオを考えてみましょう。

それぞれのブロックの半分を生成している2つのパーティション。 どちらも決定的な過半数のフォークに来ていません。 両者ともエポック100と200を越えますが、実際にはルートにコミットすることなく、したがって新しいリーダのスケジュールにクラスタ全体でコミットすることになります。

この不安定なシナリオでは、複数の有効なリーダスケジュールが存在します。

- リーダスケジュールは、前の時点に直接親があるフォークごとに生成されます。
- リーダスケジュールは、子孫フォークの次の時代の開始後に更新されるまで有効です。

各パーティションのスケジュールは、パーティションがエポック以上続いた後に分かれます。 このため、エポック期間は、スロット時間と、フォークがルートにコミットされるまでの予想される長さよりもはるかに大きくなるように選択する必要があります。

十分な時間の間、クラスターを観察した後 リーダースケジュールオフセットはパーティションの中央値と標準偏差に基づいて選択できます 例えば、パーティション期間の中央値に6つの標準偏差を加えた値よりも長いオフセットがある場合、クラスタ内で不整合な台帳スケジュールが発生する可能性は100万分の1になります。

## Genesisでのリーダースケジュール生成

ジェネシスの構成は、最初の時代のリーダを宣言します。 リーダのスケジュールは次のエポックのスロット0でも生成されるため、このリーダは最初の2つのエポックにスケジュールされます。 最初の 2 つのエポックの長さは、"genesis"設定でも指定できます。 最初のエポックの最小長さは、 [タワー BFT](../implemented-proposals/tower-bft.md) で定義されているような最大ロールバック深度以上でなければなりません。

## リーダスケジュール生成アルゴリズム

リーダスケジュールは事前定義されたシードを使用して生成されます。 プロセスは次のとおりです。

1. 定期的にPoHティックの高さ\(単調に増加するカウンタ\) を使用して、安定した擬似ランダムアルゴリズムをシードします。
2. その高さで、クラスターで設定されたティック数の中で投票したリーダーIDを持つすべてのステーキングされた口座の銀行をサンプルします。 サンプルは _アクティブセット_と呼ばれます。
3. ステーキング量でアクティブなセットをソートします。
4. ランダムシードを使用してステーキングによって重み付けされたノードを選択し、ステーキングにおける重み付けの順序を作成します。
5. この順序は、クラスタが設定したティック数の後に有効になります。

## 攻撃ベクトルのスケジュール

### シード

選ばれるシードは予測可能ですが、偏りはありません。 その結果を左右するような研削攻撃はありません。

### アクティブセット

リーダはバリデータの投票を検閲することでアクティブセットを偏らせることができます。 リーダがアクティブセットを検閲するには2つの方法があります。

- バリデータからの投票を無視すること
- バリデータからの投票があるブロックへの投票を拒否すること

検閲の可能性を減らすために、アクティブセットは、_アクティブセットのサンプリング期間中_、リーダーのスケジュールオフセット境界で計算されます。 アクティブセットのサンプリング期間は、複数のリーダーによって票が収集されるように十分な長さです。

### ステーキング

リーダは新たなステーキング取引を検閲したり、新たなステーキングトランザクションを持つブロックの検証を拒否することができます。 この攻撃はバリデータの投票を検閲するのと似ています。

### バリデータの操作キー紛失

リーダとバリデータは操作に一時的なキーを使用することが期待され、ステーキングオーナーはデリゲーションによりバリデーターに自分のステーキングでの作業を許可します。

クラスタは、リーダーとバリデータが使用するすべての一時的なキーが失われても回復できるようにすべきです。これは、すべてのノードが共有するソフトウェアの脆弱性によって起こる可能性があります。 現在ステーキングがバリデータに委任されている場合でも、ステーキングの所有者はバリデータの投票に共同で署名することで直接投票できるようにすべきです。

## エントリの追加

リーダスケジュールの寿命を_エポック_と呼びます。 エポックは_スロット_に分割され、各スロットは`T` PoH tickの継続時間を持ちます。

リーダはそのスロットでエントリを送信します。 `T`ティックの後、すべてのバリデータは予定されている次のリーダに切り替えます。 バリデーター、リーダーの割り当てられたスロット以外で送信されたエントリを無視しなければなりません。

次のリーダが自分のエントリを作成するためには、すべての`T`ティックが観測されなければなりません。 エントリが観察されない場合 \(リーダがダウンした\) またはエントリが無効です \(リーダーにバグがある、または悪意がある\)、 次のリーダは前のリーダの枠を満たすために ティックを生成しなければなりません。 次のリーダはリペア要求を並行して行い、他のバリデーターが前のリーダのエントリの観測に失敗したと確信できるまで、ティックの送信を延期すべきであることに注意してください。 あるリーダが自分のティックを誤って構築した場合、後続のリーダーは自分のティックをすべて交換しなければなりません。
