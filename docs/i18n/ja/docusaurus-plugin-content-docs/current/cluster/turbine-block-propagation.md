---
title: Turbine Block Propagation
---

Solanaクラスタでは、_Turbine_と呼ばれるマルチレイヤーのブロック伝搬メカニズムを使用して、重複するメッセージを最小限に抑えながら、すべてのノードにトランザクションシュレッドをブロードキャストします。 クラスタは、自身を _neighborhoods_ と呼ばれる小さなノードのコレクションに分割します。 各ノードは、受信したデータを近隣の他のノードと共有する責任があります。 データを他の地域の小さなノードに伝えることができます この方法で、各ノードは少数のノードと通信する必要があります。

このスロットでは、リーダノードは最初の近所の \(レイヤー 0\) のバリデータノード間でシュレッダーを配布します。 各バリデータは、その近傍内でそのデータを共有しますが、また、次のレイヤー \(レイヤ ー1\) のいくつかの近傍のノードに切断されたデータを再送信します。 レイヤー-1ノードはそれぞれ近所のピアとデータを共有します。 クラスター内のすべてのノードが全てのシュレッドを受け取るまでノードに再送信します。

## Neighborhood Assignment - 重み付けの選択

データプレーンファンアウトが機能するためには、クラスターをどのようにネイバーフッドに分割するかについて、クラスタ全体が合意する必要があります。 これを実現するために、認識されたすべてのバリデータノード\(TVU peers\) がステーキングでソートされ、リストに格納されます。 このリストにさまざまな方法でインデックスを付け、ネイバーフッドの境界を把握し、ピアを再送します。 例えば、リーダは単純にレイヤー0を構成する最初のノードを選択します。 これらは自動的に最も高いステーキングホルダーとなり、最も重い投票が最初にリーダに戻ってくるようになります。 レイヤー0と下位レイヤーのノードは、同じロジックでネイバーフッドと次のレイヤーのピアを見つけます。

攻撃ベクトルの可能性を減らすために、各シュレッドはネイバーフッドのランダムなツリー上で送信されます。 各ノードは、クラスタを表す同じノードのセットを使用します。 リーダID、スロット、およびシュレッドインデックスから派生したシードを使用して、各シュレッドのセットからランダムなツリーが生成されます。

## レイヤーとネイバーフッド構造

現在のリーダは、最大でも`DATA_PLANE_FANOUT`ノードに対して初期ブロードキャストを行います このレイヤー0がクラスタ内のノード数よりも小さい場合、データプレーンファンアウト機構が下のレイヤーを追加します。 後続のレイヤーはこれらの制約に従ってレイヤキャパシティを決定します。各ネイバーフッドには`DATA_PLANE_FANOUT`ノードが含まれます。 レイヤー0は、ファンアウトノードを持つ1つのネイバーフッドから始まります。 各レイヤーのノード数は、ファンアウトの係数で増加します。

前述のように、レイヤの各ノードは、クラスタ内のすべてのTVUピアにブロードキャストするのではなく、ネイバーフッドのノードと、次のレイヤーのネイバーフッドにあるちょうど1つのノードにのみ、そのシュレッドをブロードキャストすれば良いです。 これを考えるには、レイヤー0はファンアウトノードを持つ1つのネイバーフッドから始まり、レイヤー1はファンアウトノードを持つネイバーフッドを追加し、レイヤー2は`ファンアウト*レイヤー1のノード数`、というようになります。

これにより、各ノードは`最大2 * DATA_PLANE_FANOUT - 1`のノードとのみ通信することができます。

次の図は、リーダーがファンアウトが2のシュレッドをレイヤー0のネイバーフッド0に送信し、ネイバーフッド0のノードがデータを共有する様子を示しています。

![リーダがレイヤー0のネイバーフッド0にシュレッドを送ります。](/img/data-plane-seeding.svg)

次の図は、ネイバーフッド0がネイバーフッド1と2にファンアウトする様子を示しています。

![ネイバーフッド 0 、ネイバーフッド 1、および2へのファンアウト](/img/data-plane-fanout.svg)

最後に、ファンアウトが2の2レイヤークラスターを以下の図に示します。

![ファンアウトが2の2層クラスタです](/img/data-plane.svg)

### 設定値

`DATA_PLANE_FANOUT` - レイヤー0のサイズを指定する。 後続のレイヤーは `DATA_PLANE_FANOUT` の倍数で成長する。 エリア内のノード数はファンアウト値と等しくなります。 つまり、もしあるものが満杯でなければ、それは_must_が最後のものであるということです。

クラスタが起動されたときに設定が行われます。 将来的には、これらのパラメータはオンチェーンでホストされる可能性があり、クラスタのサイズが変更されるとその場で変更できるようになります。

## 必要なFECレートの計算

Turbineはバリデータ間のパケットの再送信に依存しています。 再送により、ネットワーク全体のパケットロスは複合的になり、パケットが宛先に到達しない確率は、各ホップで増加します。 FECレートは、ネットワーク全体のパケットロスと伝搬深度を考慮に入れる必要があります。

シュレッドグループは、お互いを再構築するために使用するデータと符号化パケットのセットです。 各シュレッドグループは、FECレートを超えるパケット数の可能性に基づいて、失敗の可能性を持っています。 バリデータがシュレッドグループの再構築に失敗した場合は、 ブロックの再構築ができないので、バリデータはブロックを修正するために バリデータはブロックを修正するためにリペアに頼らなければなりません。

シュレッドグループが故障する確率は、二項分布を使って計算することができます。 FECレートが `16:4`の場合、グループサイズは20になります。 グループが失敗するには少なくとも4人は失敗しなければなりません。 これは、20のうち4つ以上のトレイルが失敗する確率の合計に等しくなります。

タービンで成功するブロックの確率:

- パケット失敗の確率: `P = 1 - (1 - network_packet_loss_rate)^2`
- FECレート: `K:M`
- 試行回数: `N = K + M`
- シュレッダー群失敗率: `S = i=0 -> バイナリ値の M (prob_failure = P, tries = N, failure = i)`
- ブロックごとのシュレッド: `G`
- ブロック成功率: `B = (1 - S) ^ (G / N)`
- 正確に `i` の二項分布の結果 N 試験における P の確率は `(N choose i) * P^i * (1 - P)^(N-i)` と定義されます。

例:

- ネットワークパケットロス率は15%です。
- 50kのTPSネットワークは毎秒6400シュレッダーを生成します。
- FECレートは、FEC比でブロックあたりのシュレッダーの総量を増加させます。

FECレート: `16:4`

- `G = 8000`
- `P = 1 - 0.85 * 0.85 = 1 - 0.72 = 0.2775`
- `S = i=0 -> 4 for binomial(prob_failure = 0.2775, trial = 20, failure = i) = 0.689414`
- `B = (1 - 0.689) ^ (8000 / 20) = 10^-203`

FECレート `16:16`

- `G = 12800`
- `S = i=0 -> 32 for binomial(prob_failure = 0.2775, trial = 64, failure = i) = 0.002132`
- `B = (1 - 0.002132) ^ (12800 / 32) = 0.42583`

FECレート `32:32`

- `G = 12800`
- `S = i=0 -> 32 for binomial(prob_failure = 0.2775, trial = 64, failure = i) = 0.000048`
- `B = (1 - 0.000048) ^ (12800 / 64) = 0.99045`

## Neighborhoods

次の図は、異なる層の2つのネイバーフッドがどのように相互作用するかを示しています。 ネイバーフッドを不自由にするためには、上記のエリアから十分なノード \(消去コード +1\) が失敗する必要があります。 各ネイバーフッドは上層の近所内の複数のノードから切断されるので. 上層部のネットワーク障害が不完全なデータで終わる必要があります

![ネイバーフッド内の仕事](/img/data-plane-neighborhood.svg)
