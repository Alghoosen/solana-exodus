---
title: Turbine Block Propagation
---

Solana クラスタでは、*Turbine*と呼ばれるマルチレイヤーのブロック伝搬メカニズムを使用して、重複するメッセージを最小限に抑えながら、すべてのノードにトランザクションシュレッドをブロードキャストします。 クラスタは、自身を _neighborhoods_ と呼ばれる小さなノードのコレクションに分割します。 各ノードは、受信したデータを近隣の他のノードと共有する責任があります。 データを他の地域の小さなノードに伝えることができます この方法で、各ノードは少数のノードと通信する必要があります。

このスロットでは、リーダノードは最初の近所の \(レイヤー 0\) のバリデータノード間でシュレッダーを配布します。 各バリデータは、その近傍内でそのデータを共有しますが、また、次のレイヤー \(レイヤ ー 1\) のいくつかの近傍のノードに切断されたデータを再送信します。 レイヤー-1 ノードはそれぞれ近所のピアとデータを共有します。 クラスター内のすべてのノードが全てのシュレッドを受け取るまでノードに再送信します。

## Neighborhood Assignment - 重み付けの選択

データプレーンファンアウトが機能するためには、クラスターをどのようにネイバーフッドに分割するかについて、クラスタ全体が合意する必要があります。 これを実現するために、認識されたすべてのバリデータノード\(TVU peers\) がステーキングでソートされ、リストに格納されます。 このリストにさまざまな方法でインデックスを付け、ネイバーフッドの境界を把握し、ピアを再送します。 例えば、リーダは単純にレイヤー 0 を構成する最初のノードを選択します。 これらは自動的に最も高いステーキングホルダーとなり、最も重い投票が最初にリーダに戻ってくるようになります。 レイヤー 0 と下位レイヤーのノードは、同じロジックでネイバーフッドと次のレイヤーのピアを見つけます。

攻撃ベクトルの可能性を減らすために、各シュレッドはネイバーフッドのランダムなツリー上で送信されます。 各ノードは、クラスタを表す同じノードのセットを使用します。 リーダ ID、スロット、およびシュレッドインデックスから派生したシードを使用して、各シュレッドのセットからランダムなツリーが生成されます。

## レイヤーとネイバーフッド構造

現在のリーダは、最大でも`DATA_PLANE_FANOUT`ノードに対して初期ブロードキャストを行います このレイヤー 0 がクラスタ内のノード数よりも小さい場合、データプレーンファンアウト機構が下のレイヤーを追加します。 後続のレイヤーはこれらの制約に従ってレイヤキャパシティを決定します。各ネイバーフッドには`DATA_PLANE_FANOUT`ノードが含まれます。 レイヤー 0 は、ファンアウトノードを持つ 1 つのネイバーフッドから始まります。 各レイヤーのノード数は、ファンアウトの係数で増加します。

前述のように、レイヤの各ノードは、クラスタ内のすべての TVU ピアにブロードキャストするのではなく、ネイバーフッドのノードと、次のレイヤーのネイバーフッドにあるちょうど 1 つのノードにのみ、そのシュレッドをブロードキャストすれば良いです。 これを考えるには、レイヤー 0 はファンアウトノードを持つ 1 つのネイバーフッドから始まり、レイヤー 1 はファンアウトノードを持つネイバーフッドを追加し、レイヤー 2 は`ファンアウト*レイヤー1のノード数`、というようになります。

これにより、各ノードは`最大2 * DATA_PLANE_FANOUT - 1`のノードとのみ通信することができます。

次の図は、リーダーがファンアウトが 2 のシュレッドをレイヤー 0 のネイバーフッド 0 に送信し、ネイバーフッド 0 のノードがデータを共有する様子を示しています。

![リーダがレイヤー0のネイバーフッド0にシュレッドを送ります。](/img/data-plane-seeding.svg)

次の図は、ネイバーフッド 0 がネイバーフッド 1 と 2 にファンアウトする様子を示しています。

![ネイバーフッド 0 、ネイバーフッド 1、および2へのファンアウト](/img/data-plane-fanout.svg)

最後に、ファンアウトが 2 の 2 レイヤークラスターを以下の図に示します。

![ファンアウトが2の2層クラスタです](/img/data-plane.svg)

### 設定値

`DATA_PLANE_FANOUT` - レイヤー 0 のサイズを指定する。 後続のレイヤーは `DATA_PLANE_FANOUT` の倍数で成長する。 エリア内のノード数はファンアウト値と等しくなります。 つまり、もしあるものが満杯でなければ、それは*must*が最後のものであるということです。

クラスタが起動されたときに設定が行われます。 将来的には、これらのパラメータはオンチェーンでホストされる可能性があり、クラスタのサイズが変更されるとその場で変更できるようになります。

## 必要な FEC レートの計算

Turbine はバリデータ間のパケットの再送信に依存しています。 再送により、ネットワーク全体のパケットロスは複合的になり、パケットが宛先に到達しない確率は、各ホップで増加します。 FEC レートは、ネットワーク全体のパケットロスと伝搬深度を考慮に入れる必要があります。

シュレッドグループは、お互いを再構築するために使用するデータと符号化パケットのセットです。 各シュレッドグループは、FEC レートを超えるパケット数の可能性に基づいて、失敗の可能性を持っています。 バリデータがシュレッドグループの再構築に失敗した場合は、 ブロックの再構築ができないので、バリデータはブロックを修正するために バリデータはブロックを修正するためにリペアに頼らなければなりません。

シュレッドグループが故障する確率は、二項分布を使って計算することができます。 FEC レートが `16:4`の場合、グループサイズは 20 になります。 グループが失敗するには少なくとも 4 人は失敗しなければなりません。 これは、20 のうち 4 つ以上のトレイルが失敗する確率の合計に等しくなります。

タービンで成功するブロックの確率:

- パケット失敗の確率: `P = 1 - (1 - network_packet_loss_rate)^2`
- FEC レート: `K:M`
- 試行回数: `N = K + M`
- シュレッダー群失敗率: `S = i=0 -> バイナリ値の M (prob_failure = P, tries = N, failure = i)`
- ブロックごとのシュレッド: `G`
- ブロック成功率: `B = (1 - S) ^ (G / N)`
- 正確に `i` の二項分布の結果 N 試験における P の確率は `(N choose i) * P^i * (1 - P)^(N-i)` と定義されます。

例:

- ネットワークパケットロス率は 15%です。
- 50k の TPS ネットワークは毎秒 6400 シュレッダーを生成します。
- FEC レートは、FEC 比でブロックあたりのシュレッダーの総量を増加させます。

FEC レート: `16:4`

- `G = 8000`
- `P = 1 - 0.85 * 0.85 = 1 - 0.72 = 0.2775`
- `S = i=0 -> 4 for binomial(prob_failure = 0.2775, trial = 20, failure = i) = 0.689414`
- `B = (1 - 0.689) ^ (8000 / 20) = 10^-203`

FEC レート `16:16`

- `G = 12800`
- `S = i=0 -> 32 for binomial(prob_failure = 0.2775, trial = 64, failure = i) = 0.002132`
- `B = (1 - 0.002132) ^ (12800 / 32) = 0.42583`

FEC レート `32:32`

- `G = 12800`
- `S = i=0 -> 32 for binomial(prob_failure = 0.2775, trial = 64, failure = i) = 0.000048`
- `B = (1 - 0.000048) ^ (12800 / 64) = 0.99045`

## Neighborhoods

次の図は、異なる層の 2 つのネイバーフッドがどのように相互作用するかを示しています。 ネイバーフッドを不自由にするためには、上記のエリアから十分なノード \(消去コード +1\) が失敗する必要があります。 各ネイバーフッドは上層の近所内の複数のノードから切断されるので. 上層部のネットワーク障害が不完全なデータで終わる必要があります

![ネイバーフッド内の仕事](/img/data-plane-neighborhood.svg)
