# Leader and Validator Transition

A fullnode operates in two modes, leader and validator.  The modes overlap in
code and in function, but have different behaviors.  The goal for this design is
to allow the two modes to transition between states while reusing the computed
bank state.

The main design idea is centered around a synchronous loop that creates and
destroys Validator or Leader based on what slot was generated by PoH.  


## Validator

A validator operates on many different concurrent forks of the bank state until
it can prove a PoH record at a height that is the scheduled slot to be a leader.

The TVU won't operate on concurrent forks during its slot and that it doesn't
return to validating after its slot is over.

## Leader

A leader operates on a single fork for a specific PoH slot as
described in the [leader rotation](leader-rotation.md) document.


## PoH

Leaders and Validators use a different object for managing PoH. Each object only
work for a specific range of ticks and will error out and will notify the loop
when it is done.

### PoH Generator

This object handles PoH generation for a Validator.  It solves the following
problems for validators

1. Keep track of *time* as defined by PoH height, and stop the validator when it
hits the scheduled leader slot.

2. Reset the clock whenever a validator votes.  The last validator vote is the
validators most recent commitment. It is therefore the closest fork to the
scheduled slot.

3. Provide the entries that connect the last vote to the scheduled slot.

The interface to this object implements the following methods:

* new - Start the PoH thread, and compute it until end\_ticks.  This method
would take the starting hash the starting tick height and ending tick height and
create a PoH thread that runs until the end.

* restart - Restart the PoH thread at a new hash and reset height.  It still
runs until the configured ending tick height.

* final\_entries - Get the entries that connect the set of entries from the
restart point to the final tick as specified by new.

### PoH Recorder

This object handles PoH recording for a Leader.  It solves the following
problems:

1. Keep track of *time* as defined by PoH height, and stop the leader when it
gets to the end of its scheduled leader slot.

2. Register ticks with the BankState as they are produced by PoH.

3. Record entries that are produced by the TPU into PoH.

* new - Create a new recorder, with the starting entries as generated by the
Generator.  The recorder runs until the ending tick height, and registers ticks
with a BankState.

* record - Adds a vector of transactions to PoH, and register the tick with BankState.

## Fullnode Loop

This object manages the transition between modes.  The main idea is that once a
ledger is replayed, the validator can run until there is proof that it can be a
leader.  The Leader can then run and record its transactions.

The core idea is that the loop is synchronized to PoH, and does a synchronous
start and stop of a validator and leader while having a reference to all the
bank forks and the leader\_scheduler.  The following is pseudocode for the
loop:

The fullnode loop:

These components are passed in into the loop from the outside.

* forks - The Forks generated by replaying the ledger.

* leader\_scheduler - The leader\_scheduler generated by replaying the ledger.

* cluster\_info -  The network. The code to continuously receive and retransmit
blocks is owned by this.

* block\_tree -  The ledger.

loop:

1. Get my next scheduled slot.

2. Start the PoH Generator to run until the next scheduled slot.

3. Run the TVU over all the forks.

    a. TVU will send votes for votable forks.

4. Wait for PoH generator to finish.

5. Stop the TVU.

6. Get the entries connecting a voted slot in Forks to the scheduled leader slot.

7. Start a PoH recorder for the leader slot range of ticks.

8. Start the TPU over a BankState checkpoint for the leader slot.

9. Wait for the PoH recorder to finish.

    a. TPU will freeze BankState.  The vote will be sent in 3.

10. Goto 1.

## BankState

BankState is tracking changes to the runtime over a specific slot.  Once the
final tick has been registered the state becomes frozen and further writes
will error out.

Validators operate over a bunch of different BankStates that represent live
active chains.  A Leader only operates over a single BankState.
