# Pipeline Runtime + Move

This architecutre describes how Pipeline Runtime supports Resources and the Move
interpereter as defined by the (Move
whitepaper)[https://developers.libra.org/docs/move-paper].  A naive solution
with Move running in isolation over a single `Account::data` as its state
creates a sandbox that cannot interact across the global state machine.

Moveâ€™s Resources have a similar design motivatin to Solana Programs.  The
Resource implementation governs all the state transitions for the resource data,
regardless of what user the resource belongs to, including interpreting the
meaning of signatures.

To create a specific instance of a program, called a process, programs can be
associated with a read only context by the loader.  A process is used as an
implementation of a Move's resource.

## Accounts, Programs and Processes

### Account Map

Accounts are a map of an address to an account

* `Accounts = Map<AccountAddress, Account>`

### Account Address

The `AccountAddress` is a hash of the account pubkey that users self generate
and the owner pubkey.  With this change, a user only needs one pubkey, and it
exists for all owners.  The Account data base stores stores the Account pubkey
and the Owner pubkey so the index is recoverable.

* `AccountAddress = hash(Account pubkey, Owner pubkey)`

* `Accounts = Map<AccountAddress, Account>`

* `owner` - The process that is responsible for the state transitions of the
tokens and data in the `AccountAddress`.

### Programs

Programs are loaded by the Loader as BPF bytecode and are identified by the
pubkey of the program.  Programs are pure code without state.

### Loader::CreateProcess

A single user Pubkey has a valid address for every Owner.  To differentiate
between instaces of programs for specific process Loader::CreateProcess
instruction can be used to create a specific process instance of a program.
Loaders create processes by pairing a Program pubkey and a read only context
that is passed as the first parameter to all the program instructions.

## System::Allocate

This instruction is inherited by every Program, and appears as instruction 0.

* size: u64 - allocate the memeory length in `size` in bytes.  The memory is
zero initialized.

## Stored Transactions

A transaction can be generated by a Program.  It stored as a serialized message
in an `Account::data`, the data holds the stored transaction message and nothing
else at a known offset into the data.

The signatures of a stored transaction inherit from the caller.  So a caller
that supplies a signature for pubkey in the `AccountAddress`, allows any stored
transaction to execute `AccountAddress` as if it was signed by the pubkey.

Stored transactions can contain any instructions to any programs, and signatures
can accumulate.

## Stored Transaction Execution

The metadata of the `KeyedAccount` contains a few more bits of metadata

* a bit that indicates if the data is a stored transaction ready to execute,

* the offset of the Account::data the stored transaction resides at

* how to jump back to the script

To `yield`, the bytecode interpreter sets the execute bit and stores the last
instruction offset and aborts the current contract.

All the accounts referenced in the execution of the stored transaction must be
present in the caller's transaction.  This guarantees that the state is still
locked and immutable and has already been fetched.

## Scripts

A script is a program that generates a stored transaction that yields and
resumes from that transaction.

```

//from libra move whitepaper

public main(payee: address, amount: u64) {
  let coin: 0x0.Currency.Coin = 0x0.Currency.withdraw_from_sender(copy(amount));

  0x0.Currency.deposit(copy(payee), move(coin));

}

```

* `Currency::withdraw_from_sender`

Generates a reference to the coin, this could be compiled since the
`AccountAddress` is a reference.

* `Currency::deposit`

This generates a stored transaction that calls `Currency::deposit` instruction
from the payee address to the destination, which is the `hash(0x0, Currency
program owner pubkey)`.

The stored transaction yields, and then resumes back if necessary.
