//! @brief Example Rust-based BPF program that issues a ed25519 sig check cpi
use solana_program::{
    account_info::AccountInfo, ed25519_program, entrypoint, entrypoint::ProgramResult, msg,
    program::invoke, pubkey::Pubkey,
};

entrypoint!(process_instruction);
fn process_instruction(
    _program_id: &Pubkey,
    _accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    msg!("invoke ed25519 program");

    let public_key = [
        0x9eu8, 0xd8u8, 0x73u8, 0xf4u8, 0x31u8, 0xbdu8, 0x51u8, 0x59u8, 0x54u8, 0x1eu8, 0x6cu8,
        0xb6u8, 0xd9u8, 0x0eu8, 0xe7u8, 0x01u8, 0xd5u8, 0x53u8, 0xa6u8, 0xdfu8, 0x4cu8, 0x3au8,
        0x53u8, 0x72u8, 0x4fu8, 0x32u8, 0x3cu8, 0xbfu8, 0xfcu8, 0x03u8, 0x22u8, 0x90u8,
    ];
    let mut signature = [
        0x44u8, 0xf0u8, 0xcau8, 0xf8u8, 0x84u8, 0xd9u8, 0x62u8, 0xf6u8, 0x31u8, 0x35u8, 0xf4u8,
        0x55u8, 0x88u8, 0x5bu8, 0x69u8, 0x83u8, 0x8fu8, 0x82u8, 0x33u8, 0xe6u8, 0x44u8, 0x8au8,
        0x5cu8, 0x66u8, 0x02u8, 0x53u8, 0x8eu8, 0x80u8, 0xd9u8, 0xb4u8, 0x85u8, 0xbdu8, 0x88u8,
        0x38u8, 0xc8u8, 0x3au8, 0xb1u8, 0x1fu8, 0xd7u8, 0x1du8, 0xb9u8, 0xfeu8, 0xf8u8, 0x99u8,
        0x7cu8, 0xfbu8, 0x04u8, 0x61u8, 0xc3u8, 0xf9u8, 0x58u8, 0x78u8, 0x7fu8, 0x7fu8, 0xf4u8,
        0x83u8, 0xb8u8, 0xafu8, 0xaau8, 0x17u8, 0xa1u8, 0xdau8, 0x14u8, 0x08u8,
    ];
    let message =
        b"This is a test of the ed25519 sig check for the ed25519 signature check program";

    // flip some bits
    signature[0] ^= instruction_data[0];

    let instruction = ed25519_program::new_ed25519_instruction(&public_key, &signature, message);

    invoke(&instruction, &[]).expect("too succeed");

    Ok(())
}
